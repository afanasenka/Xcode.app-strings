@(#)PROGRAM:SceneKit  PROJECT:SceneKit-556
0E333333
MbP?
77777777777777770000000000000000
MbP?
>333?
>fff?
333333
?333333
I@333333
?ffffff
?333333
Mb`?
_,b?_,b?_,b?
kvz=kvz=kvz=
VUU
VUU
i\)7.
blnOq
sy2-
i\)7.
blnOq
sy2-
#<q=
p]?UUUUUU
?BxM@
?A.}?
\\CR+
?b]\BR+
!BR+
?rF\AR+
;A9)
!A '
,>I
u^@Jb
?p[M@8g
g&X=b
!!J=
fl(=7
)z =;
?pA6
7R6<<
yj?%
Mh?Z
#=;
xC%]
/A%]
|@%]
/@%]
|?5]
P?%]
/?%]
?hQ;A6
@!@F
g>h]
@>1^
?@%@!:D
?#,*
 {}=
u?|`G
#q<A
?`vo?
lI<U
nj?v
?MMf?
b?0b
~?cC[Cw
B[Bw
!A@
~?op
/[A^
~?lh
~?vl]@\U
L@e4
ywt>n
W'7>
!\!>
n=9{
?o*r?
?^Lo?
JDx<4
y;B<
5h?'
CGv}?
DCGv}?
DBGv}?
AGv}?
DAGv}?g*
@Gv}?QNZBC
@Gv}?Mc BC
@Gv}?/
D@Gv}?
@Gv}?v(
?Wv}?+
?Wv}?
?Wv}?
?hv}?
I Ae
?hv}?
_~_?yv}?
v}?oG
-?!w}?
y}?%x
w}??+
x}?T
=@)>
-AV>
SXI>
~?g|
>k+~?
>S@~?
?MKl
cCw=
K;5=
?sex?X
l? Aq
?6;j?
4f?}
?2td?
|?V4
|?^;
|?AM
+nA@
|?WF
|?:&
X?A|?
-?75|?D4
|?(`[@
.@u:
>hA|?
>-y|?
B[^>
}?m6
0>l$}?,
&>9G}?B
~?[C
=G;~?
=Qg~?
R||=eR
?SYl?
?Igd?
58D@Pz?\
C@Pz?q
B@Pz?
B@Pz?%
A@Pz?
-;A@Pz?
A@Pz?%b
@@Pz?
@@Pz?9
og@PPz?
&;@PPz?
@aPz?
@rPz?
Pz?+
?]Qz?
f?d[z?0v
lz?@
?XVz?
\z?.
?*pz?:wI@
:@s,
-@:"
z??T"@C
}_>I
{?=H
.8S>
<>^K|?
>&8}?
w}?@
j~?%Z
?!g
~?kI
?!;{?
8ho=
?G=t?2
n?Dj
?> l?
g?C9Q
f?hz
Rd?r7
Gx?f
Gx?<
t3@(Hx?
@IHx?
@kHx?^
Hx?3
Ix?k
Lx?r
?%\x?
A*q?e
G<5?DQx?
%?:[x?
cX@m
yx?\
x?K?9@G
>,ay?
>Y3z?
pz?c
tg>[
5^Z>e
M>=H{?
{?6!
=|?gC
|?4f
&~?A
=&m~?
~?F#w?~
?K:n?
?5Ad?;
u?nK
u?jP
RH+A
@#fF
u?za
Bv?{I
w?ZJv?W\
%a?a5v?c
v?%$i@9
<v?\
?J]v?
@xC:
v?eT@
>q<w?Zg
?c^'
%x?k
>lvx?
OZx>
~y?l
y??p
/3\>RHz?
A>2 {?
%\(>T
>#h|?mX
}?%]
~?Xps?
N&n=
?Swi?
Rs?h
jV?B
Rs?Z
BB%^
Ss?i
@.Ss?
AG ^
@PSs?
cyAv
IG?@
"@~Ts?
x}@
Us?y
@S@Z
\{?L
f@:w[
}s?ccT@L
N|A?%
`s2?_
s?h!)@b
@x*P
Ht?3
>`tu?E
>F}v?
>Ww?
y?m7
XVJ>
CU<>w
.>t}{?
=`=~?
m?zq"
`=0f
@k?`
,,8=W
?W]g?
e?UlL
ip?Q
ip?@
ip?u
@]jp?
R@Hkp?n^0Aj
@t|t
?Cpp?28
?Oyp?
p?{ 
p?A+d@W[q
,aU?
A@pCl
5$6?8,q?/3'@v
q?hz
q?dw
?)#r?$
qr?_
>yxs?bJ
?`ZD
t?F
du?p
5]_>
|z?J
Q|?v
|?t}?K
u?ZI
=tD~?
o?y\T
j?tF
?_%g?
?1{e?
cb? 
8m?Y
8m?`WLC
8m?n
A"9m?H
@u9m?
9m?a
@`:m?
;m?s
;m?Z
(@2=m?
>m?W
@-Bm?
?/Qm?
m?p\?@m
n?[|
?9}m
o?((
?SXi
p?*W
>)uq?
?1|4
>zru?
8v?h
w?;8
YR>shy?
>[@|?
u?>y
}?WCr?
l?->E
}X/=V
?8Ke?
r%<n
?RDb?
WICz5
6lxB;
VIB+4
oAt'
~+A7
?(Fj?a
?GVj?pP
?gCj?
aL@jk
<@#J
"@Y5
9?Idk?
?T:l?
?*ow
n?G9
?\tR
?uv2
av?I+
Sw?E
>x?f
9aR>
f11>
L|?l
x?B\
~?${l?v
~?ZJj?
|r=II
?l[h?
J='
e?p_
?B%b?j
f?q&FC
f?;!FB2
f?>{
M*@'
@EKf?
}f?M
f?d>I@
9@oF
[,@U
if?yYg?F\ @
jG?]
Hh?9
?-|i?
?[j?
?9*w
m?]1
n?=c
?FzQ
s?C7
?C86
6u>?
y?1~
y?Q/
"5->
w|?r
=$)}?
q?pa
=/P~?n
l?mTg
?vmc?
t@PA
BA7o
N5@2
@Zeb?1
E@2:
?v7c?<
&ru?K
$:?f
e?]R
ze?|+
f?bg
?;og?
?J)h?
>@jo?
?jL8
Mhr>7
9>%$z?
{?gdt?
q}?,En?
k?Q/x
\=bf
Gc?*
]?t`BL
a_\A
]?$ZcA
F\@C
@K>^?
@Mh^?
MB@HO
5_?<
&@>=
o`?\
M/E?
$?!;c?B
k?jK
?6!-
u?dv
2x?b
E>Yy?
pz?yxw?n
>]O|?
Yk?_
g~?8,i?
~?.Wg?H5,
duk=
rQ-=
?fld?-z
`"^<
a?RI
_Y?{
_Y?=:;C
1B `Y?,
A1`Y?:8;B
LA$cY?
gY?A1;A
g@zrY?
&Z?C~
?gCZ?U3v@
Z?vo>@
,0@v
[#@0
?BZ[?d 
S[~?{
[?h$
W\?~V
O?t]?
ByC?
&8?)
?[^y
j?% 
?g|o
>Zl?Q
>74q?0d
?H67
O |>
e>37w?/
 B<>
v?|(
{?8gp?
y=i:
?>xe?
L8=y
17C0
T?]+7B-
T?O=
hU?i
@V?of:@
W?h^
Z?p]Y?
Ig,?
?! _?
a?of
>]Oh?
uo?y
?w1M
0s><2v?
dx\>
Cz? $s?k
>Va{?
<}?_
`h?L8t
c? 
?->a?Z
9()
O?+X
2B6"
N}Al
O?)}
O?~{
&8}@l
P?{i
nQ?]
E@d\
^R?9
S?R&
AV?l
U?)"
y J?
*?Q1Z?
?5}^?
a?l\
? }c
`s?_B
>u"u?{/~?
gh>"
Q>(Hx??Tv?
l?%t
|?o.j?@
=Sz~?
8f?\TK
d?2r
M= y
^b?(
J?<t
hnID0
hICA
J?Gp{B
J?Qg{A
J?PE
hK?3
R@9^
?(,M?
?_AN?{
4G?|
dY?,F
?OYm
?:ZE
N~[>
az?4/o?
Pl?]
=&R~?5
O!W=<k
E6rE?
cPDGrE?ER
`PCGrE?
BXrE?
w_PB
sE?<
vE?}(
yE?|
A(}E?
`JAk
dF?$Q
`@80
?8.G?
?%xG?
G?aR-@cc
H?nR
?kfI?'i
K?;R
L?u;
N?|`O?
@R?0
i6'?
b? )
>)wg?k
Al?Gq
n?)_
t?T5y?&W!
voe>g
v?6ru?HR
]x?8
>j.{?
S}?G:g?
=R)~?wge?
a%C}
@?'(nB
@?N!nA
Ap>
@[%@?
@y<A?
<B?@
6@5z
?`WC?Y
?{gD?
?VHE?
o~?2ZG?
xCb?
&V?x
\?I
>jKe?z
>t~j?
do?@
q?F"|?it7
<>TTy?
3%>i
j=3N
RcEd
E8e:?
\D8e:?+
\CIe:?
BZe:?Q
e:?1&gB`
B4f:?
AAg:?7
i:?q
k:?3
o:?D.gA
t:?;
|:?l
U{@I
S;?+O
#@p"
>?31
?`;@?l=
?ULA?'J
? zB?
ui?!"E?~S
Q?l!H?M
o/=?
N?OW
TP?Z
>A+`?
>,gk?l?
GD>`
Zz?Q
~?;5c?
?m6b?
_?RI
_\ESX
 bC'
4?!N
4?\*9A
763@&
 @9'6?
PM@.
?|d7?
f8?!u
8?l[
>?pA
bJp?
i@?q
c}'?
'O?9
W?Aa
q?oHw?l@4
J&g>jNv?n
K>}<x?
|m?~
.?XY
.?\E
%p6A
%3AP
.??G
.??D
i/?)
iog@m
K!M@
yy$@\r0?
J1?R
W2?/
5?Bz
d=?;4
S?jKA?O
$?;pN?
tQ?P
e?*o
?-@{
>h"h?Z
>b,k?
p?+lv?
%8>c{y?
4j?*
`e?m
=-|}?
=Dj~?UOb?-]A
?W]_?{i
LkDY
h%kB
SQBY
UQAHm
-A~Q
(?/b
@g))?
s:@l>*?
GS@7
j0?s
1B|?b
LTc?
:?` 
<KD?
?`#U?
X?1C
>f.\?/
_?5$
>o)c?
f?mU~?
r?l>.
=XS}?
=sL~?]
,`?;
FEen
yA9B
"?q"A
@_)#?
zz@)
f=@wI$?7Pa@
JF*@Y
J)?lC
?5+?Ve
?aq,?
h?t%6?M
o??9
/6?&9D?
z$?4
?/PR?9
Y?>{
]?/0
Ph?]Qz?
x?\;i?d
=[$}?
ia?{JN
oAMe
o Ak,
?@cD
2@@L
A#@:
@zo ?f
?o+!?
$?c+
?g'?
PnW?
:?,}@?
W?~5
>W|[?
d{?J
>sLj?
p?9Cq?hA8
9J>K!x?
!f?d
c?jP
|?)#b?
?Mg_?
E^?A
>tD;:
+UtC~:
LtB6;
S:Be
LKtA=I
AA&R
?)]:AO
,Y@2
A@T6
-`.@
?,b ?
}#?J
%?S]
}?X;*?
rq?0
('f?
~s[?,
2?8e
cY?<
>2wa?H
y?O=
>gce?
o>aUu?
>9`{?
c`?g,Z
rSC=M
c\Ap
eyBA
?Sxx@
$@-w
"?>>
`%?y
-(?V
K_? _.?k
uwU?
Q9?v
=?c_
y\0?
?W^N?z6
z}?n
OW?p
y?lC
_?Z)x?
c?@1v?*
8t?+
o?FDA
*u>~
U>;5w?
g7>uXy?^
e?Zb
> ${?
_?F&`
H=J{
^?!w
p]?()
=_wC%
|^wB!
*BBC
n?:
x?9{#?h
E?$c5?rS
GG?(
L|?
z?/j
Jy?D
>dvb?
s?KXk
gj??6q?
8q?K[l?
2V{>w.t?
{d?(
z?wKb?
^?>v
M=%t
?Y) E
?7I~C
xCM1
@~B2
wB{2
?7H~A
CAeR
b@'P
J@sf
i8E@
5%@)Z
p?="?Eh
3nR?*
-6?`
:?nR}?GU
D?%yz?p_
BN?4
S?(*w?fO
>UPe?K
>;Vi?
Sv?;pf?
>8H|?
^?Xtk
>tBs@
W@81
Hj1@
?o~?
ms?y
p$L?DO.?j
Qz?z
Pu?b
q?ZI
>QNh?
8l?_
m?1&M
xze>
2D>%Xx?
|{W=ge
hUwCj
eBEF
ZswB*
PcwA
a5A%
isCA
t\@'
>yW7@
"1@V
$D @D
wk?6r
#s?N
)O?*:r?
j?wI<
|r?q
g?Kw'
i>;qu?
Re?>
)>A-z?rm`?
?^f\?d>
z[?8
O9()
aYDq
#RvD
>Z7YC
aUw@B'
>.:B@
-@3k
D@0g
j0@s
}?:A
l#Z?<
C=Q?
e'?m
#H?hw,?
p?Ec
8.??U
KY6?
T5-?
k<?F
W?\Xo?_^
n?}=
j?HQk?BxT
hn?,Fi?
g?NE*
P}?p
\?i7z
Z?0e
TtDT
v]tC
MtB!
%@/@
?kz?5
?(~?
r?|c
?vnn?
RS?}
$?"6l?
q=J?@M)?B>l?
{8?cF4?
Hm?D
m?x^
?R_V?_|m?
i?TWj?
^q?@Pf?,F-
c?|E
bw?vka?&W
{?5@]?\
[?O?(
d=HQ
?4/[?
Rq?{O
z?B|?
#k?Y5
q?s*
[i?0d
g?d!
?Ich? D
^?LT
Fg?`!
iL?6;&?
Cg?@
DNC?
1?{gh?
1?$|7?S
x(?5c=?!
?bfC?
j?B$
/k?M
?;TO?p[k?
xk?6
z_?m
k?+m
>qVd?
 j?>
PS>(
y?qs^?-
>R}{?
`~?c
Z?AD*
4Cro
GlAPT
4A[B
>S>O@l
Yjp@
>r4"@2
>@S@
>h=l?
e?h$
B#|?YL
gr?6<
h?gb
V?;q
]c?UN
T:<?1(/?j
Gt3?
e?pB
K;?K
`A?%
tc?X
>\!h?-
hb?t
>2V{?=
.Z?3O.
u*kD}x
kC%y
%AR@
DN)@p?
z?,
>o-c?
]?I,
U4j?/
[?('
>vO?
M ?Ii^?
G?tz&?
t_?z
`?]5
c?AJ
E?/5f?R
Ig?g
?k'R?i
{]?k-h?
Y~>Xps?
[Y>$
\?#1
>b,{?W
=kF~?
mY?xE0
o=%>
?)$Y?
TX?Ug59
fD5y
fCcz
v?j.
#]?S
>2!V?-
U?. 
B$k?
Ib?@
4X?+
?H?
??_\*?
v6?P
f7?3
V?||f?
>k?]
>O[o?Fc?
S9>m
{?l]Z?
Psr=
0bD[
Q5bCE
>A`>
oH5@
qW#@-
O?7Q
?&rQ?o
<S?g
B!R?
?`#U?
[?p%
_?Af
B?t\a?
2I? 
c?[C
[?*7e?
PS;>
[?Sw
z?d\Y?1
|?2>X?: 
)~?o
\D76
\C"7
N~.A
M@hu
^@lZ
~;1@<
>34z?
d?%\
vH?k
?tzJ?
4/S?
U?ys
lA?k*_?Q2
H?x
T?,cc?
d?Qkz
^r?F
uw=>}zx?
YW?#
<x=0,
U?M.F9{i
VA9c
y#@r
Tqv@
4Y@:x
@?[#
{?XW
A?IG
?~9G?$
I?zQ
S?PQ
+kK?
?vmO?s
#?_\R?
W?nl
Z?ca
uM?v
`?Xq
c_?[
d?8Nb?(Ig
ta?p]Q
>D0n?
c>:yu?
[?9G
|?_{V?>
E28j>.
.PD28j>
apPC
:j>(
B.=j>
Ej>9
OlPAc
q@[]
y;@u
r?J_
>?UY?
W8?*T
>Zg8?
>Eg9?
;?0G
g|k?
c?Jb
!B?Q
\!\?4
IcT?
1?KW0?n
>?hyZ?
Ga?w
#d?^+a?
k`?v
e>NFu?
/x?^
vU?*
|=h#
T?w,
nIDK U>
pICd"U>
kIBs.U>
A2uW>er[@
[>%\
G`>l
 L@;9c>
?_\z>
o?t~
3?/k
P1?:
3?,+
5?29
Dc?q8
@?s-
-CD?
+O?Qi
.?=IR?
rQ)?cD6?
U?x%
*?5
?EGR?
9^?/
T^?Z
_?R(k
Xm?8
>|}q?%
u?B{Y?4
x?]5W?
q|?{gT?
#|Dg&
Am:B>
@cGC>
jD>[#'@
7_@F`L>$
@>%W>
1k?1
C?6t
>*o'?
'?p}
>+Q*?T
d,?Z
2?[&
H5?e
5`T?
?of@?
?)<D?
nH?D
><?t`%?
9E3?
O?we
O=*?M
l<? 
Z?ip
>Qjc?hu^?Uik
]?P9V
 >{iz?
T?X7
g|?tbS?
R?y]
EG8->
=->Q
:B|G->
]->~O
:AI+.>
2@tb
1>8J
@"U4>
Su@l
2WV@
>9>b
Dm(@
@>Ig
?bhU>
G?qq
? cn>h
>h[)?:
M1o?}<
S?yv
<?<2
@L? 
*?_~3?
1\!?
;;?O
S?v3
cW?(H\?>
w]?b
c?W@]?
>*8h?
AE>K
&">WCz?
>Oy@@
j@36$>|
K>3Q,?
?Dku>x
I*{?2W
cat?q
>"U$?W
+?*o
4?oI
R?kH?tA9?
uYD?H
?I+B?
"?7RF?
8*?V
T?J@
?9)P?nRY?
[?-@k
>v6|?
eP?Z
@D% 
3z\A
Y*@%
@4C@
!u?`
|!>O
J?(c
:?.q
 Z> 
?-!
1l?=G
~#?1\
e?4f
6#_?
$1?.
?(|:?
?d:H?
?$aO?
Z?h\
X?X:?
j>k~t?a
3E>J
>^0|?
}?_DO?
O?u"
?:>N?
*-D&
b^PA,
=x%8@[_
t@DN
>o/q?
>kcX?Pn
>EID?vq
?nn,>
YY>m
?1h>
Vx>kD
JEW?b
-?,~
P?*p
2?kJ
7?Kr
?6\<?
);?K
H63?-])?.UE?
U"?{k8?
P?<J
X?dxl
>wig?TUX?
p?YnU?
aE>
O?>>
lN?G
L?0b
LIBB
=>iIA`
CA,
|,?p"
\>B%
Zy?w
?. 
-\?1#
?^g/?F
`H?j
lA?y
C?B`
M?T6T?
ra?kdW?k
.T?4
'P?FA
>S>|?u"M?
L?B@>
4L?H
FK?I
+Ce6
l,B\8
=Fu,Az5
AOy
{@q9
]4:@i
2L?u
?Nd&>
mb>2
?&nu>
Hkp?
>io?/
o`?1
]Z?ZF
HkT?
TVG?
!Y@?%v
mE?5'
?;9G?
(p?a
F>h]w?@
5|?:\K?
*gA
F]G@
E?Cs
?y=(>Re
?f3G>D
}?Tt
%h?i
bL?!
[?1T?+
S?BxD
@kn>
BO?@
iy=y;
Bmuy=)
@Y@x_u
TAFx{=
~=y;
>RF|
->lv
x?I,
j?`>
`?Di
[?XU
N)W?
?j4!?/
?~T'?
-?Yl
=?8j
RH6?N
8?>]
$G&?j
wA?9
,I?&
[L?;
[?-&R?
>]Ra?
>_@k?*VQ?
hs?J
qG>V
H?tB
G?K;
B['^
Ao.^
@b-^
AR(K=
K=ur.@
~?YR^
S?Tr^
r'@5
>Lkc
>LRi
]}?W
^>_$
]x?C
s?5}
o?@j
2^?B%
I?2Y
*?x(
W0?[
e??'
^G?$
?6!I?
{V?s
(b?^
)p?k(M?L
s?!VK?
}?cAE?J
Q*+BH
9!=~
5<wA
n+Amp"=
/$=^
Z&=S
F~y@
?O@w
>whH
>gDI
>\WL
?O#m=
>>\R
>c'\
{?Z)D>
v?LmY>
zpo?
g?2u
`? `
[?EH
":?t
]o+?
v8?4
u=?rp
I?3QH?z
b?7qN?
L?3P9
B>rjw?u?G?
+4 >J
%D?wh
mB?6[
QA?:
o@VJ/
@0,/
?n1/
?I=D
>]P?
>XtK
Pq?XrU>V
g?rR
c?}x
?{K
O?*6
bK?O<
, ?{
C??H
L8?~
,?p|
1?LU"?
/1?-
B?$BC?
-J?g}F?
!Q?|
Tm?k
gq?~
>Vfz?
=Ed|?
B?,G
0@W'
2?RG
w>A(
?S[*=
-c>n
=&Se>
>3Qd
;p~?
iWy?
;h?6
e?y 
M?5}
\;I?h
vo=?
\6?
*?vl4?
N ?EJ3?g
?RC;?
=?GW
gJ?taD?
>DoQ?
c?K>J?
m?<OH?
q?p{F?0
\>h[u?
9>GTx?
?.v;?
X}<`
X}<6t
3tA{2
<pB]?
<|ds>
&=`t9>
<>_%
I>W`8
<fx?
Xt?YN
Y?((
]oS?a
E?!#
54?U4
q-?SB
<^?%
H?XSY
tY>r
u?9bA?
75>n
z?Mj<?
};?8.c
=1_~?
[Z=Ee
r"<*
I$DB
#<@1
8G? $
@>"&<
f:<b1
!F<bIY>82
?,go<
.=nm!>
(>HR"
<X>K
=zpg>
|Eg?
=Umw>k
b?SA%>7m
Q>IM
M.2?
P,?#
"?-!+?.r
4?V,
[;?,a9?=C
XJ?f2@?
EQ?1
FE?}
h?h=D?L
B?Bv.
su?9
<?vp
1>Pqx?g
z?`x9?
|?tF8?
7?wf
5?9&
tR:D
6)<G
I<RF
E}?*
k#=y
mD=y
+>dw1
d?LP
Q1b?
{;>G
P4W?
-@W?
lCU?
<jT?d
<?d\
)!0?
tD*?
6?'1
=?=I
??n2
>QfW?.
A?dx\
>D5m?
Z=?G
(S>k
|?}v4?
=b1~?}
 1?E
_#'C)
AE/#;
8R>u
%L;s
GI<R
?rk?
&U? 
 :>%>G
PnS?6Y
$T?I
v7S?
Q?29U>.
S?g{
K?0e
6wH?
j.?=
 ? &
&?S!
2?Tq/?
:?14?
B?:>6?
?^JI?
=?sK
Rb?*
(8?MM"
S6?q
3>/jw?
74? 
2?p[
+?=C
rSyC
#:g&,@
@@QY:\
hxw?
8$=N
kGm?%
_=~p~
_\^?
jhS?
N?F_
. =%Z
$^J?r
C=gG
1[J?`:
(eJ?
^*J?
=By?>
>UMP>
*>1xx>j
!L?e
zpK?
/A?5
B/?\Y
2'?H
1?TU
?{0A?6;2?
.9?N
x8?4
f[?>
>7?N
mf?i
>_)k?Z
}>p_o?
zX>W#s?F
7>[av?
,?em
=PS{?
;.VT
t?zl
<O<'
/4o?
;RcB=
T=nl
1?5_
+k3?
p=xC
1??S
8?d[
MI:?
F<?z
,>Ovc>7
KY>?
Z>|B
@?Ab
e??.
98?G
,4?Q
0?EG
"?Id
*?o-
?(G9?
?/N@?
|_?*
.?~tZ
ji?z
1*?'
Z>V~q?.u0?
u?->)?
+|?iR"?F?
Pr@_\z?
?BxM@m
>@,dv?
@(Gq?
?=ae?
?8hC?
?%#3?
?A.}?
r?9B
j?}[
Vh?L
d?fk
h\AX
Pr@d[z?
?5|M@
1@'1t?
?D0R?
?tM?
?w0>?
?#/3?
?5Dy?Q
r?9B
d?;m
?6}\B
k\Ai
@/Pn?
?5~M?
?u"}?p
Cy?T
?3Qh?:"
i\A&
@D2|?
Pr@zRz?
?cDb?
?YnM?
??:y?7
yj?B
?\}\B
@cc~?
@Xs|?
?XSM?
?! 3?
?o/y?
o?GX
?Xuj?
?gEh?|{
If?'
@p&~?
Tr@\>z?
?]NM?
?seH?
?8j-?
u?kG
>h?E
?ud?
?-h\A~
@fN{?
@t~z?
@<ln?
?K>b?
?u[V?
?fg-?
|?I.
?}]r?
vo? 
?M0h?
6f?&
?/md?
@Xuz?
?<k1@
@3lp?
@oEn?
?>"b?
?Qg^?
y?Gs
?!Wj?d
?Z+f?[{
?>Zd?
?'hr@
?<g1@
@/Rp?
?*Re?
?"S^?
?>$H?
?vl8?
xu?M
Hr?3
?[`o?-|
Lj?3
?"m1@Z
?Y3Z?
?-Ar?
?9Bj?
?Fe\A
j1@D
@JDp?
@AGk?
@{kh?
?$%e?
?|D8?
x?Y
d?ys
?Kg\A
@%\|?
>@l>v?
@L8p?
?V~a?
cu?U3
?4,r?!
?}#j?
g?t~
?Lf\A
@-y|?
?>%_@
M@~ow?
?>]a?
?x_=?
?_au?G
?p}l?
j?QN
?S%b?
f\AL
@!V{?
+_@9Dx?
M@cGw?
? }%@
@y"p?
?{hG?
?h^B?
?i8=?
?du'?
a?"r
@nR}?
`r@s
?o/_@
`1@E.t?
?c{%@
?&4Y?
?%g\A
?kf1@+
@1_j?
@HQg?
?<k'?
r?DR
o?(}
ue?b
?,~c?
?he\AI
@lZ}?
@sG{?
_@R+x?
>@p]u?
n1@<
?}y%@O
@B@j?
?P92?
?[`'?
|?>Y
?ZGu?
?zSe?S
?iUc?
ra?RI
?3e\A
@<L{?
^@S>x?
?!#N@
?1x%@y
?(d7?
?z9?
?rMu?B
n?9&
i?_y
Rg?U
?Dh\A
@UK~?
?6u%@'jq?
?&o?
?Hh\A
@=E~?
@0K{?
N@GZv?
?2r1@0
?A+<?
?CV'?
y?$b
Fu?Ho
ii?0
?:i\A
@S<~?
@%=|?
@ZE{?
?@uYt?
?>z1@
?>y%@
@HNf?
?{2_?
?]m}?
?t&y?
?1Eu?
?mVi?y
`?#,
~\B7
h\A5
@hB{?
~%@C
@Efn?
?/1J?
?+Ny?
?kfu?bL
n?,D
?w1i?
f?GX
?}v\C
@j/~?
@{2{?
%@r3p?
?~Qb?
}?hx
?Miy?
n?hw
i?Ym
?~~\C
?]~\B
?9}^@#Ix?
>@>$t?
@ywh?
@Ife?
?dvV?
?N*N?
?e6@?
?Sw1?
1~?K
ju?~r
?<hf?
?Ti\A
@S!~?
M@;Uv?
%@~so?
?Y6;?
?c_6?
?Nc'?
y?1$
n?p%
h?cd
?l>f?
?5]_?
?Kh\A
@wj~?
@[^}?
?Sv^@
v1@w
z?_$
?~pn?`
?ock?
h\A!
?is^@`
?Na1@
@YPl?
?cdY?
?E.D?
?sI1?
Mz?Y
u?O?
?MLk?
?YQc?(
^?r3
|\BL
"At^
@5{|?
q@"9y?
s^@0
?ur%@
@XWi?
?QO??
?Tp,?
?K>n?
?!>h?
e?)#
?)B^?
?@~\C
?F~\B;
"AB?
@}[|?
@tb{?
?+k^@
~M@D
91@} q?
?R`%@
?x`P?
?,.n?[y
h?Ig
?UM`?
?${\B
h\A+
?Pr^@.Sw?
}M@0
?pw>@'ls?
?nM%@
@I-h?
@nme?
@/ob?
?&6_?
?+kG?
?)z,?
Ov?-
n?%]
?+m]?
@R~~?
@;m}?
?Sw^@j
>@S s?
!1@;
?G9%@3
?H2[?
?@1:?
? &1?
?|{#?
Rv?/
d?is
?jg\A
q@1]x?
?e5%@|
?b0S?
?gG>?
?;71?
?+5{?^
v?#2
m?LT
?huj?B
jd?w
|\B?
i\A>
!"A,
@.:}?
@1{y?
^@mpv?
?}x>@
?d"%@
@?9j?
?$^V?
?4L1?
?Bx(?
Ha?8f
;A33
@LO|?
?&8Y?
?B!R?
?HRN?
?;QF?
?1`1?
{?Qk
`?O 
?_z[?
?&p\AN
@C7{?
@p&z?
r@XYw?
@% f?
?t{5?
?px1?
?dsm?
?XYc?>
?Sx`?
?s~\B3
%"Ai
@#g}?
?#2r@
@k'b?
?B]T?
?%<!?
?1\m?
?Bwi?P
/]?g}
?{JZ?
?("A
A|e~?
@xD}?
@=(x?
Lr@%
%@@jk?
?8HP?
~\B7
+"As
AbL~?
@Hp{?
M@$Gr?
!1@G
?BBL?
?`".?
?]Q*?
Oe?%Y
^?+j
?6H\C
@;9w?
>@|`o?
%@@1j?
?J|2?
?Xo|?
v?u
?Hkh?s
?2wa?fJ
?AJX?_
0"AU
@oe}?
?_D_@
$@}ui?
?`>A?
?.=:?
?%>/?
? }+?
?nn ?
q?~6
l?5y
?[x\C
?X:"A
@Gt{?
?.u_@
?[A1@
l?\8
?2p\C
?3 <A
@82w?
?AGN@Dio?
?P:1@
}|?)
v?D5
.g?9|
?5Fc?
2Y?X
?2}\B
?)%<A
?3["A
3%@Y
@T8^?
?JE'?
f?`u
]X?c{
?>0<A.s~?
AY0}?
@%X|?
@tyw?
M%@.
@xFc?
@Ae`?
@BzZ?
?W"T?
?2!>?
?=H;?
?h#/?
?]7%?
x|? ]
Bf?D
b?e7
H^?~
D<Aj/~?
r"AV
@(cx?
?p>?@
?'l%@
@&Vb?
??sJ?
?NDG?
?J{#?
}|?73
?Iiv?
?Crj?/R?
"ANa}?
@N+y?
?J`?@
1@uvf?
@2Xa?
?<j(?
?8/v?S
d??n
z`?Z-
Q?`X
h<AT
Ad>|?
#t@/
N@b-j?
1@AIe?
@%][?
?:>V?
?MLK?
?^fH?
u?ip
?Umo?
qT?SX
?i~\B
]A_&~?
@REy?
`@.8k?
?&4&@
@k`_?
?l|N?
?*tF?
?x(>?
?q9&?
?S?#?
{?k(
?:WdE
?3s[C
?|0]A
AxB{?
@yx?
?t}t@l!l?
?uUO@
@o,\?
?B!J?
?'3b?$
h\BJ
`@$Eh?
}O@;
?^i@@
@KuY?
?`sF?
?oK<?
?;n4?
?k2?
?WB{?
?x%m?
?uXa?S
OX?|
L?i5
.\C~
?fV\B
?Ac]Ac`}?
@:Wx?
O@Wwd?
?G!@
?t)R?
?<KP?
?8eN?
?o~C?
?NC4?
{?&r%?
9`?R~
g[?a
?v3O?
|\BL
?Wj#Aw
@K9w?
tA@'
~4@h
@!@Z?
?2uC?
?rN<?
?H27?
?I0-?
?t(s?A
k?^c#?
M?]5
I?Ul
?hG)E
A7n}?
]A@i|?
?hU=A
@W_q?
?urQ@
?<g??
?9}5?
?TSr?
?]kc?ob$?
O?cD
=Aq=z?
@IHt?
@kdo?
@ Dj?
?Iev@
C@,d^?
?[y!@!
?Yn9?
?40R?;
I?l@
?4~^B
?f0"B
Ak+~?
?aP$A/
@erj?
E@W_]?
-@Wx[?
s#@2
@?6Y?
?%?V?
?SXU?
?O@O?
?]jH?
?9cD?
?1x`?k
DP?M
?r."BS
A}\{?
@-#m?
?eU;@k
?P8W?
?${D?
?[@@?
?(av?:u9?
]X?[
?|FN?
E?U4&?
?|CA?
\B$a
?]OY@*
?Lm3@
@HRZ?
?lAW?
?aPV?
?kGI?
?0fC?
}?2XA?
t?X:??
?zlG?
A&5|?
AhAx?
?H1`A&
?]}?A
?qV%A
@Wzi?
@HPd?
@UN_?
@u[^?
?]jB@9
?BB\?
?@j[?
?=eQ?
r?LqE?
i?x|C?
S?,e=?
N?EJ;?
H?l$9?
?;nD?
?-z;?
?&|!B
A5`x?
?qN%A
A=bh?
?!\r@s
?-]T@
rG@{
;@7R^?
?-@1@
?V~]?
?J%\?
dJ?~9C?
E?XWA?
Au:x?
?Rf%A
@^I^?
i@]P_?
?\qa?
?a3\?
rR?C
?R'L?f-M?
=?TtH?
u8?>
3?V-E?
?gtdB
O@AZ
@6V^?
@R}_?
r@t)b?
?_@V@
R)@U
@)ye?
@;me?
?B'd?
=?%YS?
"/?yxO?
G^Cc
AKYf?
KdAZc`?
,AF}^?
@`ta?
@sHf?
1o@r
F@y=h?
@M/i?
@EHi?
@zSi?
@@Qi?
?cAi?
?l$i?
?P7h?
?X f?
?w.|?
?0.q?C
?r1Z?T
R?F\`?
?(|J?
63?r3\?
?OgyCi
@l&g?
?T9P@
9@I,m?
@xzm?
?4gm?
?P:m?
?5*l?
?H5x?7mj?
?y"`?5
V?CXi?
?G!M?
>?t#h?
`2?JEg?
 "?~
?+l1B.
sC0*m?
?\:iA
A0.q?
?]F+ADPq?
AUgq?
?8fs@_
?Ii'@
av?'
N?p|q?
D?Jyq?
?]66?
?zS1?Doq?
?p}$?
?Adq?
?c`q?
Ga==
6<Z(
?Dio
?33s?
MAa[
8?Sx
tWxCE
333?333?333?
fff?
>333?
fff?
fff?
>333?
?fff?333?
?33s?333?
333?
333?
fff?
?fff?fff?
L>fff?
@ffffff
>fff?
?UUUUUU
?ff&?333?C
G &?RGBA
?fff?fff?fff?
?ffffff
>T=t<?Xf?
Q?m7
>|eV?
+?xE`?
|?M2
>~qi>
OV?*
?".
j<F^
g?K"
>G<i>py|?
=?$b
>]Km=
Sq=~7}>K
M:>}
bx?`
> @?
>{1p?
Q?}=_>
ty?*s
s?lx
?)yM?GO{=o
 d=/Pf?
b?f-
>caH?,f
>To)?
1!?&7j>
4m?<l:?%
h?|3
|8>@K
=:#Z>
H?-AF>D4
c;=g
F?Mf
N:?r4
>Kuq>N*B?q
>an_?
>,..>
Ij?mtz?
cU?l
{>;V
?h%=?XT
?mSL>
9$?e
I/>=
j?9}%?
>S}"=x
:b?<1;>
GT?&
?W$&>
AU>6Z
>pyH?
et?=
Z>g&
ld? 
=akf>
rx?Aa
?@/|>
O?;s
H>:y
=?\r
}=?I
>2rN?
<m?!!
%n?VHI>O>E?
M?LOH>
=O\z?
M?3Q
?uUh?
?{Ke?
2?:y
k:>N
O'?L
n?*wz<
Z>]S4?
>~R%?
+:?JC
~?8IC?\
E?l&o?
y!?9DH?%t
>uX?
8>_&
l?3o
?a8W?
:V?#
M?*X
U=6Y
?TR7>
A??0,
?fKb?
N?2Xu?
L'>:>.?@hA?2F
hG>H
J?P9
>E*?
cF?sH
>t}[?
CG=N
&4?S S>k
v9?`
_R?O
z?Qg
<g?}
'?,df?3
m?JE
:==%
>O#->
j?gc
>B{1?
=sIm?
;.Tb?
= $k?
YJ?t
ZQ?1z
----
ARGB
AfGR
v024
v024
(knNff
`>9?
`>9?
8-0?
8-0?
Z&>X
Z&>X
?333?
?333?
=fff@
US]CQ
^(BM
kZ;&
v28@?0c8I12*16I24
v140@?0{__C3DShapeVertex={CGPoint=dd}{CGPoint=dd}{CGPoint=dd}{CGPoint=dd}dBi}8{CGPoint=dd}88f104{CGPoint=dd}108{CGPoint=dd}124
v8@?0
v32@?0@8@16^B24
C3DKeyValueStore
<C3DKeyValueStore>
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Engine/AppleEngine/C3DTokenizer.hpp
mpSource
triggerOptionsForRealtimeViewer
kSceneSourceAutoLimitMemoryForImages
kSceneSourceCreateCameraIfAbsent
kSceneSourceForceInProcess
kSceneSourceCreateLightIfAbsent
kSceneSourceCreateNormalsIfAbsent
kSceneSourceAdjustInvalidClippingPlanes
kSceneSourceFlattenScene
kSceneSourceSplitMeshesForGLES
kSceneSourceConvertToYUpIfNeeded
kSceneSourceConvertToUnit
kSceneSourceAnimationLoadingMode
keepSeparate
playRepeatedly
playOnce
playUsingSceneTime
kSceneSourceCleanupMeshes
kSceneSourceRemoveAllLights
kSceneSourceRemoveColorArrays
kSceneSourceInterleaveSources
kSceneSourceMakeSourcesCheaper
kSceneSourceSkipConsistencyCheck
kSceneSourceCheckConsistency
kSceneSourceUseSafeMode
kSceneSourceAssetDirectoryURLs
kSceneSourceOverrideAssetURLs
kSceneSourceStrictConformanceKey
kSceneSourceVerboseMode
kSceneSourceFormatHint
kSceneSourceSkipImagePathResolution
contributors
created
modified
up_axis
unit
authoring_tool
author
unitName
unitMeter
com.apple.SceneKit
kEnclosingDirectoryURL
C3DSceneSource
Collada is not supported by this version of SceneKit
Unknown or missing file
Could not load the scene
The document does not appear to be a valid COLLADA file. Please check that is has not been corrupted.
The document does not appear to be valid. Please re-create it from your original COLLADA assets.
<C3DSceneSource >
CopyTextureComputePass
texturecube_slices_copy_kernel
texturecube_copy_kernel
texturecube_copy_resample_kernel
texture2d_copy_kernel
texture2d_copy_resample_kernel
scn_draw_fullscreen_triangle_vertex
scn_draw_fullscreen_fragment
C3DSortSystem
<C3DSortSystem %p>
uniform 
vec2
float2
vec3
float3
vec4
float4
ivec2
int2
ivec3
int3
ivec4
int4
uvec2
uint2
uvec3
uint3
uvec4
uint4
mat2
float2x2
mat3
float3x3
mat4
float4x4
mat2x4
float2x4
mat3x2
float3x2
mat3x3
mat4x2
float4x2
mat3x4
float3x4
u_time
scn_frame.time
u_viewTransform
scn_frame.viewTransform
u_inverseViewTransform
scn_frame.inverseViewTransform
u_projectionTransform
scn_frame.projectionTransform
u_inverseProjectionTransform
scn_frame.inverseProjectionTransform
u_cameraPosition
scn_frame.cameraPosition
u_viewToCubeWorld
scn_frame.viewToCubeWorld
u_inverseResolution
scn_frame.inverseResolution
u_modelTransform
scn_node.modelTransform
u_inverseModelTransform
scn_node.inverseModelTransform
u_modelViewTransform
scn_node.modelViewTransform
u_inverseModelViewTransform
scn_node.inverseModelViewTransform
u_normalTransform
scn_node.normalTransform
u_modelViewProjectionTransform
scn_node.modelViewProjectionTransform
u_inverseModelViewProjectionTransform
scn_node.inverseModelViewProjectionTransform
u_boundingBox
scn_node.boundingBox
u_worldBoundingBox
scn_node.worldBoundingBox
sampler1D
texture1d
sampler2D
texture2d
sampler3D
texture3d
samplerCube
texturecube
discard
discard_fragment()
gl_FragCoord
in.fragmentPosition
gl_FragColor
_output.color
gl_FrontFacing
isFrontFacing
texture1D
filter::linear
texture1DProj
texture1DLod
texture1DProjLod
texture2D
texture2DLod
textureLod
texture2DProj
texture2DProjLod
texture3D
texture3DProj
texture3DLod
texture3DProjLod
textureCube
textureCubeLod
shadow1D
shadow1DProj
shadow1DLod
shadow1DProjLod
shadow2D
shadow2DProj
shadow2DLod
shadow2DProjLod
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Engine/AppleEngine/C3DShaderConverter.mm
uniform
ParseUniform
mToken.str() == "uniform"
pragma
arguments
varyings
declaration
body
const
constant
Parse
mpTokenizer == nullptr
while
#pragma arguments
#pragma body
#pragma declaration
.sample(
Sampler
, level(
, bias(
float2(
float3(
float4(
sampler 
Sampler
_hide
v16@?0Q8
C3DParticleSystemInstance
<C3DParticleSystemInstanceRef>
DownsamplePass
COLOR
scn_supersampling_vertex
scn_supersampling_fragment
<%@:%p "%@"
  mesh: %@
  mat%d: %@
bindInfos
name
type
address
semantic
mesh
overrideMaterial
materials
levelsOfDetail
sceneRef
C3DGeometry
unknown
aoCoord
lightmapCoord
bitangent
usdz
SCN_MDLCurrentAssetResolver
While creating SCNSkinner: Could not find SCNNode %@
morpher.weights[%d]
SCNSceneKitAssociatedObject
B32@?0@"SCNGeometrySource"8Q16^B24
blendShape%d
normal%d
textureCoordinate%d
color%d
emission
baseColor
specular
reflective
opacity
metallic
roughness
ambientOcclusion
displacement
normal
%@_%d
transform
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
targetShapes
T@"NSArray",R,N
shapeSetTargetWeights
shapeSetTargetCounts
weights
T@"MDLAnimatedScalarArray",R,N
jointPaths
jointBindTransforms
T@"NSData",R,N
meshBindTransform
T{?=[4]},R,N
AO_%@_%@.png
@"NSString"16@?0@"SCNNode"8
v32@?0@"SCNNode"8@"SCNGeometry"16@"NSArray"24
aoTexture
lightmapTexture
/tmp/ModelKit_AO_%@.png
fieldOfView
focalDistance
fstop
/%@.position
/%@.orientation
/%@.scale
Bad joint path detected for joint: %@
offset=%d&size=%d
SSAORaytracePass
SSAO-DepthNormal
SSAO-MinMaxOffset
SSAOSampleCount
SSAODownSample
SSAOCameraOrtho
SSAOVRRendering
scn_ssao_compute
C3DMeshElementGetIndexCountPerPrimitive
C3DMeshElementGetChannelsDefineSameTopology
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Core/C3DMeshElement.c
indicesDataLength > topologyIndicesLength
CHANNEL %ld/%ld
%4u : %4u %4u %4u
%4u : %4u %4u
%4u : %4u
%2u : [Polygon %4u]
 %4u
v24@?0I8^I12I20
C3DMeshElement
<C3DMeshElement %p type:%@ primCount:%d channels:%d indexBytes:%d offset:%d acmr:%f inst:%d dataSize:%d shared:%p>
triangles
triangleStrip
lines
points
polygons
triangleFan
invalid
doubleSided
linesArray
trianglesArray
pointsArray
trianglesStrip
polygonsArray
indexes
subElementsCount
bytesPerIndex
primitiveNormals
bbox[0]
bbox[1]
%@-splitContainer
splitContainer
B8@?0
q16@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}8
B16@?0@?<v@?>8
v16@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}8
v32@?0^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}8c16q20C28
default camera
SceneKit
%@-split%d
DeferredShadowPass
DEPTH
SceneKit-spotShadowDepth-
cascadeCount
sampleCount
debugCascades
cascadeBlending
isSpotLight
reverseZ
enableARMode
deferredShadowCascades_frag
deferredShadow_frag
deferredShadow_VR_vert
deferredShadow_vert
v16@?0d8
scene
T^{__C3DScene=},R,V_scene
customAudioNode
TB,R,V_customAudioNode
completed
TB,V_completed
audioPlayer
T@"AVAudioPlayerNode",R,V_audioPlayer
willStartPlayback
T@?,C,N,VwillStartPlayback
didFinishPlayback
T@?,C,N,VdidFinishPlayback
audioNode
T@"AVAudioNode",R,N,V_audioNode
audioSource
T@"SCNAudioSource",R,N,V_audioSource
caff
aiff
SCNAudioSource.m
Error reading file into buffer, %@
volume
rate
reverbBlend
positional
loops
shouldStream
supportsSecureCoding
TB,R
TB,N,GisPositional,Vpositional
Tf,N,Vvolume
Tf,N,Vrate
Tf,N,VreverbBlend
TB,N,V_loops
TB,N,V_shouldStream
auth
v24@?0^^{__C3DNode}8q16
C3DHitTestResult
<C3DHitTestResult %@ %f,%f,%f>
version
coarseVertexCount
vertexPatchTable
fvarPatchTables
legacyGregoryPatchTable
patchRangesTable
vertexRefiner
fvarRefiners
skinMorphSubdivIndexToMetalIndexBuffer
synchronizeCoarsePositionsPipeline.functionName
fvarChannelDescriptorsBuffer
fvarChannelsPackedDataBuffer
USE_OPENSUBDIV
OSD_PATCH_QUADS
OSD_PATCH_TRIANGLES
OSD_PATCH_REGULAR
CONTROL_POINTS_PER_PATCH
OSD_PATCH_GREGORY
OSD_PATCH_GREGORY_BASIS
OSD_PATCH_GREGORY_BOUNDARY
#import <metal_stdlib> 
#define OSD_UV_CORRECTION if (t > 0.5) { ti += 0.01f; } else { ti += 0.01f; }
struct OsdInputVertexType { 
    metal::packed_float3 position; 
    metal::packed_float2 texcoord
    metal::packed_float4 color; 
#define OSD_USER_VARYING_DECLARE                             
float2 texcoord
float4 color; 
#define OSD_USER_VARYING_DECLARE_PACKED                             
metal::packed_float2 texcoord
metal::packed_float4 color; 
#define OSD_USER_VARYING_PER_VERTEX(in, out)                 
out.texcoord
 = in.texcoord
out.color = in.color; 
#define OSD_USER_VARYING_PER_CONTROL_POINT(in, out)          
#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d, out) 
 = mix(mix(a.texcoord
, b.texcoord
, UV.x), mix(c.texcoord
, d.texcoord
, UV.x), UV.y); 
out.color = mix(mix(a.color, b.color, UV.x), mix(c.color, d.color, UV.x), UV.y); 
#define OSD_USER_VARYING_DECLARE_ATTRIBUTE                   
 [[attribute(
)]]; 
float4 color [[attribute(
    metal::packed_float3 position; 
VERTEX_BUFFER_INDEX
PATCH_INDICES_BUFFER_INDEX
CONTROL_INDICES_BUFFER_INDEX
OSD_PATCHPARAM_BUFFER_INDEX
OSD_PERPATCHVERTEXBEZIER_BUFFER_INDEX
OSD_PERPATCHTESSFACTORS_BUFFER_INDEX
OSD_VALENCE_BUFFER_INDEX
OSD_QUADOFFSET_BUFFER_INDEX
TRANSFORMS_BUFFER_INDEX
TESSELLATION_LEVEL_BUFFER_INDEX
INDICES_BUFFER_INDEX
QUAD_TESSFACTORS_INDEX
OSD_PERPATCHVERTEXGREGORY_BUFFER_INDEX
OSD_PATCH_INDEX_BUFFER_INDEX
OSD_DRAWINDIRECT_BUFFER_INDEX
OSD_KERNELLIMIT_BUFFER_INDEX
OSD_PATCH_ENABLE_SINGLE_CREASE
OSD_FRACTIONAL_EVEN_SPACING
OSD_FRACTIONAL_ODD_SPACING
OSD_MAX_TESS_LEVEL
USE_STAGE_IN
USE_PTVS_FACTORS
USE_PTVS_SHARPNESS
THREADS_PER_THREADGROUP
CONTROL_POINTS_PER_THREAD
VERTEX_CONTROL_POINTS_PER_PATCH
OSD_MAX_VALENCE
OSD_NUM_ELEMENTS
OSD_ENABLE_BACKPATCH_CULL
OSD_USE_PATCH_INDEX_BUFFER
OSD_ENABLE_SCREENSPACE_TESSELLATION
OSD_ENABLE_PATCH_CULL
NEEDS_BARRIER
OSD_FVAR_WIDTH
OSD_FVAR_USES_MULTIPLE_CHANNELS
OSD_FVAR_DATA_BUFFER_INDEX
OSD_FVAR_INDICES_BUFFER_INDEX
OSD_FVAR_PATCHPARAM_BUFFER_INDEX
OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX
OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX
OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX
OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX
OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX
OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING
OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING
OSD_COLOR_INTERPOLATION_MODE
OSD_TEXCOORD0_INTERPOLATION_MODE
OSD_TEXCOORD1_INTERPOLATION_MODE
OSD_TEXCOORD2_INTERPOLATION_MODE
OSD_TEXCOORD3_INTERPOLATION_MODE
OSD_TEXCOORD4_INTERPOLATION_MODE
OSD_TEXCOORD5_INTERPOLATION_MODE
OSD_TEXCOORD6_INTERPOLATION_MODE
OSD_TEXCOORD7_INTERPOLATION_MODE
C3D_OPTIMIZE_OPENSUBDIV_STORAGE
SceneKit: Synchronize skin/morph for subdivision
SceneKit: Compute tessellation factors for subdivision
C3DSubdivisionOsdGPURuntimeData
<C3DSubdivisionOsdGPURuntimeDataRef %p>
Vertex patch table:
  - Patch arrays (%@):
    - %d x %@
  - Data buffer: %p (%@)
  - Patch index buffer: %p (%@)
  - Patch param buffer: %p (%@)
FVar patch table (channel %zu):
Legacy Gregory patch table:
  - Vertex valence buffer: %p (%@)
  - Quad offsets buffer: %p (%@)
  - Vertex stencil table (%d stencils)
    - Sizes buffer: %p (%@)
    - Offsets buffer: %p (%@)
    - Indices buffer: %p (%@)
    - Weights buffer: %p (%@)
  - Vertex evalutor input
    - Src buffer: [offset:%d length:%d stride:%d] %p (%@)
    - Dst buffer: [offset:%d length:%d stride:%d] %p (%@)
v16@?0r^{?={?=@@@@i}{?=@@{BufferDescriptor=iii}{BufferDescriptor=iii}}^{MTLComputeEvaluator}}8
Vertex Refiner:
  - Skin/morph indexing table: %p (%@)
Total memory usage: %@
QUADS
TRIANGLES
REGULAR
GREGORY
GREGORY BOUNDARY
GREGORY BASIS
C3DGetPatchTypeDescription
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Core/C3DGeometryOpenSubdivSupport_Metal.mm
.patchArrays
.dataBufferOffset
.dataBufferCoarseDataSize
.dataBufferFullDataSize
.patchIndexBuffer
.patchParamBuffer
.dataBuffer
.count
.[%d]
.vertexValenceBuffer
.quadOffsetsBuffer
.quadOffsetsBaseGregory
.quadOffsetsBaseGregoryBoundary
.elementCount
.patchArrayCount
.[%d][%d]
.stencilTable
.evaluatorInput
.sizesBuffer
.offsetsBuffer
.indicesBuffer
.weightsBuffer
.numStencils
.srcDesc
.dstDesc
__C3DSubdivisionOsdGPURuntimeDataDecodeEvaluatorInput
srcLength == sizeof(OpenSubdiv::Osd::BufferDescriptor)
dstLength == sizeof(OpenSubdiv::Osd::BufferDescriptor)
 -w 
%@%s%@
C3D-OpenSubdiv_compute.metal
#import "scn_metal"
scn_metal
compute_opensubdiv
C3DPatchTypeFromOsdPatchType
C3DPatchTypeToOsdPatchType
^{__CFData=}8@?0
%@-%s
Mesh
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/osd/../osd/mesh.h
_refiner
initializeContext
{MTLContext=@@@@}8@?0
__C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer
encodedLength <= buffer.length
v16@?0@"<MTLCommandBuffer>"8
scn_osd_synchronize_coarse_positions_no_argument_buffer
scn_osd_synchronize_indexed_coarse_positions_no_argument_buffer
layer
T@"CALayer",&,N,V_layer
C3DList
<C3DList %p: head %p, tail %p, %ld objects>
com.apple.scenekit
SceneKit: Morphing Incremental
blend_inc_init_8x_pn_kernel
blend_inc_add_8x_pn_kernel
blend_inc_init_8x_p_kernel
blend_inc_add_8x_p_kernel
SceneKit: Post-morphing Normal Smoothing
unify_u16
unify_u32
morphNormal
copy_generic
blend_generic
blend_sparse_u16_generic
blend_sparse_u32_generic
splat_indexed_vertices
SceneKit: Morphing Sparse
needNormal
needTangent
maxBoneCount
%c%c%d
skin_var
SceneKit: Skinning
DOFDownsampleCoCPass
DofColorCoC
dof_coc_downsample4
halfExtent
strength
falloffExponent
minimumDistance
active
scope
usesEllipsoidalExtent
exclusive
offset
direction
Td,N
TB,N,GisActive
TB,N,GisExclusive
T{SCNVector3=fff},N
TB,N
Tq,N
categoryBitMask
TQ,N
block
smoothness
animationSpeed
DrawBackgroundPass
BACKGROUND
v24@?0^{__C3DNode=}8^B16
C3DFXFloorPass.plist
SceneKit_renderMirroredScene
SceneKit_renderFloor
u_floorReflectionColor
SceneKit-floor-color-%p
u_floorReflectionDepth
SceneKit-floor-depth-%p
u_floorNormal
u_floorTangent
u_floorCenter
u_floorExtent
u_floor_viewport
u_floorReflectivity
u_floorFalloffStart
u_floorFalloff
u_floorPlane
u_floorMVP_i
FloorGeomImpl.glsl
FloorGeomImpl-metal.h
USE_FALLOFF
USE_FALLOFF_START
USE_TRANSPARENCY
FloorImpl.glsl
FloorImpl-metal.h
v16@?0^{__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}8
ShadowMapPass
--ShadowMaterial--
com.apple.scenekit.jitteringUpdateQueue
enabled
TB,N,GisEnabled
C3DStack
<C3DStack>
bodyA
bodyB
axisA
axisB
anchorA
anchorB
T@"SCNPhysicsBody",R,N
FinalPass
None
Vertex
Normal
Texcoord
Tangent
ModelViewProjectionTransform
ModelViewTransform
ModelTransform
ViewTransform
ProjectionTransform
NormalTransform
ModelViewProjectionInverseTransform
ModelViewInverseTransform
ModelInverseTransform
ViewInverseTransform
ProjectionInverseTransform
NormalInverseTransform
InverseResolution
SystemTime
COLOR0
COLOR1
COLOR2
COLOR3
Invalid
_allocate
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Containers/C3DHash.hpp
(new_size & (new_size - 1)) == 0
v24@?0@"SCNNode"8^B16
v32@?0@8Q16^B24
_prepareSnapToAlignDataForAxis - unexpected axis
B24@?0@"SCNNode"8^B16
authoringEnvironment
T@"SCNAuthoringEnvironment",R
T{SCNMatrix4=ffffffffffffffff},R
manipulatorNode
T@"SCNNode",R
targets
T@"NSOrderedSet",&,N
target
T@"SCNNode",&,N
xAlignment
Tq,N,V_xAlignment
yAlignment
Tq,N,V_yAlignment
zAlignment
Tq,N,V_zAlignment
readonly
TB,N,V_readonly
features
T@"SKScene",&,N,V_scene
location
initFromPath
relativePath
runtimePath
vertexCount
componentsPerValue
componentsType
valuesCount
data
kGeometrySourceSemanticVertex
kGeometrySourceSemanticNormal
kGeometrySourceSemanticColor
kGeometrySourceSemanticTexcoord
stride
padding
sourceID
sourceTypeID
vertex
position
color
texcoord
textangent
joints
commonProfile
geometryID
materialsID
facesCount
kAnimationsKey
kBindingsKey
kActionsKey
kLightKey
kSkinnerKey
kMorpherKey
kCameraKey
kConstraints
kParticleSystem
kAudioPlayer
kLightmapInfoKey
kRenderingPriorityKey
kShaderModifiers
kPivotKey
libraryStorage
kMeshKey
rendererDelegate
kFilterKey
geometry
geometryElement
geometryElements
geometrySource
genericSource
node
material
effect
image
keyframedAnimations
animation
camera
light
skin
morph
linear
easeIn
easeOut
easeInEaseOut
default
function
avoidsOverlighting
double sided
cullMode
cullBack
cullFront
lambert
phong
blinn
physicallyBased
none
shadowOnly
ambient
diffuse
transparent
filter
selfIllumination
metalness
clearCoat
clearCoatRoughness
clearCoatNormal
emissionColor
ambientColor
diffuseColor
specularColor
reflectiveColor
transparentColor
normalColor
filterColor
emissionImageID
ambientImageID
diffuseImageID
specularImageID
reflectiveImageID
transparentImageID
filterImageID
normalImageID
shininessImageID
emissionTextureSampler
ambientTextureSampler
diffuseTextureSampler
specularTextureSampler
reflectiveTextureSampler
transparentTextureSampler
filterTextureSampler
normalTextureSampler
shininessTextureSampler
emissionUVSet
ambientUVSet
diffuseUVSet
specularUVSet
reflectiveUVSet
transparentUVSet
normalUVSet
filterUVSet
shininessUVSet
ambientOcclusionUVSet
selfIlluminationUVSet
shininess
reflectivity
transparency
indexOfRefraction
fresnelExponent
transparencyMode
A_ONE
RGB_ZERO
minFilter
magFilter
mipFilter
wrapS
wrapT
wrapP
textureType
anisotropy
SCNKitErrorDomain
frustumCulling
defaultLight
defaultCamera
probeRendering
debugRendering
pointOfView
rootNode
mirrorNode
kHitTestFirstFoundOnly
kHitTestSearchMode
kHitTestSortResults
kHitTestClipToZRange
kHitTestSkipTransparentNode
kHitTestSkipHiddenNode
kHitTestCategoryBitMask
kHitTestBackFaceCulling
kHitTestBoundingBoxOnly
kHitTestIgnoreChildNodes
kHitTestRootNode
kHitTestAllLayers
kHitTestLayerMask
kHitTestShowDebugInfo
kHitTestResultIgnoreLightArea
kC3DNotificationMeshSourceWillDie
kC3DNotificationMeshElementWillDie
kC3DNotificationImageWillDie
kC3DNotificationImageProxyWillDie
kC3DNotificationProgramWillDie
kC3DNotificationGeometryWillDie
kC3DNotificationMorphWillDie
kC3DNotificationSkinWillDie
kC3DNotificationMaterialWillDie
kC3DNotificationMeshWillDie
kC3DNotificationNodeWillDie
kC3DNotificationPassWillDie
kC3DNotificationRasterizerStatesDidDie
kC3DNotificationEngineContextInvalidatePasses
kC3DNotificationEngineContextPassesDidUpdate
kC3DNotificationProfileWillDie
kC3DNotificationEntityAttributeDidChange
kC3DNotificationRendererElementWillDie
kC3DNotificationProgramHashCodeWillDie
kC3DSceneDidUpdateNotification
hidden
attributes
matrix
translation
rotation
orientation
scale
eulerAngles
quaternion
pivot
filters
dofIntensity
focalSize
aperture
apertureBladeCount
xFov
yFov
orthographicScale
zFar
projectionTransform
zNear
firstMaterial
selfIlluminationOcclusion
multiply
litPerPixel
lockAmbientWithDiffuse
contents
texture
contentsTransform
borderColor
intensity
shadowColor
shadowRadius
gobo
probeEnvironment
attenuationStart
attenuationEnd
attenuationFalloffExponent
spotInnerAngle
spotOuterAngle
spotFalloffExponent
morpher
shaderModifiers
background
environment
customProperty
animations
a_position
a_normal
a_tangent
a_color
a_skinningJoints
a_skinningWeights
a_texCoord0
a_texCoord1
a_texCoord2
a_texCoord3
a_texCoord4
a_texCoord5
a_texCoord6
a_texCoord7
<%@: %p
 '%@'
 point(%f %f %f)
 normal(%f %f %f)
 impulse(%f)
 distance:%f
nodeA
T@"SCNNode",R,N
nodeB
contactPoint
T{SCNVector3=fff},R,N
contactNormal
collisionImpulse
Td,R,N
penetrationDistance
sweepTestFraction
vertexCrease
edgeCrease
%4d : %3d %3d %3d %3d
%4d : %+.2f %+.2f
%4d : %+.2f %+.2f %+.2f
%4d : %+.2f %+.2f %+.2f %+.2f
type debugging not implemented
C3DMeshSource
<C3DMeshSource %p(%@) data:(%p) mut:%d count:%ld type:%@ divisor:%d mtl:%d offset:%d stride:%d
mkSemantic
accessor
C3D-GaussianBlur
#define unshareIndex %d
#define MAX_SAMPLE %d
#define COMPONENT %c
GaussianBlur_vert
GaussianBlur_frag
C3D-blur-radiusH
C3D-blur-radiusV
C3D-blur-offsets
C3D-blur-weights
C3D-blur-samples
weakRef
T@,W,N,VweakRef
v36@?0I8^^{__C3DNode}12^^{__C3DLight}20^{?={?=[3]}}28
v24@?0q8r^v16
SCNBindingValueTransformerKey
B32@?0@8Q16^B24
C3DAnimationManager
<C3DAnimationManager %p>
q16@?0^{__C3DNode=}8
C3DKeyframeController
<C3DKeyframeController %p>
keyframeVersion
keyframeType
keyCount
keyframes
keytimes
keytimes-data
values
values-data
timingFunctions
timingFunctions-data
interpolationModes
interpolationModes-data
tensionValues
tensionValues-data
continuityValues
continuityValues-data
biasValues
biasValues-data
inTangents
inTangents-data
outTangents
outTangents-data
interpolationMode
calculationMode
0.12
v16@?0@"MTLRenderPipelineDescriptor"8
Compute SCNGeometryScreenSpaceAdaptiveTessellator tessellation factors
compute_tessellation_factors_screeenspace_adaptive_uint16
compute_tessellation_factors_screeenspace_adaptive_uint32
Compute kC3DGeometryTessellatorTypeConstrainedEdgeLength tessellation factors
compute_tessellation_factors_constrained_edge_uint16
compute_tessellation_factors_constrained_edge_uint32
SCNAction: Run block actions can not be properly encoded, Objective-C blocks do not support NSSecureCoding.
SCNAction: Run block actions can not be properly decoded, Objective-C blocks do not support NSSecureCoding.
SCNMaterialData
debug_frag
debug_vert
debug_post_tessellation_vert
debug_isolate_frag
scn_commonprofile_ds
scn_commonprofile
v24@?0^{__CFString=}8^v16
label
T@"NSString",C
device
T@"<MTLDevice>",R
cpuCacheMode
storageMode
hazardTrackingMode
resourceOptions
heap
T@"<MTLHeap>",R
heapOffset
allocatedSize
length
libraryManager
T@"SCNMTLLibraryManager",&,N,V_libraryManager
T@"<MTLDevice>",R,N,V_device
commandQueue
T@"<MTLCommandQueue>",R,N,V_commandQueue
copy_no_alpha_depth_texture
copy_no_alpha_uint_texture
copy_no_alpha_texture
addDependency
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Engine/RenderGraph/C3DRenderGraph.mm
_renderGraph->size() > n1
_renderGraph->size() > n2
n1Port == kPartialDependencyPort || node1.pass->descriptor().inputCount() > n1Port
n2Port == kPartialDependencyPort || node2.pass->descriptor().outputCount() > n2Port
a->identifier() != kInvalidPass
b->identifier() != kInvalidPass
(*_renderGraph).size() > n1
(*_renderGraph).size() > n2
v16@?0^{__C3DLight=}8
stages
outputs
inputs
%d-i-%d
%d-o-%d
links
addPass
passIndex < 32767
sort
_renderGraph->size() < 32767
linked to : %s slot %d (%s)
%s %s slot %d (%s)
GaussianBlurPass-Y
GaussianBlurPass-X
bloom_blur_%sfrag_%d
smp_
Format: %@ ; Size: %gx%g[%d] ; Texture: <%p> ; [rc:%ld/ts:%ld]
Name: %@ ; %@
-[SCNRenderTarget textureForSliceIndex:]
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/NewRenderer/SCNRenderTarget.m
_sliceTextures != nil
T@,&,N,V_texture
T@"NSString",C,N,V_name
referenceCount
Tq,N,V_referenceCount
timeStamp
Tq,N,V_timeStamp
viewportDependant
TB,R,N
renderBufferFormat
TC,R,N
Allocate
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Engine/Allocator/C3DScratchAllocator.cpp
last_chunk
VMAllocateChunk
chunk
!chunk->next
chunk->data
C3DTimingFunction
<C3DTimingFunction>
bundle
metalLibraryName
sequence
passes
symbols
depth
program
metalLibraryFile
metalVertexShader
metalFragmentShader
clientProgram
owners
C3DFXDefault_velocity.plist
C3DFXDefaultPass.plist
C3DFXDeferredShadingDefaultPass.plist
C3DFXTechnique
<C3DFXTechnique>
pass %d
plist
self
SSRDownSampleColorDepthPass
BackDepth
ColorDownSampled
DepthDownSampled
SSRDownSample
SSRReverseZ
scn_ssr_downsample_depth
_audioSource
_wait
C3DKeyframedAnimation
<C3DKeyframedAnimation %p>
keyframeController
keyframedAnimation
failed to load technique from dictionary: %@
-[SCNTechnique setValue:forSymbolNamed:]
rootResource
T@"<MTLResource>",R
parentTexture
T@"<MTLTexture>",R
parentRelativeLevel
parentRelativeSlice
buffer
T@"<MTLBuffer>",R
bufferOffset
bufferBytesPerRow
iosurface
T^{__IOSurface=},R
iosurfacePlane
pixelFormat
width
height
mipmapLevelCount
arrayLength
usage
framebufferOnly
TB,R,GisFramebufferOnly
allowGPUOptimizedContents
swizzle
T{?=CCCC},R,N
animations.%@.speed
valueForSymbol
animationKeys
T@"NSArray",R
dictionaryRepresentation
T@"NSDictionary",R
library
T@"<MTLLibrary>",&,N
time
T@"<MTLCommandQueue>",R,N
commandBuffer
T@"<MTLCommandBuffer>",R,N
T@"<MTLDevice>",R,N
initializationHandler
T@?,C,N
executionHandler
C3DAnimationNode
<C3DAnimationNode %p>
C3DAnimationClusterNode
<C3DAnimationClusterNode %p>
SceneKit-CI-nodetree-color-
SceneKit-CI-effect-color-
SceneKit_renderCINodeTree-
SceneKit-CI-nodetree-depth
SceneKit_ApplyCIFilter
SceneKit_renderCIQuad
C3D-CIFilter_middleZ
C3D-CIFilter_extent
SceneKit-CI-nodetree-color
SceneKit-CI-effect-color
SceneKit_renderCINodeTree
^{__CFString=}16@?0^{__CFString=}8
C3DFXCIFilterPassMetal.json
C3DFXCIFilterPass.json
NSNumber
CICrop
inputRectangle
C3D-CIFilter_modelMatrix
SceneKit - Draw wireframe
u_color
u_transform
SCNPhysicsShapeTypeKey
SCNPhysicsShapeKeepAsCompoundKey
SCNPhysicsShapeScaleKey
SCNPhysicsShapeCollisionMarginKey
boundingBox
convexHull
concaveMesh
v32@?0@"SCNPhysicsShape"8Q16^B24
convexDecomposition
transformsCount
transform%d
referenceObject
options
T@"NSDictionary",R,N
sourceObject
T@,R,N,V_referenceObject
transforms
physicsShape[%f,%f,%f]
physicsShape
SCNDefaultPhysicsShape
btTriangleInfoData
btTriangleInfoMapData
float
float2x3
half
half2
half3
half4
short
short2
short3
short4
ushort
ushort2
ushort3
ushort4
char
char4
uchar
uchar4
bool
RGBA8Unorm
RGBA8Unorm_sRGB
R8_sRGB
BGR10_XR
BGR10_XR_sRGB
BGRA10_XR
BGRA10_XR_sRGB
MTLPixelFormatR32Uint
MTLPixelFormatR32Sint
MTLPixelFormatR32Float
MTLPixelFormatRG16Unorm
MTLPixelFormatRG16Snorm
MTLPixelFormatRG16Uint
MTLPixelFormatRG16Sint
MTLPixelFormatRG16Float
MTLPixelFormatRGBA8Snorm
MTLPixelFormatRGBA8Uint
MTLPixelFormatRGBA8Sint
MTLPixelFormatRGB10A2Unorm
MTLPixelFormatRGB10A2Uint
MTLPixelFormatRG11B10Float
MTLPixelFormatRGB9E5Float
MTLPixelFormatRG32Uint
MTLPixelFormatRG32Sint
MTLPixelFormatRG32Float
MTLPixelFormatRGBA16Unorm
MTLPixelFormatRGBA16Snorm
MTLPixelFormatRGBA16Uint
MTLPixelFormatRGBA16Sint
MTLPixelFormatRGBA16Float
MTLPixelFormatRGBA32Uint
MTLPixelFormatRGBA32Sint
MTLPixelFormatRGBA32Float
MTLPixelFormatGBGR422
MTLPixelFormatBGRG422
Depth32Float
Stencil8
UnknownPixelFormat
MTLStorageModeShared
MTLStorageModePrivate
MTLStorageModeMemoryless
Unkown
MTLCPUCacheModeDefaultCache
MTLCPUCacheModeWriteCombined
MTLTextureType1D
MTLTextureType1DArray
MTLTextureType2D
MTLTextureType2DArray
MTLTextureType2DMultisample
MTLTextureTypeCube
MTLTextureType3D
MTLTextureTypeTextureBuffer
shaderRead
shaderWrite
renderTarget
pixelFormatView
MTLTextureUsageShaderRead
MTLTextureUsageShaderWrite
MTLTextureUsageRenderTarget
MTLTextureUsagePixelFormatView
MTLTextureUsageUnknown
byteOrderDefault(Big)
byteOrder16Little
byteOrder32Little
byteOrder16Big
byteOrder32Big
byteOrderUnknown
alphaNone
alphaPremultipliedLast
alphaPremultipliedFirst
alphaLast
alphaFirst
alphaNoneSkipLast
alphaNoneSkipFirst
alphaOnly
alphaUnknown
size
MDLMemoryMappedData
isAttachment
C3DImage
<C3DImage %p src:%@ [%fx%f]>
<C3DImage %p src:%p [%fx%f]>
imageData
imageRelativePath
distantImageURL
file
cgImage
clientImage
bitmap
hasAlpha
pvrtc
minificationFilter
magnificationFilter
%f %f %f %f
maxAnisotropy
C3DTextureSampler
<C3DTextureSampler>
nearest
clamp
repeat
clampToBorder
C3DAnimationClusterKeyframes
<C3DAnimationClusterKeyframes %p>
C3DAnimationCluster
<C3DAnimationCluster %p>
Resource Manager Flush
Environment cube
C3D-EnvMap2D
textureSampler0
u_textureMatrix
C3D-EnvMapCube
u_mvp
u_zfar
Quad
C3DEngineContext
<C3DEngineContext>
CompositeARPass
enableGrain
grainIsColored
renderWithViewpoints
shouldDelegateARCompositing
scn_postprocess_AR_vertex
scn_postprocess_AR_fragment
velocity
jumpSpeed
FloorPass
SceneKit-floor-color-
SceneKit-floor-depth-
OutlinePass
COLOR_OUTLINE
outline_vert
outline_frag
C3DRendererElementState
<C3DRendererElementState>
uv_set
Reset all states
%02x
v16@?0^{__C3DRenderTarget={__CFRuntimeBase=QAQ}{?=CCCb1b1b1b1b1b1[4C]}^{__C3DTexture}Iq^vQIII}8
C3DRendererContext
<C3DRendererContext>
v24@?0C8^{__CFArray=}12I20
v20@?0I8r*12
v20@?0C8r*12
__drawCall
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Engine/AppleEngine/OpenGL/C3DRendererContextGL.c
DownSampleBloomCoCPass
AverageLuminance
Bloom
downsample_2x_bloom
downsample_2x_dof
downsample_2x_bloom_dof
downsample_4x_bloom
downsample_4x_dof
downsample_4x_bloom_dof
ParticleSystem_MeshElement
C3D-ParticleSystem_Trail
C3D-ParticleSystem
C3D-ParticleSystem_PointSprite
%@%1d%1d%c%c%c%c%c%c%c%c%c%1dO%1d%c
enableLighting
enableColorRamp
enableCubeMap
enableStretch
enableAnimation
enableFog
enableStereoRendering
eyeCount
ARMode
animationMode
blendMode
uberparticle_stereo_vert
uberparticle_vert
uberparticleCube_frag
uberparticle_frag
.vsh
.fsh
precision highp float;
precision mediump float;
#define ENABLE_LIGHTING
#define ENABLE_COLOR_RAMP
#define ENABLE_CUBE_MAP
#define ENABLE_STRETCH
#define ENABLE_BILLBOARD_VIEW
#define ENABLE_ORIENTATION_FREE
#define ENABLE_BILLBOARD_Y
#define ENABLE_BILLBOARD_SCREEN
#define ENABLE_FOG
#define ENABLE_ANIMATION %d
#define ENABLE_SOFT
BlackPass
viewTransform
u_fresnelExponent
u_viewTransform2
u_lightPosition0
u_lightColor0
u_colorRamp
u_stretchFactor
u_frameSize
u_softParameters
u_invProj
u_depthSampler0
u_fogParameters
u_fogColor
u_textureSampler0
C3DParticleManager
<C3DParticleManagerRef>
v28@?0I8^^{__C3DNode}12^^{__C3DLight}20
C3DFXJitteringPass.plist
SceneKit_JitterCopyFirstFrame
SceneKit_JitterToEven
SceneKit_JitterToOdd
SceneKit_JitterResolve
Copy_vert
Copy_frag
C3D-Copy
C3D-jitter-factor
IncrementalAverage_vert
IncrementalAverage_frag
C3D-IncrementalAverage
C3DBufferObject
<C3DBufferObject vbo:%ld addr:%p lockCount:%d target:%d retainCount:%d>
overrides
ide_
ske_
simd
geometry.materials[%d]
particleSystems[0]
[%d]
SCNReferenceLoadingStack
referenceRoot
<%@: %p url=%@>
referenceURL
loadingPolicy
childNodes
T@"NSURL",C,N
Tq,N,V_loadingPolicy
loaded
TB,R,GisLoaded
referenceSceneName
T@"NSString",C,N,VreferenceSceneName
referenceNodeName
T@"NSString",C,N,VreferenceNodeName
referenceName
repeatCount
repeatDuration
usesSceneTimeBase
T@"NSString",C,N,VreferenceName
{CATransform3D=dddddddddddddddd}
rgba16f
rgba16unorm
rgba32f
r16f
r32f
rg8s
rg16
rg16f
rgba
framebufferColor
depth24
depth24stencil8
C3DFramebuffer
slot%d: %@ 
<C3DFramebuffer %p: color=%@ - depth=%@ color-samples=%d depth-samples=%d renderTargets:%@>
com.apple.scenekit.resourceCPUQueue
FrameConstant
Volatile
background_2D_vertid
background_2D_frag
background_cube_vertid
background_cube_frag
background_video_vertid
background_video_frag
background_2D_multiple_viewports_vertid
background_2D_multiple_viewports_frag
background_cube_multiple_viewports_vertid
background_cube_multiple_viewports_frag
background_2D_layered_vertid
background_2D_layered_frag
background_cube_layered_vertid
background_cube_layered_frag
Clear binding points
v16@?0@"<MTLBuffer>"8
LightingSet: uploaded count: %d
  LightingSet: uploaded size %d bytes
SceneKit - Draw scene background
SceneKit - Draw video background
v24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}8^{__C3DLightRuntimeData=If[4{?=[4]}]^v^{__C3DTextureSampler}^v^{__C3DTextureSampler}}16
modelTransform
v28@?0^v8I16@"SCNMTLRenderContext"20
inverseModelTransform
modelViewTransform
lightIndices
inverseModelViewTransform
normalTransform
modelViewProjectionTransform
lastFrameModelTransform
motionBlurIntensity
inverseModelViewProjectionTransform
worldBoundingBox
nodeOpacity
shCoefficients
skinningJointMatrices
v24@?0@"SCNMTLResourceBinding"8@"SCNMTLRenderContext"16
scn_lights
scn_lights_count
scn_skinningJointMatrices
scn_shCoefficients
scn_pointSize
u_clusterTexture
u_lightIndicesTexture
u_areaLightBakedDataTexture
u_shadowKernel
v28@?0c8@"SCNMTLResourceBinding"12@"SCNMTLRenderContext"20
u_%@Texture
u_reflectiveCubeTexture
u_shadowTexture%d
u_goboTexture%d
u_iesTexture%d
u_iesCubeTexture%d
position%d
direction%d
right%d
up%d
iesMatrix%d
attenuation%d
spotAttenuation%d
shadowMatrix%d
shadowRadius%d
shadowColor%d
goboMatrix%d
projectorColor%d
u_areaPolygonPositions%d
u_specularDFGTexture
u_radianceTexture
u_irradianceTexture
u_reflectionProbeTexture
u_ssaoTexture
SSAO-Final
v32@?0@"SCNBufferBinding"8@"MTLArgument"16@"SCNMTLShaderBindingsGenerator"24
ds_debug_vert
ds_debug_frag
ds_dir_vert
ds_light_frag
ds_omni_vert
ds_omni_frag
ds_spot_vert
ds_spot_frag
deferred_light_pass
gBuffer0
gBuffer1
gBuffer2
gBuffer3
ds_omni_debug_vert
ds_omni_debug_frag
ds_spot_debug_vert
ds_spot_debug_frag
Rendering light (type: %d)
quad_vertex
quad_display_cube_equirectangular
quad_display_texture2D
quad_display_depth2D
quad_display_depth_cube
scn_draw_fullscreen_fragment_sk
scn_draw_fullscreen_gamma_fragment
SpriteKit - NonLinear Encoding
pendingGPUFrameCount
Tq,R,N
contentScaleFactor
Td,N,V_contentScaleFactor
superSamplingFactor
Td,N,V_superSamplingFactor
screenTransform
T{SCNMatrix4=ffffffffffffffff},N
wantsWideGamut
disableLinearRendering
TB,N,V_enableARMode
TB,N,V_shouldDelegateARCompositing
isOpaque
currentFrameIndex
showsAuthoringEnvironment
enablesDeferredShading
TB,N,VenablesDeferredShading
collectsCompilationErrors
compilationErrors
T@"NSMutableDictionary",R,N
generatedTexturePath
T@"NSString",&,N,V_generatedTexturePath
TI,R,N
profile
Ti,R,N
resourceManager
T@"SCNMTLResourceManager",R,N,V_resourceManager
debugOptions
TQ,N,V_debugOptions
currentRenderCommandEncoder
T@"<MTLRenderCommandEncoder>",R,N
currentRenderPassDescriptor
T@"MTLRenderPassDescriptor",R,N
currentCommandBuffer
resourceCommandBuffer
resourceComputeEncoder
T^{SCNMTLComputeCommandEncoder=[31@][31Q][31@][16@]@@@^{SCNMTLBufferPool}I[1Q][1Q]},R,N
resourceBlitEncoder
T^{SCNMTLBlitCommandEncoder=@@},R,N
engineContext
T^{__C3DEngineContext=},R,N
textureTarget
T@"<MTLTexture>",R,N
layerTarget
T@"CAMetalLayer",R,N
preferredFramesPerSecond
shouldPresentAfterMinimumDuration
TB,N,V_shouldPresentAfterMinimumDuration
resourceQueue
T@"NSObject<OS_dispatch_queue>",R,N
resourceGroup
T@"NSObject<OS_dispatch_group>",R,N
clientRenderPassDescriptor
T@"MTLRenderPassDescriptor",&,N,V_clientRenderPassDescriptor
clientRenderCommandEncoder
T@"<MTLRenderCommandEncoder>",&,N,V_clientRenderCommandEncoder
clientCommandBuffer
T@"<MTLCommandBuffer>",&,N,V_clientCommandBuffer
clientCommandQueue
T@"<MTLCommandQueue>",&,N,V_clientCommandQueue
frameConstantBufferPool
T^v,R,N
frameTexturePool
T^v,R,N,V_frameTexturePool
renderEncoder
T^v,R,N,V_renderEncoder
v24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}8*16
morpherCompressedData
morpherMetaData
SCNDecodeMorpherUsingAnimCodec
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DKit/classes/SCNMorpherAnimCodecSupport.mm
morpherMetaData.length >= (2+targetCount)
point
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/AnimCodec/public/Mesh.h
index < pointCount()
setPoint
setPolygonSize
j < polygonCount()
setIndex
i < indexCount()
I16@?0^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}8
C3DGeometryInitSubdivTopologyInfoIfNeeded
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Core/C3DGeometryOpenSubdivSupportInternal.cpp
(int32_t)vertexCountPerFaceCurrentIndex == topologyInfo->topologyDescriptor.numFaces
vertIndicesPerFaceCurrentIndex == topologyInfo->totalIndexCount
C3DSubdivCreateMesh
faceVertexIndices.size() == 4
Interpolate
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/primvarRefiner.h
level>0 && level<=(int)_refiner._refinements.size()
interpFromEdges
refinement.getNumChildVerticesFromFaces() > 0
Vtr::IndexIsValid(cVertOfFace)
interpFromVerts
vMask.AreFaceWeightsForFaceCenters()
assignSmoothMaskForVertex
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/../sdc/catmarkScheme.h
vertex.GetNumFaces() == vertex.GetNumEdges()
CombineVertexVertexMasks
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/../sdc/../sdc/scheme.h
this->AreFaceWeightsForFaceCenters() == dst.AreFaceWeightsForFaceCenters()
InterpolateVarying
InterpolateFaceVarying
interpFVarFromEdges
eFaceIndex == i
interpFVarFromVerts
pSibling == cSibling
CreateMeshSources
faceVertexCount == 4
Failure in PrimvarRefiner::Limit() -- last level of refinement does not include full topology.
limit
tan1Mask.GetNumFaceWeights() == tan2Mask.GetNumFaceWeights()
tan1Mask.GetNumEdgeWeights() == tan2Mask.GetNumEdgeWeights()
assignSmoothLimitMask
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/../sdc/loopScheme.h
valence != 2
internalSettings
forceGLES
forceMetal
showsStatistics
cameraControlEnabled
batchMaxCount
disableLinearSpaceRendering
disableWideGamut
enableWideGamut
enablePostMorphUnifyNormals
enableStandardShadersWithFunctionConstants
forceNMOSBehavior
com.apple.sceneKit.forceOS2019Behavior
com.apple.sceneKit.forceOS2018Behavior
com.apple.sceneKit.forceOS2017Behavior
com.apple.sceneKit.forceOS2016Behavior
com.apple.sceneKit.useOneCommandQueuePerDevice
disableReverseZ
com.apple.sceneKit.isolateCacheMissShader
com.apple.scenekit.resourceManagerDeletionQueue
C3DResourceManager
<C3DResourceManager>
kResourceManagerPendingMeshElementRemoval
kResourceManagerPendingImageRemoval
kResourceManagerPendingImageProxyRemoval
kResourceManagerPendingProgramRemoval
kResourceManagerPendingMeshRemoval
kResourceManagerPendingMeshSourceRemoval
-[SCNView(SCNDisplayLink) _initializeDisplayLinkWithScreen:completionHandler:]_block_invoke
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DKit/cocoa/SCNDisplayLink_ARC.m
ret == 0
scenekit_worker_group
wg != NULL
com.apple.scenekit.scnview-renderer
C3DTexture
<C3DTexture>
T@"<MTLBuffer>",R,N,V_buffer
bufferSize
TQ,R,N,V_bufferSize
elementSize
TQ,R,N,V_elementSize
MBFinalBlurPass
VELOCITY
MB-TileMax
scn_draw_fullscreen_triangle_VR_pos_uv_uvNorm_vertex
scn_motionblur_blur
scn_motionblur_blur_resize
BloomDownSamplePass
scn_bloom_downsample
SCNDefaultIrradiance
SCNDefaultRadiance
compute_diffusePreIntegrated_texture2d
compute_diffusePreIntegrated
scn_draw_fullscreen_quad_vertex
cubemap_from_sh
compute_specularPreIntegratedLD_texture2d
compute_specularPreIntegratedLD_texturecube
compute_specularPreIntegratedDFG
C3DImageProxy
<C3DImageProxy>
C3DTextureProxy
<C3DTextureProxy>
SSAOMinMaxOffsetPass
scn_ssao_downsample
-[NSData(SCNExtensions) scn_indexedDataEncodingHighWatermarkWithBytesPerIndex:]
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DKit/utils/NSData+SCNExtensions.m
-[NSData(SCNExtensions) scn_indexedDataDecodingHighWatermarkWithBytesPerIndex:]
-[NSData(SCNExtensions) scn_indexedDataEncodingDeltaWithBytesPerIndex:]
-[NSData(SCNExtensions) scn_indexedDataDecodingDeltaWithBytesPerIndex:]
v16@?0^{__C3DEngineContext=}8
C3DEnginePipeline
<C3DEnginePipeline %p>
SSRBlurPass-Y
SSRBlurPass-X
lobeFootprint
scn_ssr_blur_x
scn_ssr_blur_y
SceneKit-CI-effect-depth-
C3D-CIFilter_reverseZ
SceneKit-CI-effect-depth
C3DFXCIFilterPassMetalRenderGraph.json
%@%p
compute_sh%d_from_cubemap_threadgroup_mem
compute_sh%d_from_cubemap
sum_sh%d
SSRCompositePass
Radiance
ReflectanceRoughness
scn_ssr_composite_frag
frameA
frameB
maximumAngularLimit1
maximumAngularLimit2
maximumTwistAngle
C3DFXProgramDelegate
<C3DFXProgramDelegate %p>
SCN_ENABLE_COLLECTION
scenekit.fps
scenekit.primcnt
scenekit.frmtime
scenekit.phytime
scenekit.prttime
scenekit.animtime
scenekit.clientTime
scenekit.consttime
scenekit.rendertime
scenekit.cpuidletime
scenekit.cawaittime
scenekit.deviceutil
scenekit.rendererutil
scenekit.tilerutil
IOAcceleratorES
PerformanceStatistics
__scnPerformanceData
v24@?0{_CSTypeRef=QQ}8
scenekit.shaderCompilationTime
scenekit.shaderGenerationCount
Device Utilization %
Renderer Utilization %
Tiler Utilization %
SceneKitShaderCache
com.apple.sceneKit.traceResources
containerPath
commonProfile_
metal
error
can't create symbolicator for pid
__scnDebuggingInfo
can't find symbol __scnDebuggingInfo
can't mmap memory for symbol __scnDebuggingInfo
can't get mem rangefor symbol __scnDebuggingInfo
failed to read memory for symbol __scnDebuggingInfo
applicationContainerPath not set
double
C3DFloat
color4
ucharn
charn
10a2n
u10a2n
uchar4n
char4n
ushortn
ushort2n
ushort3n
ushort4n
short2n
short3n
short4n
unknown type
hw.optional.sse2
hw.optional.sse3
hw.optional.supplementalsse3
hw.optional.sse4_1
hw.optional.sse4_2
hw.optional.avx1_0
hw.optional.fma
SCNDisableLinearSpaceRendering
SCNDisableWideGamut
SCNEnableWideGamut
Aixt/MEN2O2B7f+8m4TxUA
SKESceneDocument
SKEDocumentSanitizer
mat44
#define %@ %@
SCNSourceURLForCurrentlyUnarchivedScene
currentMorphTargets
T@"NSArray",&,N,V_currentMorphTargets
documentURL
T@"NSURL",&,N,V_documentURL
context
T@"NSDictionary",&,N,V_context
assetCatalog
T@"SCNAssetCatalog",&,N,V_assetCatalog
lookUpKey
T@"NSString",&,N,V_lookUpKey
lookUpFoundInstance
T@,&,N,V_lookUpFoundInstance
documentEnclosingURL
T@"NSURL",R,N
skipMorphTargets
TB,N,VskipMorphTargets
T@"NSDictionary",C,N,Voptions
C3DFXShader
<C3DFXShader %@>
source
stage
C3DLightProbesSystem
<C3DLightProbesSystem %p>
usedCount
Tq,V_usedCount
T@"<MTLBuffer>",&,N,V_buffer
TQ,N,V_offset
dataSource
T@,N,V_dataSource
<%@: %p> "%@"
argument
T@"MTLArgument",&,N,V_argument
argumentEncoder
T@"<MTLArgumentEncoder>",&,N,V_argumentEncoder
TQ,R,N
T@"NSString",R,N
usedResources
T@"NSMutableArray",R,N
needsRenderResource
bindBlock
T@,C,N,V_bindBlock
semanticsCount
Tq,N,VsemanticsCount
Tq,N,VbufferSize
inputsCount
Tq,N,VinputsCount
materialModificationCount
Tq,N,VmaterialModificationCount
geometryModificationCount
Tq,N,VgeometryModificationCount
<%@: %p>
<state: %@>
FrameBuffer bindings:
Node bindings:
Pass bindings:
Shadable bindings:
Light bindings:
state
T@"<MTLRenderPipelineState>",&,N,V_state
vertexDescriptor
T@"MTLVertexDescriptor",C,N,V_vertexDescriptor
vertexFunction
T@"<MTLFunction>",&,N,V_vertexFunction
fragmentFunction
T@"<MTLFunction>",&,N,V_fragmentFunction
frameBufferBindings
T@"NSArray",C,N,V_frameBufferBindings
nodeBufferBindings
T@"NSArray",C,N,V_nodeBufferBindings
passBufferBindings
T@"NSArray",C,N,V_passBufferBindings
shadableBufferBindings
T@"NSArray",C,N,V_shadableBufferBindings
lightBufferBindings
T@"NSArray",C,N,V_lightBufferBindings
vertexBuffersUsageMask
T@"<MTLComputePipelineState>",&,N,V_state
computeFunction
T@"<MTLFunction>",&,N,V_computeFunction
buffer[%d] : %@
element[%d] : %@
buffers
T@"NSArray",C,N,V_buffers
elements
T@"NSArray",C,N,V_elements
stageDescriptor
T@"MTLStageInputOutputDescriptor",&,N,V_stageDescriptor
T@"MTLVertexDescriptor",C,N
vertexDescriptorHash
tessellationVertexDescriptor
T@"MTLVertexDescriptor",R,N,V_tessellationVertexDescriptor
tessellationVertexDescriptorHash
volatileBuffer
T@"<MTLBuffer>",&,N,V_volatileBuffer
volatileOffset
TQ,N,VvolatileOffset
volatileStride
TQ,N,VvolatileStride
volatileSize
TQ,N,VvolatileSize
verticesCount
Tq,N,VverticesCount
mutabilityTimestamp
Tq,N,V_mutabilityTimestamp
<SCNMTLMeshElement: %p type: %d index buffer: %@ [%d] effective count: %d offset: %d>
indexCount
Tq,N,V_indexCount
instanceCount
TQ,N,V_instanceCount
sharedIndexBufferOffset
Tq,N,V_sharedIndexBufferOffset
indexBuffer
T@"SCNMTLBuffer",&,N,V_indexBuffer
indexType
TQ,N,V_indexType
primitiveType
TQ,N,V_primitiveType
primitiveCount
effectiveIndexOffset
Tq,R,N,V_effectiveIndexOffset
effectiveIndexCount
Tq,R,N,V_effectiveIndexCount
SCNLightingModelConstant
SCNLightingModelLambert
SCNLightingModelPhong
SCNLightingModelBlinn
SCNLightingModelNone
SCNLightingModelShadowOnly
SCNLightingModelPhysicallyBased
SCNLightingModelInvalid
C3DEffectCommonProfile
<C3DEffectCommonProfile %p :
 lightingModel:%@
 perPixelLit:%d
 isOpaque:%d
 transparencyMode:%d
Emission
Ambient
Diffuse
Specular
Reflective
Transparent
Filter
Ambient Occlusion
Self Illumination
Metalness
Roughness
ClearCoat
ClearCoatRoughness
ClearCoatNormal
Displacement
Shininess
Reflectivity
Transparency
Fresnel
[%@] texture:%d xform:%d
versionNumber
ambientIntensity
diffuseIntensity
specularIntensity
emissionIntensity
multiplyIntensity
transparentIntensity
normalIntensity
ambientOcclusionIntensity
selfIlluminationIntensity
displacementIntensity
reflectiveIntensity
locksAmbientWithDiffuse
Intensity
lightingModel
imagesCount
C3DEffectSlot
<C3DEffectSlot>
sampler
mtltexture
imageProxy
uvSet
threshold
thresholdType
C3DLOD
<C3DLOD>
DOFFinalBlurPass
DOFCoCBlurred
DOF-Final
enableBloom
enableVignetting
enableColorGrading
enableSaturation
enableContrast
enableColorFringe
enableDebug
enableExposure
enableFrameLuminanceAutoExposure
enableHistogramAutoExposure
enableDepthOfField
DOFSampleCount
enableVR
enableWhiteBalance
dof_blur
dof_compute_kernel
_duration
_timingMode
_beginTime
_pausedTime
_isRunning
_finished
duration
timingMode
timingFunction
T@?,N
speed
T{SCNVector3=fff},N,Vposition
euler
T{SCNVector3=fff},N,Veuler
T{SCNVector3=fff},N,Vscale
T{SCNVector4=ffff},N,Vrotation
usesEuler
TB,N,VusesEuler
Tf,N,Vopacity
SCNActionCacheKey
DrawQuadPass
.<>?:/|&^*/+-=%!~
SSAODepthNormalPass
--DepthAndNormalMaterial--
#pragma body
_output.color = float4(_surface.normal.xyz, _surface.position.z);
C3DEdgeArray
<C3DEdgeArray>
C3DTriangulationInfo
<C3DTriangulationInfo>
C3DMeshElementEditor
<C3DMeshElementEditor>
script
JSContext
elapsedTime
T@"SCNNode",&,N,Vnode
component
T@,&,N,Vcomponent
elementIndex
TQ,N,VelementIndex
worldTransform
elementPosition
C3DIndexSet
indexSet 
(no index)
[number of indexes: %lu (in %lu ranges), indexes: (
-%lu
mass
charge
friction
restitution
rollingFriction
ccdThreshold
damping
angularVelocity
angularDamping
linearRestingThreshold
angularRestingThreshold
velocityFactor
angularVelocityFactor
ignoreGravity
explicitMomentOfInertia
momentOfInertia
centerOfMassOffset
collisionBitMask
contactTestBitMask
allowsResting
isDefaultShape
linearSleepingThreshold
angularSleepingThreshold
usesDefaultMomentOfInertia
T@"SCNPhysicsShape",&,N
isResting
T{SCNVector4=ffff},N
affectedByGravity
TB,N,GisAffectedByGravity
continuousCollisionDetectionThreshold
Td,N,V_continuousCollisionDetectionThreshold
C3DConvexPolyhedron
<C3DConvexPolyhedron %p>
autoreverses
additive
cumulative
isAnimationClip
removeOnCompletion
sceneTimeBased
fillModeMask
timeOffset
beginTime
fadeInDuration
fadeOutDuration
simpleAnimation
C3DSimpleAnimation
<C3DSimpleAnimation>
baseType
startValue
byValue
endValue
cube_blur_h%d
cube_blur_v%d
CubeBlurPass
C3DLightAddLightSHContribution
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Core/C3DLight.c
C3DLight
<C3DLight %p> Type:%@ CastsShadow(Samples:%d Cascade:%d)
<C3DLight %p> Type:%@
Directional
Omni
Spot
Irradiance
Area[Rectangle]
Area[Polygon]
Area[Line]
Area[Ellipse]
Area[Ellipsoid]
Unknown
attenuationEndDistance
attenuationStartDistance
shadowBias
temperature
shadowCascadeDebugFactor
property3
property4
castShadow
znear
zfar
shadowSoftenFactor
category
Color
shadowMapSize
directionalExtent
shadowMaxSampleCount
Area light - Rectangle
Area light - Polygon
Area Light - Line
Area Light - Ellipse
Area Light - Ellipsoid
area_shape_vert
area_shape_ellipse_frag
halfExtents
area_shape_ellipsoid_frag
sh_eval_direction
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Math/sh_math.h
order < kSHMinOrder || order > kSHMaxOrder
sh_accumulate_omni_light
v36@?0I8^^{__C3DNode}12^^{__C3DLight}20^(?={?=ffff})28
v16@?0^{__C3DParticleSystemInstance={__CFRuntimeBase=QAQ}^{__C3DParticleEmitter}IIi^{__C3DNode}^{__C3DParticleSystem}^{__C3DParticleManager}^{__C3DScene}d{?=[32^v][21^v][21^v]{__C3DParticleArrayLayout=[32I][32^?]I[21C][21C]}}IIIIIBdf{?=}{?={?=SS}I}^{__CFArray}^{__CFArray}}8
v36@?0I8^^{__C3DNode}12^^{__C3DLight}20^{?=ffff}28
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/NewRenderer/SCNMTLClusterSystem.mm
clusterCellSize == sizeof(simd_ushort2)
__compactLightIndices
debug_omni_vert
debug_light_frag
debug_spot_vert
debug_cluster_frag
scn_draw_fullscreen_quad_VR_pos_vertex
debug_light_indices_8_buffer_frag
debug_cluster_slices_frag
C3DCamera
<C3DCamera>
fStop
aspectRatio
sensorHeight
lensShift
averageGray
bloomBlurRadius
bloomIntensity
bloomThreshold
bloomIteration
bloomIterationSpread
colorFringeStrength
colorFringeIntensity
contrast
grainIntensity
grainScale
exposureAdaptationBrighteningSpeedFactor
exposureAdaptationDarkeningSpeedFactor
exposureAdaptationDuration
exposureAdaptationHistogramRangeHighProbability
exposureAdaptationHistogramRangeLowProbability
exposureOffset
focusDistance
focalLength
maximumExposure
minimumExposure
saturation
vignettingIntensity
vignettingPower
whitePoint
screenSpaceAmbientOcclusionIntensity
screenSpaceAmbientOcclusionRadius
screenSpaceAmbientOcclusionBias
screenSpaceAmbientOcclusionDepthThreshold
screenSpaceAmbientOcclusionNormalThreshold
screenSpaceAmbientOcclusionSampleCount
screenSpaceAmbientOcclusionDownSample
whiteBalanceTemperature
whiteBalanceTint
ortho
letterbox
fovHorizontal
customProj
autoZRange
xfov
yfov
xMag
bladeCount
dofSampleCount
sensorSize
orthoScale
PickedObjectPass
COLOR_PICKED
DEPTH_PICKED
--OutlineMaterial--
%s%p
C3DNode
<C3DNode:%p "%@"
  geometry: %@
  light: %@
  camera: %@
  skinner: %@
  morpher: %@
alpha
isJoint
matrix4x4
axisAngle
kC3D
firstChild
nextSibling
parent
skinner
v24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}8^B16
_opacityTarget
_opacityTargetReversed
_lastOpacity
_isRelative
sources
primarySourcesInfo
subIDs
C3DMesh
<C3DMesh %p "%@"
  element%d: %@
  source %@%d (channel:%d) : %@
  source %@ (channel:%d) : %@
  renderable element%d: %@
  renderable source %@%d: %@
  renderable source %@: %@
baseSourceLocators
verticesMask
boundingSphere
meshElements
effectID
C3DMaterial
<C3DMaterial %p : "%@", 
common profile %@
custom %@
__library__
enableWriteInDepthBuffer
enableReadsFromDepthBuffer
fillMode
nodeConstraints-%p
C3DScene
<C3DScene>
fogColor
fogDensityExponent
fogEndDistance
fogStartDistance
wantsScreenSpaceReflection
screenSpaceReflectionSampleCount
screenSpaceReflectionMaximumDistance
screenSpaceReflectionStride
startTime
endTime
frameRate
upAxis
nodeTree
nodeID
childs
root
playbackSpeed
animationManager
lightingSystem
results
backfaceCulling
closest
ccdPenetration
behaviors
gravity
timeStep
contactDelegate
T@"<SCNPhysicsContactDelegate>",W
allBehaviors
{CGPoint=dd}
{SCNVector3=fff}
{CGRect={CGPoint=dd}{CGSize=dd}}
{SCNVector4=ffff}
{SCNMatrix4=ffffffffffffffff}
{?=[4]}
SKGlobalSharedContextRegistry
MBNeighborMaxPass
scn_motionblur_neighbormax_x
scn_motionblur_neighbormax_y
SCNLightAttenuationStartKey
SCNLightAttenuationEndKey
SCNLightAttenuationFalloffExponentKey
SCNLightSpotInnerAngleKey
SCNLightSpotOuterAngleKey
SCNLightSpotFalloffExponentKey
SCNLightShadowNearClippingKey
SCNLightShadowFarClippingKey
SCNLightGoboProjectShadows
SCNLightConstantAttenuationKey
SCNLightLinearAttenuationKey
SCNLightQuadraticAttenuationKey
SCNLightFallOffAngleKey
SCNLightFallOffExponentKey
SCNLightHotspotBeamKey
omni
directional
spot
probe
area
<%@: %p '%@' | type=%@>
<%@: %p | type=%@>
-[SCNLight setName:]
%@.%@
-[SCNLight setAttenuationEndDistance:]
-[SCNLight setAttenuationFalloffExponent:]
-[SCNLight setAttenuationStartDistance:]
-[SCNLight setBaked:]
-[SCNLight setCastsShadow:]
-[SCNLight setCategoryBitMask:]
-[SCNLight setColor:]
-[SCNLight setIntensity:]
-[SCNLight setOrthographicScale:]
-[SCNLight setShadowBias:]
-[SCNLight setShadowColor:]
-[SCNLight setShadowMapSize:]
-[SCNLight setShadowRadius:]
-[SCNLight setShadowSampleCount:]
-[SCNLight setSpotFalloffExponent:]
-[SCNLight setSpotInnerAngle:]
-[SCNLight setSpotOuterAngle:]
-[SCNLight setTechnique:]
-[SCNLight setTemperature:]
-[SCNLight setType:]
-[SCNLight setUsesDeferredShadows:]
-[SCNLight setUsesModulatedMode:]
-[SCNLight setZFar:]
-[SCNLight setZNear:]
-[SCNLight setShadowCascadeCount:]
-[SCNLight setAutomaticallyAdjustsShadowProjection:]
-[SCNLight setMaximumShadowDistance:]
-[SCNLight setForcesBackFaceCasters:]
-[SCNLight setSampleDistributedShadowMaps:]
-[SCNLight setShadowCascadeSplittingFactor:]
-[SCNLight set_shadowCascadeDebugFactor:]
usesDeferredShadows
lightCategoryBitMask
spotFallOffExponent
probeType
probeUpdateType
parallaxCorrectionEnabled
probeExtentsX
probeExtentsY
probeExtentsZ
probeOffsetX
probeOffsetY
probeOffsetZ
parallaxOffsetX
parallaxOffsetY
parallaxOffsetZ
parallaxExtentsFactorX
parallaxExtentsFactorY
parallaxExtentsFactorZ
maximumShadowDistance
autoShadowProjection
shadowCascadeCount
shadowCascadeSplittingFactor
forcesBackFaceCasters
sampleDistributedShadowMaps
castsShadow
usesModulatedMode
baked
shouldBakeDirectLighting
shouldBakeIndirectLighting
sphericalHarmonics
scncolor
scnShadowColor
shadowSampleCount
shadowSampleCount2
IESProfileURL
technique
areaType
areaExtentsX
areaExtentsY
areaExtentsZ
areaPolygonVertices
drawsArea
T@"NSString",C,N
T@,&,N
T{CGSize=dd},N
shadowMode
automaticallyAdjustsShadowProjection
T@"NSURL",&,N
sphericalHarmonicsCoefficients
T@"NSData",R,C,N
probeExtents
probeOffset
parallaxExtentsFactor
parallaxCenterOffset
T@"SCNMaterialProperty",R,N
areaExtents
T@"NSArray",C,N
VertexCache
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Core/C3DMeshElement_Tools.cpp
cacheSize < kMaxCacheSize
T@"<MTLLibrary>",R,N,V_library
metallib
com.apple.scenekit.device
scenekit
commonProfile_%@.metal
v16@?0@"NSString"8
v24@?0@"NSString"8@"NSString"16
v24@?0@"NSString"8^B16
v24@?0@"<MTLLibrary>"8@"NSError"16
C3DFramebufferRegistry
<C3DFramebufferRegistry>
(null)
v36@?0I8^^{__C3DNode}12^^{__C3DLight}20^28
C3DLightingSystem
<C3DLightingSystem %p>
Texture
Buffer
Invalid - wrong value
C3D::PassBufferParameter [
] : 
GridPass
C3D_grid_vert
C3D_grid_frag
offsetX
offsetY
mappingChannel
-[SCNMaterial setName:]
  %@=%@
.color
content
-[SCNMaterial _shadableSetValue:forUndefinedKey:]
shaderModifiers.
customMaterialProperties
customMaterialAttributes
-[SCNMaterial setShaderModifiers:]
-[SCNMaterial copyShaderModifiersFrom:]
-[SCNMaterial setProgram:]
valuesForUndefinedKeys
failed to archive material's custom attributes. %@ %@
lightingModelName
shadableHelper
avoidsOverLighting
writesToDepthBuffer
readsFromDepthBuffer
colorBufferWriteMask
T@"SCNProgram",&,N
T@"NSDictionary",C,N
TB,N,GisLitPerPixel
TB,N,GisDoubleSided
Position
Angle
RotationAxis
Velocity
AngularVelocity
Life
Opacity
Size
Frame
FrameRate
Bounce
Friction
Charge
ContactPoint
ContactNormal
-[SCNParticleSystem setName:]
scnp
failed to unarchive particle data at %@ (%@)
-[SCNParticleSystem setParticleGeometries:]
-[SCNParticleSystem setColliderNodes:]
-[SCNParticleSystem setPropertyControllers:]
-[SCNParticleSystem setParticleImage:]
-[SCNParticleSystem _setParticleImagePath:withResolvedPath:]
-[SCNParticleSystem setOrientationDirection:]
orientationDirection
-[SCNParticleSystem setLightEmissionRadiusFactor:]
fixedTimeStep
-[SCNParticleSystem setAffectedByGravity:]
-[SCNParticleSystem setAffectedByPhysicsFields:]
-[SCNParticleSystem setBirthDirection:]
-[SCNParticleSystem setBirthLocation:]
-[SCNParticleSystem setBirthRate:]
birthRate
-[SCNParticleSystem setBirthRateVariation:]
birthRateVariation
-[SCNParticleSystem setBlackPassEnabled:]
-[SCNParticleSystem setBlendMode:]
-[SCNParticleSystem setDampingFactor:]
dampingFactor
-[SCNParticleSystem setEmissionDuration:]
emissionDuration
-[SCNParticleSystem setEmissionDurationVariation:]
emissionDurationVariation
-[SCNParticleSystem setEmitterShape:]
-[SCNParticleSystem setFixedTimeStep:]
-[SCNParticleSystem setFresnelExponent:]
-[SCNParticleSystem setIdleDuration:]
idleDuration
-[SCNParticleSystem setIdleDurationVariation:]
idleDurationVariation
-[SCNParticleSystem setImageSequenceAnimationMode:]
-[SCNParticleSystem setImageSequenceColumnCount:]
imageSequenceColumnCount
-[SCNParticleSystem setImageSequenceFrameRate:]
imageSequenceFrameRate
-[SCNParticleSystem setImageSequenceFrameRateVariation:]
imageSequenceFrameRateVariation
-[SCNParticleSystem setImageSequenceInitialFrame:]
imageSequenceInitialFrame
-[SCNParticleSystem setImageSequenceInitialFrameVariation:]
imageSequenceInitialFrameVariation
-[SCNParticleSystem setImageSequenceRowCount:]
imageSequenceRowCount
-[SCNParticleSystem setIsLocal:]
isLocal
-[SCNParticleSystem setLightingEnabled:]
-[SCNParticleSystem setLoops:]
-[SCNParticleSystem setOrientationMode:]
-[SCNParticleSystem setParticleAngle:]
particleAngle
-[SCNParticleSystem setParticleAngleVariation:]
particleAngleVariation
-[SCNParticleSystem setParticleAngularVelocity:]
particleAngularVelocity
-[SCNParticleSystem setParticleAngularVelocityVariation:]
particleAngularVelocityVariation
-[SCNParticleSystem setParticleBounce:]
particleBounce
-[SCNParticleSystem setParticleBounceVariation:]
particleBounceVariation
-[SCNParticleSystem setParticleCharge:]
particleCharge
-[SCNParticleSystem setParticleChargeVariation:]
particleChargeVariation
-[SCNParticleSystem setParticleColor:]
particleColor
-[SCNParticleSystem setParticleDiesOnCollision:]
-[SCNParticleSystem setParticleFriction:]
particleFriction
-[SCNParticleSystem setParticleFrictionVariation:]
particleFrictionVariation
-[SCNParticleSystem setParticleLifeSpan:]
particleLifeSpan
-[SCNParticleSystem setParticleLifeSpanVariation:]
particleLifeSpanVariation
-[SCNParticleSystem setParticleMass:]
particleMass
-[SCNParticleSystem setParticleMassVariation:]
particleMassVariation
-[SCNParticleSystem setParticleSize:]
particleSize
-[SCNParticleSystem setParticleSizeVariation:]
particleSizeVariation
-[SCNParticleSystem setParticleVelocity:]
particleVelocity
-[SCNParticleSystem setParticleVelocityVariation:]
particleVelocityVariation
-[SCNParticleSystem setPhysicsCollisionsEnabled:]
-[SCNParticleSystem setRenderingMode:]
-[SCNParticleSystem setSeed:]
-[SCNParticleSystem setSoftParticlesEnabled:]
-[SCNParticleSystem setSortingMode:]
-[SCNParticleSystem setSpeedFactor:]
speedFactor
-[SCNParticleSystem setSpreadingAngle:]
spreadingAngle
-[SCNParticleSystem setStretchFactor:]
stretchFactor
-[SCNParticleSystem setSystemSpawnedOnCollision:]
-[SCNParticleSystem setSystemSpawnedOnDying:]
-[SCNParticleSystem setSystemSpawnedOnLiving:]
-[SCNParticleSystem setWarmupDuration:]
warmupDuration
-[SCNParticleSystem setParticleIntensity:]
particleIntensity
-[SCNParticleSystem setParticleIntensityVariation:]
particleIntensityVariation
-[SCNParticleSystem setParticleColorVariation:]
particleColorVariation
-[SCNParticleSystem setEmittingDirection:]
emittingDirection
-[SCNParticleSystem setAcceleration:]
acceleration
particleImage
emitterShape
birthLocation
birthDirection
affectedByPhysicsFields
physicsCollisionsEnabled
lightingEnabled
softParticlesEnabled
particleDiesOnCollision
blackPassEnabled
systemSpawnedOnCollision
systemSpawnedOnDying
systemSpawnedOnLiving
seed
renderingMode
orientationMode
imageSequenceAnimationMode
particleGeometries
colliderNodes
propertyControllers
sortingMode
T@"SCNGeometry",&,N
local
TB,N,GisLocal
T@"SCNParticleSystem",&,N
T@"UIColor",&,N
TB,N,GisBlackPassEnabled
TB,N,GisLightingEnabled
copy_texture_3D_from_buffer_ushort
FillTexturePass
kProjectionTransform
kModelTransform
kViewTransform
kModelViewProjectionTransform
kModelViewTransform
kNormalTransform
kRenderPassName
-[SCNNode setName:]
%s%s {
dump node tree (%@)
------------------------------------------------------
%@%@
<%p>
-[SCNNode _setQuaternion:]
-[SCNNode _setPosition:]
-[SCNNode _setScale:]
-[SCNNode setMovabilityHint:]
-[SCNNode setCastsShadow:]
-[SCNNode setCategoryBitMask:]
-[SCNNode setHidden:]
-[SCNNode setOpacity:]
-[SCNNode setRenderingOrder:]
 pos(%f %f %f)
 rot(%f %f %f %f)
 scale(%f %f %f)
 light=%@
 camera=%@
 geometry=%@
 | no child
 | 1 child
 | %d children
nodes
filters.
-[SCNNode setValue:forUndefinedKey:]
Error: physicsBody %@ already has a owner: %@ that is not %@
constraints
physicsBody
physicsField
particleSystem
fixedBoundingBoxExtrema[0]
fixedBoundingBoxExtrema[1]
paused
focusBehavior
action-keys
actions
clientAttributes
failed to archive node's client attributes. %@ %@
movabilityHint
renderingOrder
hasActions
actionKeys
preferredFocusEnvironments
T@"NSArray",R,C,N
parentFocusEnvironment
T@"<UIFocusEnvironment>",R,W,N
focusItemContainer
T@"<UIFocusItemContainer>",R,N
preferredFocusedView
T@"UIView",R,W,N
focusGroupIdentifier
T@"NSString",R,C,N
canBecomeFocused
frame
T{CGRect={CGPoint=dd}{CGSize=dd}},R,N
T@"SCNLight",&,N
T@"SCNCamera",&,N
T@"SCNSkinner",&,N
T@"SCNMorpher",&,N
T{SCNMatrix4=ffffffffffffffff},R,N
worldPosition
worldOrientation
TB,N,GisHidden
parentNode
T@"SCNPhysicsBody",&,N
T@"SCNPhysicsField",&,N
T@"NSArray",C
presentationNode
TB,N,GisPaused
T@"<SCNNodeRendererDelegate>",N
worldUp
worldRight
worldFront
localUp
localRight
localFront
-[SCNNode(SIMD) setSimdPivot:]
-[SCNNode(SIMD) setSimdTransform:]
-[SCNNode(SIMD) setSimdRotation:]
simdTransform
T{?=[4]},N
simdPosition
simdRotation
simdOrientation
T{?=},N
simdEulerAngles
simdScale
simdPivot
simdWorldPosition
simdWorldOrientation
simdWorldTransform
simdWorldUp
T,R,N
simdWorldRight
simdWorldFront
simdLocalUp
simdLocalRight
simdLocalFront
BloomUpSamplePass
scn_bloom_upsample
kSceneStartTimeAttributeKey
kSceneEndTimeAttributeKey
kSceneFrameRateAttributeKey
kSceneUpAxisAttributeKey
org.khronos.collada.digital-asset-exchange
scnz
com.apple.scenekit.scene
com.apple.scenekit.scene.zip
com.pixar.universal-scene-description-mobile
public.polygon-file-format
public.geometry-definition-format
public.standard-tesselated-geometry-format
com.pixar.universal-scene-description
usda
usdc
MDLAsset
sceneDump%d.scn
dumping scene to %@
children[
physicsWorld
userAttributes
sourceURL
T@"SCNPhysicsWorld",R,N
lightingEnvironment
SCNRendererOffscreenSampleCount
viewMatrix
T{SCNMatrix4=ffffffffffffffff},N,VviewMatrix
projectionMatrix
T{SCNMatrix4=ffffffffffffffff},N,VprojectionMatrix
passDescriptor
T@"MTLRenderPassDescriptor",&,N
viewport
T{?=dddddd},N
waitEvent
T@"<MTLEvent>",&,N,V_waitEvent
waitFrame
TQ,N,V_waitFrame
signalEvent
T@"<MTLEvent>",&,N,V_signalEvent
signalFrame
TQ,N,V_signalFrame
transition pass
outgoingScene
T@"SCNScene",&,N,V_outgoingScene
transition
T@"SKTransition",&,N,V_transition
transitionStartTime
Td,N,V_transitionStartTime
outgoingPointOfView
T@"SCNNode",&,N,V_outgoingPointOfView
com.apple.scenekit.renderingQueue.%@%p
SKSCNRenderer
<SCNRenderer %p: scene = %@, pointOfView = %@, sceneTime = %f, context = %p>
SceneKit - Delete Framebuffer
SceneKit - Create Framebuffer
camera.xFov
camera.yFov
camera.fieldOfView
camera.orthographicScale
camera.
_recordWithoutExecute
SCNRenderer.m
We should have an engine context at this stage
No C Scene associated with %@
Metal implementation not done
sceneTime
SpriteKit - Draw Overlay
SceneKit - Flush
SceneKit - Jitter
T@"SCNScene",&,N
delegate
T@"<SCNSceneRendererDelegate>",W,N
playing
TB,GisPlaying
autoenablesDefaultLighting
jitteringEnabled
TB,N,GisJitteringEnabled
temporalAntialiasingEnabled
TB,N,GisTemporalAntialiasingEnabled
overlaySKScene
T@"SKScene",&,N
renderingAPI
colorPixelFormat
depthPixelFormat
stencilPixelFormat
audioEngine
T@"AVAudioEngine",R,N
audioEnvironmentNode
T@"AVAudioEnvironmentNode",R,N
audioListener
currentViewport
usesReverseZ
T@"SCNTechnique",C,N
nextFrameTime
textureID
antialiasingMode
path
flatness
entityID
basic
keyframe
group
class
keyPath
animation-players
animation-keys
keyPathSrc
keyPathDst
bindings
.app/Contents/
imageNamed
imageNamed://
MDLSkyCubeTexture
turbidity
sunElevation
upperAtmosphereScattering
groundAlbedo
horizonElevation
gamma
exposure
brightness
channelEncoding
dimensions.x
dimensions.y
highDynamicRangeCompression.x
highDynamicRangeCompression.y
groundColor
Error: ranges and strings arrays must be of the same size
Error: ranges must be ordered
Error: incorrect ranges : cumulated size larger than the original string
SCNAnimationCommitOnCompletion
SCN_CAKeyframeAnimation %p (duration=%f, keyPath:%@)
c3dAnimation
commitsOnCompletion
removedOnCompletion
CAKeyframeAnimation based on CGPath are not supported
SCNAnimationAnimatesUsingSceneTimeKey
SCNAnimationFadeInDurationKey
SCNAnimationFadeOutDurationKey
SCNAnimationEventsKey
animationEvents
c3dTimingFunction
c3dAnimationType
applyOnCompletion
fillForward
fillBackward
userInfo
failed to archive animation's userinfo. %@ %@
appliedOnCompletion
scna
<SCNAnimation(%p) keyPath=%@ duration=%f repeatCount=%f>
T@"SCNTimingFunction",&,N
blendInDuration
blendOutDuration
TB,N,GisRemovedOnCompletion
TB,N,GisAppliedOnCompletion
startDelay
fillsForward
fillsBackward
animationDidStart
animationDidStop
TB,N,GisAdditive
TB,N,GisCumulative
blendFactor
weight
<SCNAnimationPlayer(%p) animation=%@>
T@"SCNAnimation",R,N,V_animation
q24@?0@"SCNAnimationEvent"8@"SCNAnimationEvent"16
geometryMemory
textureMemory
SCNSceneSourceUseModelIOToLoadDAEFiles
kSceneSourceCacheScenesByURLKey
kSceneSourceSceneIndexKey
kSceneSourceForceMorphNormals
SCNSceneSourceLoadTexturesInCPUMemory
kSceneSourcePreserveOriginalTopology
SCNDetailedErrorsKey
SCNConsistencyElementIDErrorKey
SCNConsistencyElementTypeErrorKey
SCNConsistencyLineNumberErrorKey
kSceneSourceFormat
SCNSceneSourceInputSource
SCNSceneExportDestinationURL
SCNSceneExportUTIKey
SCNSceneExportCompressGeometryElements
SCNSceneExportCompressMorphTargets
SCNSceneExportEmbedImages
SCNSceneExportEmbedReferences
SCNSceneExportPresentationTree
[SCNSceneSource scenesSourceWithURL:] nil URL
<%@: %p | URL='%@'>
The document "%@" could not be opened.
The document data could not be read.
Failed to retrieve scene from XPC service.
v32@?0f8i12^{__CFError=}16^B24
failed to unarchive data at %@ (%@)
failed to unarchive scene at %@ - unknown decoded object class (%@)
failed to unarchive scene at %@ (%@)
v36@?0f8q12@"NSError"20^B28
@16@?0^v8
T@"NSURL",R
T@"NSData",R
bplist
<%@: %p | scene=%@ sceneTime=%f pointOfView=%@>
renderer.%@
Jittering is not supported on SCNMetalLayer
syncTimeWithCoreAnimation
TB,N,V_syncTimeWithCoreAnimation
textureCoordinate is deprecated - use textureCoordinateWithMappingChannel instead
<%@: %p <%f,%f,%f> | geometryIndex=%d node=%@ bone=%@>
geometryIndex
faceIndex
localCoordinates
worldCoordinates
localNormal
worldNormal
boneNode
simdLocalCoordinates
simdWorldCoordinates
simdLocalNormal
simdWorldNormal
simdModelTransform
a_vertexColor
a_TexTangent
a_diffuseTexcoord
a_ambientTexcoord
a_specularTexcoord
a_emissionTexcoord
a_filterTexcoord
a_transparentTexcoord
a_normalTexcoord
a_lightmapTexcoord
u_nodeOpacity
u_skinningJointMatrices
u_materialShininess
u_ambientColor
u_ambientIntensity
u_ambientTexture
u_ambientTextureMatrix
u_diffuseColor
u_diffuseIntensity
u_diffuseTexture
u_diffuseTextureMatrix
u_specularColor
u_specularIntensity
u_specularTexture
u_specularTextureMatrix
u_emissionColor
u_emissionIntensity
u_emissionTexture
u_emissionTextureMatrix
u_multiplyColor
u_multiplyIntensity
u_multiplyTexture
u_multiplyTextureMatrix
u_transparency
u_transparentColor
u_transparentIntensity
u_transparentTexture
u_transparentTextureMatrix
u_normalTexture
u_normalIntensity
u_normalTextureMatrix
u_shininessTexture
u_shininessTextureMatrix
u_lightmapTexture
u_reflectiveColor
u_reflectiveIntensity
u_reflectiveTexture
u_reflectiveTextureMatrix
u_fresnel
u_ambientLightColor
u_shCoefficients
u_light%d_attenuation
u_light%d_spotAttenuation
u_light%d_color
u_light%d_position
u_light%d_direction
u_light%d_up
u_light%d_right
u_light%d_gobo
u_light%d_goboMatrix
u_light%d_goboIntensity
u_light%d_iesMatrix
u_light%d_iesTex
u_light%d_shadow
u_light%d_shadowMatrix
u_light%d_shadowRadius
u_light%d_shadowColor
u_zRange
u_orientationPreserved
textureProvider
T@"<SCNMaterialPropertyTextureProvider>",&,N
v16@?0@?<v@?@"<MTLComputeCommandEncoder>">8
v16@?0@?<v@?@"<MTLBlitCommandEncoder>">8
_layerRoot
_overlayLayerRoot
_lightRoot
_cameraRoot
_particlesRoot
_physicsFieldRoot
_pointsOfViewRoot
Perspective
Bottom
Left
Right
Front
Back
_authoringCamera%s
lightAuth
particlesAuth
kSCNFreeViewCameraName
cameraAuth
cameraFrustumAuth
cameraNearPlaneAuth
fieldAuth
SCNDebugLightTypeKey
SCNDebugLightSubTypeKey
lightInnerAuth
lightOuterAuth
lightArrowAuth
lightShadowAuth
lightSpotAuth
probeGeometry
lightProbeExtents
scn_probesphere_from_sh_vertex
scn_probesphere_from_sh_fragment
v40@?0@"<SCNBufferStream>"8@"SCNNode"16@"<SCNShadable>"24@"SCNRenderer"32
lightAreaAuth
disabled
oa:%f ia:%f s:%f e:%f
AuthEnvHash
sourceShape
authoringLayer
authoringOverlayLayer
manipulator
T@"SCNManipulator",R,N
displayMask
authoringCameraType
C3DFXOutline.plist
C3DFXOutlineRetina.plist
C3DFXAuthoring.plist
PickedObject.glsl
PROBE
RenderProbePass
ControllerAnimation
ControllerVariableMode
ControllerVariableOverLife
ControllerVariableOverDistance
ControllerVariableOverOtherProperty
ControllerVariableOrigin
ControllerVariableScale
ControllerVariableBias
C3DParticleSystem
<C3DParticleSystemRef>
InvLifeSpan
BirthTime
SortingIndices
Mass
TempData
EventIndex
C3DLibrarySubStorage
<C3DLibrarySubStorage>
C3DLibrary
<C3DLibrary>
kPrimitiveGenerateMappingCoordinates
kPrimitiveVertexTransformation
kPrimitiveWidthSegments
kPrimitiveHeightSegments
kPrimitiveLengthSegments
kPrimitiveChamferSegments
kPrimitiveRotationSegments
kPrimitiveCapSegments
kPrimitiveRingSegments
kPrimitivePipeSegments
kPrimitiveSphereType
kPrimitiveSphereSegments
kPrimitiveTypeSphere
kPrimitiveTypeGeosphere
widthSegmentCount
heightSegmentCount
lengthSegmentCount
chamferSegmentCount
segmentCount
radialSegmentCount
ringSegmentCount
pipeSegmentCount
-[SCNFloor setReflectionResolutionScaleFactor:]
-[SCNFloor setReflectionCategoryBitMask:]
-[SCNFloor setWidth:]
-[SCNFloor setLength:]
-[SCNFloor setReflectionFalloffEnd:]
reflectionFalloffEnd
-[SCNFloor setReflectionFalloffStart:]
reflectionFalloffStart
-[SCNFloor setReflectionSampleCount:]
-[SCNFloor setReflectivity:]
reflectionCategoryBitMask
reflectionResolutionScaleFactor
C3DFloor
<C3DFloor>
resolutionScaleFactor
reflectionBitMask
<%@: %p '%@'>
-[SCNCamera setName:]
-[SCNCamera setScreenSpaceAmbientOcclusionIntensity:]
-[SCNCamera setScreenSpaceAmbientOcclusionRadius:]
-[SCNCamera setScreenSpaceAmbientOcclusionBias:]
-[SCNCamera setScreenSpaceAmbientOcclusionDepthThreshold:]
-[SCNCamera setScreenSpaceAmbientOcclusionNormalThreshold:]
-[SCNCamera setScreenSpaceAmbientOcclusionSampleCount:]
-[SCNCamera setScreenSpaceAmbientOcclusionDownSample:]
-[SCNCamera setAutomaticallyAdjustsZRange:]
-[SCNCamera setAverageGray:]
-[SCNCamera setBloomBlurRadius:]
-[SCNCamera setBloomIntensity:]
-[SCNCamera setBloomThreshold:]
-[SCNCamera setBloomIterationCount:]
-[SCNCamera setBloomIterationSpread:]
-[SCNCamera setCategoryBitMask:]
-[SCNCamera setColorFringeStrength:]
-[SCNCamera setColorFringeIntensity:]
-[SCNCamera setContrast:]
-[SCNCamera setGrainIntensity:]
-[SCNCamera setGrainScale:]
-[SCNCamera setGrainIsColored:]
-[SCNCamera setGrainSlice:]
-[SCNCamera setGrainTexture:]
-[SCNCamera setWhiteBalanceTemperature:]
-[SCNCamera setWhiteBalanceTint:]
-[SCNCamera setExposureAdaptationBrighteningSpeedFactor:]
-[SCNCamera setExposureAdaptationDarkeningSpeedFactor:]
-[SCNCamera setExposureAdaptationDuration:]
-[SCNCamera setExposureAdaptationHistogramRangeHighProbability:]
-[SCNCamera setExposureAdaptationHistogramRangeLowProbability:]
-[SCNCamera setExposureAdaptationMode:]
-[SCNCamera setExposureOffset:]
-[SCNCamera setDofIntensity:]
-[SCNCamera setMaximumExposure:]
-[SCNCamera setMinimumExposure:]
-[SCNCamera setMotionBlurIntensity:]
-[SCNCamera setOrthographicScale:]
-[SCNCamera setSaturation:]
-[SCNCamera setUsesOrthographicProjection:]
-[SCNCamera setVignettingIntensity:]
-[SCNCamera setVignettingPower:]
-[SCNCamera setWantsExposureAdaptation:]
-[SCNCamera setWantsHDR:]
-[SCNCamera setWhitePoint:]
-[SCNCamera setXFov:]
-[SCNCamera setYFov:]
-[SCNCamera setZFar:]
-[SCNCamera setZNear:]
-[SCNCamera setLensShift:]
-[SCNCamera setFieldOfView:]
-[SCNCamera setSensorHeight:]
-[SCNCamera setFocalLength:]
-[SCNCamera setFStop:]
-[SCNCamera setApertureBladeCount:]
-[SCNCamera setFocalBlurSampleCount:]
-[SCNCamera setFocusDistance:]
-[SCNCamera setProjectionTransform:]
usesOrthographicProjection
automaticallyAdjustsZRange
projectionDirection
lensShiftX
lensShiftY
focalBlurSampleCount
exposureAdaptationMode
colorGrading
wantsHDR
wantsExposureAdaptation
focalBlurRadius
wantsDepthOfField
bloomIterationCount
glID
TI,N,VglID
TI,N,Vtarget
T^v,N,Vcontext
T{CGSize=dd},N,Vsize
invalid wrapS value: %d
invalid wrapT value: %d
SKScene
SKTexture
GLKTextureInfo
AVPlayer
-[SCNMaterialProperty setContentsTransform:]
<%@: %p | contents=%@>
<data %p>
imageArray
skscene
sktexture
attachment
isCommonProfileProperty
propertyType
customSlotName
sRGB
textureComponents
-[SCNGeometry setName:]
%@: %p '%@'
%@: %p
 | %d elements
<%@>
geometrySourceForSemantic is deprecated - use geometrySourcesForSemantic instead
-[SCNGeometry setBoundingBoxMin:max:]
materials[
q24@?0@8@16
-[SCNGeometry _shadableSetValue:forUndefinedKey:]
-[SCNGeometry setShaderModifiers:]
-[SCNGeometry copyShaderModifiersFrom:]
-[SCNGeometry setProgram:]
sourceChannels
failed to archive geometry's custom attributes. %@ %@
subdivisionLevel
wantsAdaptiveSubdivision
edgeCreasesSource
edgeCreasesElement
subdivisionSettings
tessellator
T@"SCNMaterial",&,N
geometrySources
geometryElementCount
T@"SCNGeometryTessellator",&,N
T@"SCNGeometryElement",&,N
T@"SCNGeometrySource",&,N
C3DFXGLSLProgramObject
<C3DFXGLSLProgramObject %p>
SCNErrorDomain
item
T@,&,N,Vitem
timestamp
Td,N,Vtimestamp
scnasset
.scnassets
SCNScene
catalogURL
T@"NSURL",R,N,V_catalogURL
v24@?0Q8r^{SmartPtr<__C3DArray *, C3D::detail::CFRetainFct, C3D::detail::CFReleaseFct>=^{__C3DArray}}16
C3DProgramHashCodeStore
<C3DProgramHashCodeStore %p>
inputMode
inputScale
inputBias
inputOrigin
inputProperty
T@"CAAnimation",&,N
T@"SCNNode",W,N
skeleton
baseGeometry
baseGeometryBindTransform
bones
compressedSkinData
boneWeights
boneIndices
baseGeometryBindTransform-%d
boneInverseBindTransforms
T@"SCNGeometrySource",R,N
preferredFrameRate
Tf,N
adaptativeFrameRate
%@ - Skinned
C3DSkinner
<C3DSkinner %p skeleton:%p jointCount:%d cpuReady:%d gpuReady:%d
  skin:%p skinnedMesh:%p calcMode:%d
  JointBbox[%d] {%f,%f,%f} {%f,%f,%f}
skeletonID
skinID
meshCreated
bboxDirty
skinnedMesh
verticesJointsMatrices[%d]
normalsJointsMatrices[%d]
 %f %f %f %f
C3DSkin
<C3DSkin %p name:%@ joint:%d weight:%d vertexCount:%d
  maxInf:%d morpher:%p
defaultShapeMatrix
inverseBindMatrix
jointsCount
maxInfluences
inverseBindMatrices
defaultShapeMatrix
baseMeshID
weightsCount
vertexWeightIndices
jointsForVertexWeights
vertexWeights
maxInfluencesPerVertex
influencingMorpher
vertexWeightIndices[%d]
vertexWeights[%d]
jointsForVertexWeights[%d]
C3DIONSZipFileArchiveHeaderOffset
C3DIONSZipFileArchiveCompressionType
C3DIONSZipFileArchiveCRC
C3DIONSZipFileArchiveCompressedLength
C3DIONSZipFileArchiveUncompressedLength
1.2.11
C3DSourceAccessor
<C3DSourceAccessor %lx>
componentsCountPerValue
count
<C3DGenericSource %lx>
listener
C3DGenericSource
Camera
autoSwitchToFreeCamera
allowsTranslation
flyModeVelocity
panSensitivity
truckSensitivity
rotationSensitivity
enableFreeCamera
freeCamera
view
T@"SCNView",N
cameraController
T@"SCNCameraController",R,N,V_cameraController
T@"<SCNCameraNavigationControllerDelegate>",N,V_delegate
stickyAxis
cameraTarget
gimbalLockMode
enableInertia
automaticCameraTarget
TB,N,V_enableFreeCamera
T@"SCNNode",R,N,V_freeViewCameraNode
T@"SCNView",N,V_view
TB,N,V_autoSwitchToFreeCamera
Td,N,V_flyModeVelocity
Td,N,V_panSensitivity
Td,N,V_truckSensitivity
Td,N,V_rotationSensitivity
C3DResourceCache
<C3DResourceCache 0x%lx>
C3DAnimationGroup
<C3DAnimationGroup %p animations:%@>
channels
targetPath
subAnimations
HDRFrameLuminancePass
FrameLuminance
scn_draw_fullscreen_triangle_VR_uv_vertex
scn_hdr_luminance_frag
normals
vehicle
wheelIndex
suspensionStiffness
suspensionCompression
suspensionDamping
maximumSuspensionTravel
frictionSlip
maximumSuspensionForce
connectionPosition
steeringAxis
axle
radius
suspensionRestLength
isFront
T{SCNVector3=fff}
T@,&,N,VsourceObject
T@"NSString",&,N,VkeyPathSrc
T@"NSString",&,N,VkeyPathDst
T@"NSDictionary",&,N,Voptions
DrawNodesPass
DrawNodeDefault
v40@?0q8q16q24q32
v24@?0d8f16f20
v28@?0f8f12f16f20f24
SSAOUpSamplePass
scn_ssao_upsampling
JitteringPass
pingPongTex
scn_jittering_color_attachment
scn_jittering_texture
scn_jittering_color_attachment_drawable
scn_jittering_texture_drawable
-[SCNPlane setCornerRadius:]
cornerRadius
-[SCNPlane setCornerSegmentCount:]
cornerSegmentCount
-[SCNPlane setHeight:]
-[SCNPlane setHeightSegmentCount:]
-[SCNPlane setPrimitiveType:]
-[SCNPlane setWidth:]
-[SCNPlane setWidthSegmentCount:]
<%@ | width=%.3f height=%.3f>
-[SCNBox setChamferRadius:]
chamferRadius
-[SCNBox setChamferSegmentCount:]
-[SCNBox setHeight:]
-[SCNBox setHeightSegmentCount:]
-[SCNBox setLength:]
-[SCNBox setLengthSegmentCount:]
-[SCNBox setPrimitiveType:]
-[SCNBox setWidth:]
-[SCNBox setWidthSegmentCount:]
<%@ | width=%.3f height=%.3f length=%.3f chamferRadius=%.3f>
boxwidth
boxheight
boxlength
boxchamferRadius
boxwidthSegmentCount
boxheightSegmentCount
boxlengthSegmentCount
boxchamferSegmentCount
boxprimitiveType
-[SCNPyramid setHeight:]
-[SCNPyramid setHeightSegmentCount:]
-[SCNPyramid setLength:]
-[SCNPyramid setLengthSegmentCount:]
-[SCNPyramid setPrimitiveType:]
-[SCNPyramid setWidth:]
-[SCNPyramid setWidthSegmentCount:]
<%@ | width=%.3f height=%.3f length=%.3f>
pyramidwidth
pyramidheight
pyramidlength
pyramidwidthSegmentCount
pyramidheightSegmentCount
pyramidlengthSegmentCount
pyramidprimitiveType
-[SCNSphere setGeodesic:]
-[SCNSphere setHemispheric:]
-[SCNSphere setPrimitiveType:]
-[SCNSphere setRadialSpan:]
radialSpan
-[SCNSphere setRadius:]
-[SCNSphere setSegmentCount:]
<%@ | radius=%.3f>
sphereradius
sphereradialSpan
spheresegmentCount
sphereprimitiveType
spheregeodesic
spherehemispheric
geodesic
TB,N,GisGeodesic
-[SCNCylinder setHeight:]
-[SCNCylinder setHeightSegmentCount:]
-[SCNCylinder setPrimitiveType:]
-[SCNCylinder setRadialSegmentCount:]
-[SCNCylinder setRadialSpan:]
-[SCNCylinder setRadius:]
<%@ | radius=%.3f height=%.3f>
cylinderradius
cylinderheight
cylinderradialSpan
cylinderheightSegmentCount
cylinderradialSegmentCount
cylinderprimitiveType
-[SCNCone setBottomRadius:]
bottomRadius
-[SCNCone setHeight:]
-[SCNCone setHeightSegmentCount:]
-[SCNCone setPrimitiveType:]
-[SCNCone setRadialSegmentCount:]
-[SCNCone setTopRadius:]
topRadius
<%@ | topRadius=%.3f bottomRadius=%.3f height=%.3f>
conetopRadius
conebottomRadius
coneheight
coneheightSegmentCount
coneradialSegmentCount
coneprimitiveType
-[SCNTube setHeight:]
-[SCNTube setHeightSegmentCount:]
-[SCNTube setInnerRadius:]
innerRadius
-[SCNTube setOuterRadius:]
outerRadius
-[SCNTube setPrimitiveType:]
-[SCNTube setRadialSegmentCount:]
-[SCNTube setRadialSpan:]
<%@ | innerRadius=%.3f outerRadius=%.3f height=%.3f>
tubeinnerRadius
tubeouterRadius
tubeheight
tuberadialSpan
tubeheightSegmentCount
tuberadialSegmentCount
tubeprimitiveType
-[SCNCapsule setCapRadius:]
capRadius
-[SCNCapsule setCapSegmentCount:]
capSegmentCount
-[SCNCapsule setHeight:]
-[SCNCapsule setHeightSegmentCount:]
-[SCNCapsule setPrimitiveType:]
-[SCNCapsule setRadialSegmentCount:]
<%@ | capRadius=%.3f height=%.3f>
capsulecapRadius
capsuleheight
capsuleheightSegmentCount
capsuleradialSegmentCount
capsulecapSegmentCount
capsuleprimitiveType
-[SCNTorus setPipeRadius:]
pipeRadius
-[SCNTorus setPipeSegmentCount:]
-[SCNTorus setPrimitiveType:]
-[SCNTorus setRadialSpan:]
-[SCNTorus setRingRadius:]
ringRadius
-[SCNTorus setRingSegmentCount:]
<%@ | ringRadius=%.3f pipeRadius=%.3f>
torusringRadius
toruspipeRadius
torusradialSpan
torusringSegmentCount
toruspipeSegmentCount
torusprimitiveType
compute_cube_from_equi_views
compute_cube_from_equi
compute_equi_from_cube
_C3DParametricGeometryCreateCacheHash_not_thread_safe
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Core/C3DParametricGeometry.c
size <= sizeof(C3DParametricGeometryType) + sizeof(C3DParametricGeometryParameters)
C3DParametricGeometry
Pyramid
Cylinder
Cone
Tube
Capsule
Torus
Sphere
Plane
<%@<%@>:%p "%@"
ScenePass
Normals
true
false
vec2(
vec3(
vec4(
C3DValue
<C3DValue %p - %@ ptr:%p >
value
C3DFXSampler
<C3DFXSampler>
preferredExtensions
/System
B24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}8^B16
nodeFromflattenedMesh
v16@?0@"NSTimer"8
T@"<SCNCameraControllerDelegate>",N,V_delegate
T@"SCNNode",&,N,V_pointOfView
interactionMode
Tq,N,V_interactionMode
automaticTarget
TB,N,V_automaticTarget
inertiaEnabled
inertiaFriction
inertiaRunning
TB,R,N,GisInertiaRunning
minimumVerticalAngle
maximumVerticalAngle
minimumHorizontalAngle
maximumHorizontalAngle
drivenByDefaultNavigationCameraController
simdUp
simdTarget
verticalMaximumAngle
horizontalMaximumAngle
0.10
0.11
kEnclosingFolderURL
kSceneSourceInputLibrary
kC3DIOSerializationExportDelegate
kCreatePropertyListShouldZipOption
kCreatePropertyListShouldKeepReferencesToFilesOption
readerMinimumRequiredVersion
Could not get the data for the serialized property list
Could not zip the serialized property list
zippedData
zipped
%.1f %.1f %.1f
meter
unnamed animation #%d
kIDKey
kNameKey
entity-name
entity-ID
_kvc
C3DEntity
<C3DEntity:%p>
CIFilterPass
CIFilterDrawNodesPass
C3DEngineNotificationQueue
<C3DEngineNotificationQueue %p>
Cube
Equirectangular
DualParaboloid
PreFiltered Radiance
scn_draw_fullscreen_cube_layered
scn_draw_fullscreen_cube
scn_draw_fullscreen_cube_no_base
cube
equi
dual
compute_specularPreIntegratedLD_var_texturecube_half
compute_specularPreIntegratedLD_var_texturecube_float
compute_specularPreIntegratedLD_var_texture2d
compute_specularPreIntegratedLD_equirectangular_half
compute_specularPreIntegratedLD_equirectangular_float
compute_specularPreIntegratedLD_dual_paraboloid_half
compute_specularPreIntegratedLD_dual_paraboloid_float
ComputeRadiancePass
v28@?0f8r^{Triangle=}12r^20
B20@?0^8I16
C3DConstraintSlider
<C3DConstraintAcceleration>
C3DConstraintAvoidOccluder
<C3DConstraintAvoidOccluder %p>
SSRRaytracePass
SSREnableFog
scn_ssr_raytrace_vert
scn_ssr_raytrace_frag
C3DDynamicBatchingSystem
<C3DDynamicBatchingSystem %p>
root_node
/System/Library/PrivateFrameworks/USDKit.framework/USDKit
../SharedFrameworks/USDKit.framework/USDKit
USKObjectPath
USKToken
USKData
USKScene
USKDataTypeResourcePath
USKDataTypeInt
USKDataTypeBool
USKDataTypeDouble3
USKDataTypeDouble4x4
USKDataTypeDouble4x4Array
USKDataTypeFloat
USKDataTypeFloat2
USKDataTypeFloat3
USKDataTypeFloat4
USKDataTypeFloat2Array
USKDataTypeFloat3Array
USKDataTypeFloatArray
USKDataTypeIntArray
USKDataTypeObjectPath
USKDataTypeObjectPathArray
USKDataTypeQuatf
USKDataTypeQuatfArray
USKDataTypeStringArray
USKDataTypeToken
USKDataTypeTokenArray
USKNodeTypeCamera
USKNodeTypeMaterial
USKNodeTypeMesh
USKNodeTypeMeshGroup
USKNodeTypeScope
USKNodeTypeShader
USKNodeTypeSkeletalAnimation
USKNodeTypeSkeleton
USKNodeTypeSkeletonRoot
USKNodeTypeBlendShape
USKNodeTypeTransform
USKRoleTypeColor
USKRoleTypeNone
USKRoleTypeNormal
USKRoleTypePoint
USKRoleTypeVector
USKRoleTypeTextureCoordinate
USKSchemaTypeBindingAPI
[^A-Za-z0-9]
SceneKit export preview %.02f
customLayerData
creator
assetInfo
kind
defaultPrim
metersPerUnit
startTimeCode
endTimeCode
timeCodesPerSecond
Node_
Skeleton
restTransforms
bindTransforms
skel:skeleton
subdivisionScheme
faceVertexCounts
interpolation
faceVarying
extent
material:binding
_meshGroup
elementType
face
familyName
materialBind
indices
primvars:normals
primvars:st
primvars:displayColor
faceVertexIndices
primvars:normals:indices
primvars:st:indices
primvars:displayColor:indices
Material_
surfaceShader
info:id
UsdPreviewSurface
outputs:surface
emissiveColor
occlusion
Materials
textures
texgen_%lu.png
texgen_%lu
@"NSString"24@?0@"NSString"8@?<B@?@"NSString">16
UTTypeTagSpecification
public.filename-extension
B16@?0@"NSString"8
public.png
inputs:
_texCoordReader
UsdPrimvarReader_float2
outputs:result
inputs:varname
inputs:frame:stPrimvarName
_transform2D
sdrMetadata
role
math
UsdTransform2d
inputs:in
inputs:rotation
inputs:scale
inputs:translation
_texture
UsdUVTexture
inputs:bias
inputs:file
inputs:st
inputs:wrapS
inputs:wrapT
outputs:
mirror
blendShape
BlendShape
pointIndices
skel:blendShapes
skel:blendShapeTargets
offsets
normalOffsets
orthographic
perspective
projection
horizontalAperture
verticalAperture
clippingRange
xformOp:transform
xformOp:translate
xformOp:orient
rotation.euler
xformOp:rotate
xformOp:rotateXYZ
xformOp:scale
xformOp:rotateX
xformOp:rotateY
xformOp:rotateZ
xformOpOrder
Geom
blendShapeWeights
Animations
skel:animationSource
blendShapes
primvars:skel:jointWeights
primvars:skel:jointIndices
primvars:skel:geomBindTransform
translations
rotations
scales
MBTileMaxPass
scn_motionblur_tilemax
SCNPreferredRenderingAPIKey
SCNPreferredDeviceKey
SCNPreferLowPowerDeviceKey
PrefersOpenGL
GdXjx1ixZYvN9Gg8iSf68A
ARSCNView
ibPreferredRenderingAPI
ibWantsMultisampling
allowsCameraControl
backgroundColor
ibSceneName
background.contents
kSCNViewObservingContext
com.apple.sceneKit.forceSeparateWorkGroup
SceneKit - SCNView Draw
<%@: %p | scene=%@ sceneTime=%f frame=%@ pointOfView=%@>
SKNode
rendersContinuously
cameraControlConfiguration
T@"<SCNCameraControlConfiguration>",R,N
defaultCameraController
T@"SCNCameraController",R,N
eaglContext
T@"EAGLContext",&,N
SceneKit-spotShadowDepth-%p
SceneKit-spotShadowDepth
C3DFXDeferredShadowPass.json
C3DFXForwardShadowPass.json
SceneKit_renderSceneFromLight
SceneKit_applyDeferredShadows
lightDepthSampler
C3D-spotShadow
#define TARGET_OS_IPHONE 1
#define MAX_SAMPLE %d
#define unshareIndex %d
#define SPOT_SHADOW 1
#define USE_PCF 1
C3D-u_lightPos-symbol
C3D-u_lightDir-symbol
C3D-u_lightSpotAtt-symbol
C3D-light_MVP-symbol
C3D-cascadeScale-symbol
C3D-cascadeBias-symbol
C3D-shadowCascadeDebugFactor-symbol
C3D-camera_MVP_i-symbol
C3D-shadowRadius-symbol
C3D-shadowColor-symbol
C3D-shadowKernel-symbol
C3DMorph
<C3DMorph %p "%@"
  calc:%d morphNrm:%d targets:%ld
[%ld] weight:%f %@
morphingType
weightsID
targetIDs
weightsData
<unnamed %d>
C3DMorpher
<C3DMorpher %p baseGeom:%p morphedMesh:%p state:%d
  morph:%@
morphID
C3DFXContext
<C3DFXContext>
%d - %@
 (resolve)
 (%dx)
NoName
ConvertCubePass-%sTo%s
scn_convert_%s_from_%s_frag
commonprofile_frag
commonprofile_vert
standard_frag
standard_vert
standard_post_tessellation_vert
USE_%@
USE_%@_COLOR
USE_%@_INTENSITY
USE_%@_TEXTURE_COMPONENT
USE_%@TEXCOORD
USE_%@_MAP
USE_%@_CUBEMAP
Error creating the xml writer
utf-8
Error at xmlTextWriterStartDocument
COLLADA
xmlns
http://www.collada.org/2005/11/COLLADASchema
1.4.1
Error at xmlTextWriterEndDocument
asset
contributor
SceneKit Collada Exporter v1.0
Y_UP
Z_UP
X_UP
yyyy-MM-dd'T'HH:mm:ss'Z'
library_animations
library_animation_clips
effect_
%@%d
(%ld)
can't mix euler and axisangle rotations
transform animation not supported
_copyComponentForColor4Address
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DIO/collada/C3DIOColladaExport.c
offset<4
_copyComponentForMatrixAddress
offset<16
(%zd)(%zd)
_copyComponentForVector3Address
offset<3
_copyComponentForVector4Address
float_array
int_array
Name_array
%s-array
_writeArrayWithWriterFunc
ccpv == 1
_writeArrayWithWriterFunc: unknown array type
technique_common
#%s-array
TIME
ANGLE
TRANSFORM
INTERPOLATION
_writeAccessor
cpv <= sizeof(XYZWNames) / sizeof(char*)
cpv <= sizeof(RGBANames) / sizeof(char*)
cpv <= sizeof(STPQNames) / sizeof(char*)
cpv <= 1
param
LINEAR
STEP
HERMITE
input
INPUT
OUTPUT
IN_TANGENT
OUT_TANGENT
_writeKeyframeAnimation: can't resolve animation path (root)
_writeKeyframeAnimation: can't resolve animation path
channel
%s/%s%s
SID_%d
animation_clip
start
instance_animation
library_cameras
optics
xmag
library_lights
%g %g %g
constant_attenuation
linear_attenuation
quadratic_attenuation
falloff_angle
falloff_exponent
extra
shadow
enable
%g %g %g %g
spotParameters
outerAngle
innerAngle
probeParameters
tmpProbe
library_images
init_from
./no-path-found
library_materials
instance_effect
#effect_%s
library_effects
effect_%s
profile_COMMON
common
index_of_refraction
constant_ambient
constant_diffuse
bump
extendedLightingModel
double_sided
invertCulling
ambient_diffuse_lock
intensities
newparam
%s_%s
surface
CUBE
CLAMP
WRAP
BORDER
MIRROR
wrap_s
wrap_t
NONE
NEAREST
minfilter
magfilter
mipfilter
opaque
CHANNEL%d
library_geometries
vertices
%s-vertices
POSITION
NORMAL
TEXCOORD
tristrips
VERTEX
TEXTANGENT
JOINT
WEIGHT
#%s-vertices
%ld 
library_controllers
controller
method
NORMALIZED
RELATIVE
%s-targets
IDREF_array
%s-targets-array
#%s-targets-array
MORPH_TARGET
IDREF
#%s-targets
MORPH_WEIGHT
bind_shape_matrix
INV_BIND_MATRIX
vertex_weights
vcount
%d %ld 
%.7g 
library_visual_scenes
visual_scene
instance_visual_scene
instance_camera
instance_light
user_properties
lightmap_path=%s
uv_set=%d
visibility
translate
rotate
0 0 1 %g
0 1 0 %g
1 0 0 %g
instance_controller
instance_geometry
bind_material
instance_material
symbol
bind_vertex_input
input_semantic
input_set
C3D-DefaultProgram
C3DFXGLSLProgram
<C3DFXGLSLProgram %p>
vertexShader
fragmentShader
attributeNamesToIndexes
uniformNamesToIndexes
#extension
C3DRendererDelegate
<C3DRendererDelegate %p>
CustomPass
USE_SPECULAR
USE_VIEW
USE_SHININESS
SCNShaderLightDecl.glsl
float __shadow2DProj(sampler2DShadow tex, vec4 coord) {return shadow2DProjEXT( tex, coord );}
uniform vec4 u_shadowKernel[%d];
USE_FOG
USE_POSITION
USE_FRESNEL
USE_NORMAL
AVOID_OVERLIGHTING
USE_AMBIENT_LIGHTING
USE_LIGHTING
USE_PER_PIXEL_LIGHTING
USE_MODULATE
USE_PER_VERTEX_LIGHTING
USE_VERTEX_COLOR
SCNShaderSurfaceDecl.glsl
USE_AMBIENT_AS_AMBIENTOCCLUSION
USE_EMISSION_AS_SELFILLUMINATION
USE_TANGENT
USE_BITANGENT
    vec2 %@Texcoord;
    _surface.%@Texcoord = v_texcoord%d;
USE_DISCARD
} _surface;
varying vec2 v_texcoord%d;
uniform mat4 u_%@TextureMatrix;
v_texcoord%d = (u_%@TextureMatrix * vec4(_geometry.texcoords[%d], 0., 1.)).xy;
v_texcoord%d = _geometry.texcoords[%d];
NEED_IN_TEXCOORD%d
USE_TEXCOORD
#extension GL_EXT_shadow_samplers : require
C3D-UberShader.vsh
SCNShaderGeometryDecl.glsl
struct SCNShaderLightingContribution {vec3 ambient; vec3 diffuse; vec3 specular; vec3 modulate;} _lightingContribution;
SEPARATE_PROJECTION
__DoTexcoord__
#define kSCNTexcoordCount %ld
USE_SKINNING
MAX_BONE_INFLUENCES
USE_GEOMETRY_MODIFIER
__DoGeometryModifier__
__DoLighting__
#extension GL_OES_standard_derivatives : enable
C3D-UberShader.fsh
USE_SURFACE_MODIFIER
__DoSurfaceModifier__
USE_FRAGMENT_MODIFIER
__DoFragmentModifier__
LOCK_AMBIENT_WITH_DIFFUSE
USE_DOUBLE_SIDED
USE_NODE_OPACITY
DIFFUSE_PREMULTIPLIED
USE_TRANSPARENCY_RGBZERO
u_light%hu
    SCNShaderLight _light;
    _light.intensity = vec4(1.);
uniform vec4 %@_color;
    _light.intensity = %@_color;
uniform vec4 %@_direction;
    _light.direction = %@_direction.xyz;
uniform vec4 %@_position;
    vec3 _D = %@_position.xyz - _surface.position;
    _light.dist = length(_D);
    _light.direction = _D / _light.dist;
    _light.direction = normalize(%@_position.xyz - _surface.position);
    _light.dir = %@_direction.xyz;
//Unsupported
    _light._att = 1.;
uniform vec4 %@_attenuation;
    vec3 _att = %@_attenuation.xyz;
    _light._att *= step(_light.dist, _att.x);
    _light._att *= clamp(_light.dist * _att.x + _att.y, 0.0, 1.0);
    float _dstatt = clamp(_light.dist * _att.x + _att.y, 0.0, 1.0);
    _light._att *= (_dstatt  * _dstatt);
    _light._att *= pow(clamp(_light.dist * _att.x + _att.y, 0.0, 1.0), _att.z);
uniform vec4 %@_spotAttenuation;
    vec3 _spot = %@_spotAttenuation.xyz;
    _light._att *= step(_spot.x, dot(_light.direction, _light.dir));
    _light._att *= clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0);
    float _sptatt = clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0);
    _light._att *= _sptatt * _sptatt;
    _light._att *= pow(clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0), _spot.z);
uniform sampler2DShadow %@_shadow;
uniform mat4 %@_shadowMatrix;
uniform float %@_shadowRadius;
    float _shadowingTerm = 0.0;
    vec4 _lightScreen = (%@_shadowMatrix * vec4(_surface.position, 1.));
    float _filteringSizeFactor = %@_shadowRadius * _lightScreen.w;
    for(int i=0; i < %d; i++){
        _shadowingTerm += __shadow2DProj(%@_shadow, _lightScreen + (u_shadowKernel[i] * _filteringSizeFactor));
    }
    _shadowingTerm /= float(%d);
    float _shadowingTerm = __shadow2DProj(%@_shadow, (%@_shadowMatrix * vec4(_surface.position, 1.)));
uniform vec4 %@_shadowColor;
    _light._att *= (1. - _shadowingTerm * %@_shadowColor.a);
    _light._att *= (1. - _shadowingTerm);
uniform sampler2D %@_gobo;
uniform mat4 %@_goboMatrix;
uniform float %@_goboIntensity;
    _light.intensity *= mix(vec4(1.), texture2DProj(%@_gobo, (%@_goboMatrix * vec4(_surface.position, 1.))), %@_goboIntensity);
    _light.intensity *= %@_goboIntensity * texture2DProj(%@_gobo, (%@_goboMatrix * vec4(_surface.position, 1.)));
    _lightingContribution.modulate *= _light._att * _light.intensity.rgb;
    _light.intensity.rgb *= _light._att * max(0.0, dot(_surface.normal, _light.direction));
    _lightingContribution.diffuse += _light.intensity.rgb;
    vec3 _R = reflect(-_light.direction, _surface.normal);
    _lightingContribution.specular += pow(max(0.0, dot(_R, _surface.view)), _surface.shininess) * _light.intensity.rgb;
    vec3 _halfVector = normalize(_light.direction + _surface.view);
    _lightingContribution.specular += pow(max(0.0, dot(_surface.normal, _halfVector)), _surface.shininess) * _light.intensity.rgb;
  vec4 %@;
uniform %@ %@;
C3DFXDOFPass_deprecated.plist
SceneKit_downSample4x
SceneKit_DOF_blurCoc_H
SceneKit_DOF_blurCoc_V
SceneKit_blurColor4x_H
SceneKit_blurColor4x_V
C3D-dof-lerpBias
C3D-dof-lerpScale
C3D-dof-cocScaleBias
C3D-dof-invertPixelSize
SceneKit: C3DProgressDebugger fractionCompleted > 1.0
fractionCompleted
vertexBuffer.
osdIndicesBuffer
osdTessellationLevel
osdVertexBuffer
osdFaceVaryingData
osdFaceVaryingIndices
osdFaceVaryingPatchParams
osdFaceVaryingPatchArray
osdFaceVaryingChannelCount
osdFaceVaryingChannelDescriptors
osdFaceVaryingPatchArrayIndex
osdFaceVaryingChannelsPackedData
vertexBuffer
patchParamBuffer
perPatchVertexBuffer
patchTessBuffer
scn_node
scn_nodeInstances
scn_lights_layered
scn_frame
scn_frames
C3DNotificationCenter
<C3DNotificationCenter %p>
-[SCNMorpher setName:]
<SCNMorpher %p>
weights[%d]
-[SCNMorpher setWeight:forTargetAtIndex:]
-[SCNMorpher setCalculationMode:]
v32@?0^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}8^{__C3DMeshSource=}16^{__C3DMeshSource=}24
weights[
-[SCNMorpher setValue:forUndefinedKey:]
weightID
useSparseTargets
inBetweenCounts
inBetweenInfluenceWeights
shouldMorphNormals
channelTargetCounts
channelTargetWeights
T@"NSArray",&,N
unifiesNormals
com.apple.scenekit.programHashCodeQueue
C3DProgramHashCode
<C3DProgramHashCode %p : 
SM_Mat,
SM_Geo,
SM(%@),
Aone,
Acst,
opq,
tgt,
lgh,
amb,
prob,
fog,
dynB,
pntR,
Constant
Lambert
Phong
Blinn
ShadowOnly
[%@:
PerPix|
Double|
OverLght|
WrNrm|
Nrmliz|
WriteDepth|
LinDepth|
LockAmb|
TrspA
TrspRGB
TrspSL
TrspDL
[Node:
skn(%d)|
LightMap|
VrtCol|
Tess|
PNTriangles|
Phong|
OSD|
SingleCrease|
ScreenSpace|
PrimvarData=%d|
AmbientOcclusion
SelfIllumination
Tex|
rgb0|
rgb1|
flt0|
texA|
int|
comp|
mat|
(1D)
(2D)
(3D)
(Cube)
[Lighting:
Soft(%d)
bbox %p - min:[%f %f %f] max:[%f %f %f]
T{SCNVector3=fff},N,Vmin
T{SCNVector3=fff},N,Vmax
bsphere %p - center:[%f %f %f] radius:%f
center
T{SCNVector3=fff},N,Vcenter
Td,N,Vradius
_actions
_mycaction->_animIndex
SCNUITreeDidChange
SCN_isBackingUIView
uiView
T@"UIView",&,N,V_uiView
uiWindow
T@"UIWindow",&,N,V_uiWindow
uiWindowLayer
T@"CALayer",&,N,V_uiWindowLayer
T@,&,N,V_source
TB,N,V_isOpaque
_lastRatio
_posTarget.x
_posTarget.y
_posTarget.z
_posTargetReversed.x
_posTargetReversed.y
_posTargetReversed.z
_posStart.x
_posStart.y
_posStart.z
_isReversed
BoxBlurPass
box_blur_frag_%d
copy_frag
C3DParticleModifier
<C3DParticleModifierRef>
C3DTransaction
<C3DTransaction>
UITrackingRunLoopMode
com.apple.scenekit.main-thread-implicit-transaction-flush
animationTimingFunction not implemented for Javascript
animationDuration
animationTimingFunction
T@"CAMediaTimingFunction",C,N
disableActions
completionBlock
kGeometrySourceSemanticTangent
kGeometrySourceSemanticVertexCrease
kGeometrySourceSemanticEdgeCrease
kGeometrySourceSemanticBoneWeights
kGeometrySourceSemanticBoneIndices
<%@: %p | semantic=%@ vectors=%d %@x%d>
_geometrySourceWithSource - Conversion failed
cdata
vectorCount
floatComponents
bytesPerComponent
componentType
componentsPerVector
dataOffset
dataStride
colorSpace
Geometry source has invalid bounds
mutableData
T@"NSMutableData",R,N
<%@: %p | %u x %@, %u channels, %@ indices>
compressedElementData
elementData
primitiveRangeLocation
primitiveRangeLength
indicesChannelCount
interleavedIndicesChannels
ptSize
minimumPointScreenSpaceRadius
maximumPointScreenSpaceRadius
pointSize
primitiveRange
T{_NSRange=QQ},N
triangle
triangle strip
line
polygon
renderingAlgorithm
sourceMode
pointSourceInHeadMode
obstruction
T{AVAudio3DPoint=fff},N
C3D-wireframe
ManipulatorWireframe_vert
ManipulatorWireframe_frag
SceneKit - Draw Statistics
Draw Statistics
v32@?0^q8^{CGSize=dd}16^^{?}24
v24@?0{CGSize=dd}8
Physics
Constraints
Particles
Delegate
Rendering
GL flush
--- ms
%2.1f s
%2.1f ms
$3$%@ $4$%@
Mt %dfps
GL %dfps
sceneRenderer
T@"<SCNSceneRenderer>",R
selectedNodes
selectionIsReadonly
shouldSnapOnGrid
TB,N,V_shouldSnapOnGrid
shouldSnapToAlign
TB,N,V_shouldSnapToAlign
graphicalSelectionEnabled
TB,N,V_graphicalSelectionEnabled
surroundToSelect
TB,N,V_surroundToSelect
authoringDisplayMask
gridUnit
Td,R,N,V_gridUnit
editingSpace
Tq,N,V_editingSpace
T@"<SCNAuthoringEnvironmentDelegate>",N,V_delegate
AuthEnvDraw
u_sampler
C3DManipulatorColorAndTexture
C3DManipulatorColorOnly
C3DManipulatorLightProbe
ManipulatorColorAndTexture_vert
ManipulatorColorAndTexture_frag
ManipulatorColorOnly_vert
ManipulatorColorOnly_frag
ManipulatorLightProbe_vert
ManipulatorLightProbe_frag
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
Menlo
%2.1fms
Menlo-Bold
%.3gK
%.3gM
%.3gG
T@"SCNView",R
setGimbalLockVector is deprecated
gimbalLockVector
scn_generate_grain
_axisRot
_rotX
_rotY
_rotZ
_lastRotX
_lastRotY
_lastRotZ
_isAxisAngle
_isUnitArc
_qRot
C3D-Standard.metal
#import "scn_util.h"
#import "scn_standard_lighting.h"
#import "scn_standard_constants.h"
#import "C3D-PBR.metal"
__ExtraVaryingsDecl__
__ShaderModifiersDecl__
__VertexExtraArguments__
__VertexExtraArgumentsPostTessellation__
__DoGeometryModifierPostTessellation__
__FragmentExtraArguments__
C3D-Lighting.metal
__SurfaceExtraDecl__
__LightModifierExtraDecl__
__DoLightModifier__
C3D-CommonProfile.metal
#import "scn_tessellation.h"
__TexcoordDecl__
#import "C3D-Lighting.metal"
__OpenSubdivDeclPerGeometry__
__OpenSubdivDeclPerPatchType__
__OpenSubdivDeclShared__
__VertexDoVertexOnlyTexcoord__
__VertexDoLighting__
__VertexDoTexcoord__
__FragmentDoTexcoord__
__LightModifierCopyDecl__
__FragmentDoLighting__
%@ %@;
, device %@ %@
, constant %@& %@
, %@ %@
, %@<float> %@
_lightingContribution.%@=%@;
%@<float> %@;
v32@?0@"NSString"8@"NSString"16^B24
%@%@%@
C3D-OpenSubdiv-Utils.h
C3D-OpenSubdiv-Utils.metal
scn_util.h
scn_standard_lighting.h
scn_standard_constants.h
C3D-PBR.metal
USE_VERTEX_EXTRA_ARGUMENTS
USE_FRAGMENT_EXTRA_ARGUMENTS
USE_SHADER_MODIFIERS
METAL
////////////////////////////////////////////////
// CommonProfile Shader v%d
USE_MULTIPLE_RENDERING
USE_LAYERED_RENDERING
USE_MULTIPLE_VIEWPORTS_RENDERING
USE_PBR
USE_SHADOWONLY
C3DLightIndexType
C3D_USE_TEXTURE_FOR_LIGHT_INDICES
C3D_SUPPORT_CUBE_ARRAY
C3D_USE_REFLECTION_PROBES
SCNLightingModelCustom
LIGHTING_MODEL
USE_CLUSTERED_LIGHTING
USE_SSAO
USE_PROBES_LIGHTING
HAS_NORMAL
HAS_VERTEX_COLOR
USE_INSTANCING
USE_POINT_RENDERING
DISABLE_LINEAR_RENDERING
DISABLE_SPECULAR
USE_MOTIONBLUR
USE_COLOR1_OUTPUT
USE_NORMALS_OUTPUT
USE_REFLECTANCE_ROUGHNESS_OUTPUT
USE_RADIANCE_OUTPUT
USE_OUTLINE
USE_MODELTRANSFORM
USE_TRANSPARENT
    float2 %@Texcoord;
    _surface.%@Texcoord = in.texcoord%d;
USE_MODELVIEWTRANSFORM
USE_MODELVIEWPROJECTIONTRANSFORM
USE_SURFACE_EXTRA_DECL
USE_EXTRA_VARYINGS
USE_TESSELLATION
scn_tessellation.h
TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE
TESSELLATION_SMOOTHING_MODE_PHONG
#import
%@%@
%@%@
#if 1 // SHADER_COLLECTION_PREFERS_MONOLITHIC_FILES
#else // SHADER_COLLECTION_PREFERS_MONOLITHIC_FILES
#endif // SHADER_COLLECTION_PREFERS_MONOLITHIC_FILES
#generate "__OpenSubdivDeclShared__.metal"
#generate "__OpenSubdivDeclShared__patchType%d.metal"
USE_REVERSE_Z
DEBUG_PIXEL
_import/%@
#import "%@"
#generate
-[SCNCommonProfileProgramGeneratorMetal collectShaderForProgram:newVertexFunctionName:newFragmentFunctionName:sourceCodeBlock:additionalFileBlock:]
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/NewRenderer/SCNCommonProfileProgramGeneratorMetal.m
USE_LIGHT_MODIFIER
scn_node.
USE_
v32@?0@"NSString"8@16^B24
, depthcube<float> u_shadowTexture%d
, depth2d_array<float> u_shadowTexture%d
, depth2d<float> u_shadowTexture%d
, texture2d<half> u_goboTexture%d
, sampler u_goboTexture%dSampler
, texture2d<half> u_iesTexture%d
, device packed_float2* u_areaPolygonPositions%d
_lightingContribution.add_directional(scn_lights[%d], u_goboTexture%d, u_goboTexture%dSampler, %s);
_lightingContribution.add_directional(scn_lights[%d], u_shadowTexture%d, %d, %s, u_shadowKernel, %d, %s);
_lightingContribution.add_directional(scn_lights[%d], u_shadowTexture%d, %d);
_lightingContribution.add_directional(scn_lights[%d], u_shadowTexture%d, u_shadowKernel, %d);
_lightingContribution.add_directional(scn_lights[%d], u_shadowTexture%d);
_lightingContribution.add_directional(scn_lights[%d]);
_lightingContribution.add_omni(scn_lights[%d], u_shadowTexture%d, u_shadowKernel, %d);
_lightingContribution.add_omni(scn_lights[%d]);
_lightingContribution.add_spot(scn_lights[%d], u_goboTexture%d, u_goboTexture%dSampler, %s);
_lightingContribution.add_spot(scn_lights[%d], u_shadowTexture%d, u_shadowKernel, %d);
_lightingContribution.add_spot(scn_lights[%d]);
_lightingContribution.add_ies(scn_lights[%d], u_iesTexture%d, u_shadowTexture%d, u_shadowKernel, %d);
_lightingContribution.add_ies(scn_lights[%d], u_iesTexture%d);
_lightingContribution.add_area_rectangle(scn_lights[%d], u_areaLightBakedDataTexture);
_lightingContribution.add_area_polygon(scn_lights[%d], u_areaLightBakedDataTexture, u_areaPolygonPositions%d);
_lightingContribution.add_area_line(scn_lights[%d], u_areaLightBakedDataTexture);
_lightingContribution.add_area_ellipse(scn_lights[%d], u_areaLightBakedDataTexture);
_lightingContribution.add_area_ellipsoid(scn_lights[%d], u_areaLightBakedDataTexture);
float2 _%@Texcoord = (scn_commonprofile.textureTransforms[%d] * float4(_geometry.texcoords[%d], 0., 1.)).xy;
float2 _%@Texcoord = _geometry.texcoords[%d].xy;
float2 texcoord%d;
out.texcoord%d = (scn_commonprofile.textureTransforms[%d] * float4(_geometry.texcoords[%d], 0., 1.)).xy;
out.texcoord%d = _geometry.texcoords[%d].xy;
TEXTURE_TRANSFORM_COUNT
kSCNTexcoordCount
NEED_IN_TEXCOORD0
NEED_IN_TEXCOORD1
NEED_IN_TEXCOORD2
NEED_IN_TEXCOORD3
NEED_IN_TEXCOORD4
NEED_IN_TEXCOORD5
NEED_IN_TEXCOORD6
NEED_IN_TEXCOORD7
http
SCNLayerTreeDidChange
kCARendererFlags
kCARendererColorSpace
kCARendererMetalCommandQueue
T@,&,N,V_delegate
kExportPointOfViewAttribute
SCNExportSceneIdentifier
SCNExportMovieMirrored
SCNExportMovieSupersamplingFactor
SCNExportMovieFrameRate
SCNExportOperation : error not implemented
T@,N,V_delegate
T^v,N,V_userInfo
didEndSelector
T:,N,V_didEndSelector
T@"SCNScene",&,N,V_scene
T{CGSize=dd},N,V_size
Td,N,V_startTime
Td,N,V_endTime
progress
Td,N,V_progress
canceled
TB,N,V_canceled
succeded
TB,N,V_succeded
T@"NSDictionary",&,N,V_attributes
outputURL
T@"NSURL",&,N,V_outputURL
T@"NSError",&,N,V_error
TQ,N,V_antialiasingMode
renderer
T@"SCNRenderer",&,N,V_renderer
QTAddImageCodecType
QTMovieRateAttribute
SCNExport.m
SceneKit: Couldn't create pixel buffer
serial assetwriter input queue
DOFBlurCoCYPass
dof_coc_blurH
C3DAvoidOccluderConstraintDelegate
<C3DAvoidOccluderConstraintDelegate %p>
CompositePass
enableAR
scn_draw_fullscreen_triangle_VR_uv_uvNorm_vertex
scn_postprocess
minLinearLimit
maxLinearLimit
minAngularLimit
maxAngularLimit
motorTargetLinearVelocity
motorMaximumForce
motorTargetAngularVelocity
motorMaximumTorque
minimumLinearLimit
maximumLinearLimit
minimumAngularLimit
maximumAngularLimit
C3DGlyphCreate
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Primitives/Text/C3DGlyph.c
shapeParams.cgPath == NULL
C3DGlyph
<C3DGlyph '%@' in '%@'>
Tq,N,Vtype
next
T@"SCNNodeComponent",&,N,Vnext
T@,W,N,Vcomponent
C3DTextFrame
<C3DTextFrame>
C3DRasterizerStates
<C3DRasterizerStates %p> ZRead:%d ZWrite:%d ZFunc:%d cull:%d fill:%d
SSRDepthBackFacePass
--SSRBackFaceMaterial--
HDRAverageLuminancePass
fixed_lum
sliding_lum
adaptative_lum
SSAOBlurPass-Y
SSAOBlurPass-X
scn_ssao_blur_y
scn_ssao_blur_x
B24@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}8^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}16
v24@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}8^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}16
v24@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}8i16i20
C3DAppendPointToPath
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Primitives/Text/C3DShapeUtils.c
origin != C3DShapeVertexOriginCurveStart
C3DTextLine
<C3DTextLine>
astc
GenerateMipmapPass
_scaleTarget
_scaleTargetReversed
_deltaScale
C3DTransformTree
<C3DTransformTree %p>
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Primitives/Text/C3DShapeTriangulation.c
C3DShapeTriangulationTriangleContainingPoint
C3DLinkIndexFromTriangleToTriangle
C3DVertexNotSharedByTriangles
C3DShapeConnectedComponentTriangulatePseudopolygon
list->count > 1
C3DShapeTriangulationAddEdge
recycledTriangles.count == 0
C3DSpokeCreate
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Primitives/Text/C3DShapeStraightSkeleton.c
CGPointEqualToPoint(origin, prev) == false
CGPointEqualToPoint(origin, next) == false
!isnan(spoke.direction.x)
!isnan(spoke.direction.y)
intersectionForSpokeAndSpoke
fabs(CGPointNorm(spoke1->direction) - 1) < epsilon
fabs(CGPointNorm(spoke2->direction) - 1) < epsilon
intersectionForSpokeAndEdge
spoke != edgeStart
spoke != edgeEnd
splitJoinFace
event.type == C3DStraightSkeletonEventSplit
spoke->boundaryOfVerticesIndex != INVALID_INDEX
other->boundaryOfVerticesIndex != INVALID_INDEX
d != INVALID_INDEX
f != INVALID_INDEX
C3DOffsetBuild
newFace.boundaries == NULL
tessellationFactorScale
maximumEdgeLength
edgeTessellationFactor
insideTessellationFactor
adaptive
screenSpace
tessellationPartitionMode
smoothingMode
<%@: %p, screen space (maximum edge length: %.3f px)>
<%@: %p, local space (maximum edge length: %.3f)>
<%@: %p, uniform (inside: %.3f, edge: %.3f)>
TB,N,GisAdaptive
TB,N,GisScreenSpace
C3DCullingSystem
<C3DCullingSystem %p>
T@,&
T{CGRect={CGPoint=dd}{CGSize=dd}}
bounds
T{CGSize=dd}
vector3
T{SCNVector3=fff},R
vector4
T{SCNVector4=ffff},R
matrix4
JSValue
toVector4
toVector3
toTransform3D
valueWithVector3:inContext:
valueWithVector4:inContext:
valueWithTransform3D:inContext:
_SceneKitIsLoaded
SCNMaterialProperty
SCNBoundingBox
SCNBoundingSphere
SCNTransaction
SCNColor
CAMediaTimingFunction
CABasicAnimation
CAAnimationGroup
CAKeyframeAnimation
CALayer
SCNImage
SCNValue
SCNView
SCNNode
SCNGeometry
SCNPhysicsWorld
SCNPhysicsBody
SCNTransformConstraint
SCNLookAtConstraint
SCNLight
SCNCylinder
SCNGeometryElement
SCNIKConstraint
SCNPhysicsVehicleWheel
SCNRenderer
SCNTube
SCNParticleSystem
SCNMorpher
SCNBox
SCNCamera
SCNLevelOfDetail
SCNMaterial
SCNProgram
SCNParticlePropertyController
SCNConstraint
SCNPlane
SCNCone
SCNPhysicsBehavior
SCNPhysicsHingeJoint
SCNPhysicsField
SCNGeometrySource
SCNTorus
SCNPhysicsShape
SCNCapsule
SCNFloor
SCNShape
SCNText
SCNTechnique
SCNPyramid
SCNSceneSource
SCNSphere
SCNPhysicsBallSocketJoint
SCNPhysicsSliderJoint
SCNPhysicsContact
SCNHitTestResult
SCNAnimationEvent
SCNPhysicsVehicle
SCNAction
SCNActionTimingModeLinear
SCNActionTimingModeEaseIn
SCNActionTimingModeEaseOut
SCNActionTimingModeEaseInEaseOut
SCNEditingLocalSpace
SCNEditingParentSpace
SCNEditingWorldSpace
SCNEditingScreenSpace
SCNManipulatorPositionCenter
SCNManipulatorPositionMin
SCNManipulatorPositionMax
SCNAuthoringDisplayBoundingBoxes
SCNAuthoringDisplayBoundingSpheres
SCNAuthoringDisplayCameraFrustum
SCNAuthoringDisplayLightExtents
SCNAuthoringDisplayCameraPosition
SCNAuthoringDisplayLightPosition
SCNAuthoringDisplayPhysics
SCNAuthoringDisplayPhysicsFields
SCNAuthoringDisplayGrid
SCNAuthoringDisplayLightProbes
SCNAuthoringDisplayWireframe
SCNAuthoringDisplaySkeletons
SCNAuthoringDisplayConstraints
SCNAuthoringDisplayCreases
SCNAuthoringDisplayLightInfluence
SCNAuthoringCameraPerspective
SCNAuthoringCameraTop
SCNAuthoringCameraBottom
SCNAuthoringCameraLeft
SCNAuthoringCameraRight
SCNAuthoringCameraFront
SCNAuthoringCameraBack
SCNCameraProjectionDirectionVertical
SCNCameraProjectionDirectionHorizontal
SCNInteractionModeFly
SCNInteractionModeOrbitTurntable
SCNInteractionModeOrbitAngleMapping
SCNInteractionModeOrbitCenteredArcball
SCNInteractionModeOrbitArcball
SCNInteractionModePan
SCNInteractionModeTruck
SCNCameraFieldOfViewOrientationVertical
SCNCameraFieldOfViewOrientationHorizontal
SCNCameraExposureAdaptationModeFrameLuminance
SCNCameraExposureAdaptationModeHistogramLuminance
SCNCameraFillModeFill
SCNCameraFillModeLetterbox
SCNGeometryPrimitiveTypeTriangles
SCNGeometryPrimitiveTypeTriangleStrip
SCNGeometryPrimitiveTypeLine
SCNGeometryPrimitiveTypePoint
SCNGeometryPrimitiveTypePolygon
SCNTessellationSmoothingModeNone
SCNTessellationSmoothingModePNTriangles
SCNTessellationSmoothingModePhong
SCNSubdivisionBoundaryInterpolationRuleNone
SCNSubdivisionBoundaryInterpolationRuleEdgeOnly
SCNSubdivisionBoundaryInterpolationRuleEdgeAndCorner
SCNSubdivisionFaceVaryingInterpolationRuleLinearNone
SCNSubdivisionFaceVaryingInterpolationRuleLinearCornersOnly
SCNSubdivisionFaceVaryingInterpolationRuleLinearCornersPlus1
SCNSubdivisionFaceVaryingInterpolationRuleLinearCornersPlus2
SCNSubdivisionFaceVaryingInterpolationRuleLinearBoundaries
SCNSubdivisionFaceVaryingInterpolationRuleLinearAll
SCNSubdivisionNormalSmoothingModeCrossTriangle
SCNSubdivisionNormalSmoothingModeCrossQuad
SCNSubdivisionNormalSmoothingModeLimit
SCNHitTestSearchModeClosest
SCNHitTestSearchModeAll
SCNHitTestSearchModeAny
SCNLevelOfDetailThresholdModeWorldSpaceDistance
SCNLevelOfDetailThresholdModeScreenSpaceRadius
SCNShadowModeForward
SCNShadowModeDeferred
SCNShadowModeModulated
SCNMorpherCalculationModeNormalized
SCNMorpherCalculationModeAdditive
SCNMovabilityHintFixed
SCNMovabilityHintMovable
SCNChamferModeBoth
SCNChamferModeFront
SCNChamferModeBack
SCNParticleSortingModeNone
SCNParticleSortingModeProjectedDepth
SCNParticleSortingModeDistance
SCNParticleSortingModeOldestFirst
SCNParticleSortingModeYoungestFirst
SCNParticleBlendModeAdditive
SCNParticleBlendModeSubtract
SCNParticleBlendModeMultiply
SCNParticleBlendModeScreen
SCNParticleBlendModeAlpha
SCNParticleBlendModeReplace
SCNParticleOrientationModeBillboardScreenAligned
SCNParticleOrientationModeBillboardViewAligned
SCNParticleOrientationModeFree
SCNParticleOrientationModeBillboardYAligned
SCNParticleBirthLocationSurface
SCNParticleBirthLocationVolume
SCNParticleBirthLocationVertex
SCNParticleBirthDirectionConstant
SCNParticleBirthDirectionSurfaceNormal
SCNParticleBirthDirectionRandom
SCNParticleImageSequenceAnimationModeRepeat
SCNParticleImageSequenceAnimationModeClamp
SCNParticleImageSequenceAnimationModeAutoReverse
SCNParticleInputModeOverLife
SCNParticleInputModeOverDistance
SCNParticleInputModeOverOtherProperty
SCNParticleModifierStagePreDynamics
SCNParticleModifierStagePostDynamics
SCNParticleModifierStagePreCollision
SCNParticleModifierStagePostCollision
SCNParticleEventBirth
SCNParticleEventDeath
SCNParticleEventCollision
SCNParticleRenderingModeSprite
SCNParticleRenderingModePointSprite
SCNParticleRenderingModeTrail
SCNParticleRenderingModeBeam
SCNParticleRenderingModeGeometry
SCNReferenceLoadingPolicyImmediate
SCNReferenceLoadingPolicyOnDemand
SCNAntialiasingModeNone
SCNAntialiasingModeMultisampling2X
SCNAntialiasingModeMultisampling4X
SCNRenderingAPIMetal
SCNRenderingAPIOpenGLES2
SCNSceneSourceStatusParsing
SCNSceneSourceStatusValidating
SCNSceneSourceStatusProcessing
SCNSceneSourceStatusComplete
SCNSceneSourceStatusError
SCNCullBack
SCNCullFront
SCNBufferFrequencyPerFrame
SCNBufferFrequencyPerNode
SCNBufferFrequencyPerShadable
SCNFillModeFill
SCNFillModeLines
SCNCullModeBack
SCNCullModeFront
SCNTransparencyModeAOne
SCNTransparencyModeRGBZero
SCNTransparencyModeSingleLayer
SCNTransparencyModeDualLayer
SCNTransparencyModeDefault
SCNBlendModeAlpha
SCNBlendModeAdd
SCNBlendModeSubtract
SCNBlendModeMultiply
SCNBlendModeScreen
SCNBlendModeReplace
SCNBlendModeMax
SCNFilterModeNone
SCNFilterModeNearest
SCNFilterModeLinear
SCNWrapModeClamp
SCNWrapModeRepeat
SCNWrapModeMirror
SCNPhysicsBodyTypeStatic
SCNPhysicsBodyTypeDynamic
SCNPhysicsBodyTypeKinematic
SCNPhysicsFieldScopeInsideExtent
SCNPhysicsFieldScopeOutsideExtent
fromValue
toValue
TB,GisAdditive
TB,GisCumulative
T@"CAMediaTimingFunction",&
TB,GisRemovedOnCompletion
T^{CGPath=}
keyTimes
T@,C,N
currentTime
T@,N
TB,N,GisPlaying
T@"SCNNode",N
tessellationControlShader
tessellationEvaluationShader
geometryShader
vertexFunctionName
fragmentFunctionName
TB,N,GisOpaque
T@"<SCNProgramDelegate>",N
presentationMorpher
T@"SCNMorpher",R,N
T@"SCNGeometry",R
screenSpaceRadius
Td,R
worldSpaceDistance
audioPlayers
particleSystems
hemispheric
TB,N,GisHemispheric
geometrySourceChannels
influenceFactor
incremental
TB,N,GisIncremental
presentationLight
T@"SCNLight",R,N
presentationMaterial
T@"SCNMaterial",R,N
speedInKilometersPerHour
wheels
chassisBody
targetOffset
upVector
gimbalLockEnabled
T@,R,N
TB,R,N,GhasInterleavedIndicesChannels
extrusionDepth
chamferMode
chamferProfile
chainRootNode
targetPosition
T@"<SCNPhysicsContactDelegate>"
string
font
wrapped
TB,N,GisWrapped
containerFrame
T{CGRect={CGPoint=dd}{CGSize=dd}},N
textSize
T{CGSize=dd},R,N
truncationMode
alignmentMode
SCNJS%@JSExport
SCN%@JSExport
%@JSExport
_hasFired
C3DRenderTarget
<C3DRenderTarget %p - texture:%@ rbo:%d>
C3D-Add.fsh
C3D-wireframe.vsh
C3D-DefaultProgram.fsh
C3D-EnvMap2D.fsh
C3D-Copy.vsh
C3D-dof-Resolve.vsh
C3D-dof-downSample4x.vsh
C3DManipulator.vsh
C3D-GaussianBlurAlpha.fsh
C3D-IncrementalAverage.vsh
C3DFXPostProcess.json
C3D-OutlineMax.vsh
C3D-spotShadow.vsh
C3D-GaussianBlur.vsh
C3D-BlendAuthoring.vsh
C3D-Copy.fsh
C3D-OutlineRetina.vsh
C3D-CIFilterComposite.fsh
C3D-EnvMap2D.vsh
C3DFXMotionBlur.plist
C3D-ParticleSystem.fsh
C3DFXJitteringPassFloat.plist
C3DFXPostProcess_depth.json
C3D-Outline.vsh
C3D-dof-ComputeNearCoc.fsh
C3DFXSSAO.json
C3D-GaussianBlurAlpha.vsh
C3D-WarmupTexture.vsh
C3D-PickedObjects.vsh
C3D-OutlineMax.fsh
C3D-IncrementalAverage.fsh
C3D-spotShadow.fsh
C3D-BlendAuthoring.fsh
C3D-EnvMapCube.vsh
C3D-CIFilterComposite.vsh
C3DManipulatorLightProbe.vsh
C3D-dof-ComputeNearCoc.vsh
C3D-dof-generateNearCoc.fsh
C3D-WarmupTexture.fsh
C3DFXCopyPass.plist
SCNShaderLightingContribution.glsl
C3DManipulatorColorOnly.vsh
C3D-Mult_float.fsh
C3D-EnvMapCube.fsh
C3D-dof-Resolve.fsh
C3D-dof-Blur5x5.fsh
C3D-ParticleSystem_Trail.vsh
C3DManipulatorColorAndTexture.fsh
C3D-wireframe.fsh
C3D-DefaultProgram.vsh
C3DManipulatorLightProbe.fsh
C3D-dof-generateNearCoc.vsh
C3D-PickedObjects.fsh
C3D-dof-downSample4x.fsh
C3D-Mult_float.vsh
C3D-Add.vsh
C3DManipulator.fsh
C3D-dof-Blur5x5.vsh
C3D-GaussianBlur.fsh
C3DManipulatorColorOnly.fsh
C3D-ParticleSystem.vsh
C3D-Outline.fsh
C3D-OutlineRetina.fsh
C3D-ParticleSystem_Trail.fsh
C3DManipulatorColorAndTexture.vsh
  "sequence" : [
                "SceneKit_renderCIQuad"
                ],
  "targets" : {
    "SceneKit-CI-effect-depth" : {
      "type" : "depth"
    },
    "SceneKit-CI-effect-color" : {
      "type" : "color",
      "format" : "rgba",
      "usage" : ["shaderWrite", "shaderRead"]
    }
  },
  "symbols" : {
    "C3D-CIFilter_middleZ" : {
      "type" : "float"
    },
    "C3D-CIFilter_extent" : {
      "type" : "vec4"
    },
    "C3D-CIFilter_reverseZ" : {
        "type" : "float"
    }
  },
  "passes" : {
    "SceneKit_renderCIQuad" : {
      "inputs" : {
        "u_color" : {
          "target" : "SceneKit-CI-effect-color",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_middleZ" : "C3D-CIFilter_middleZ",
        "u_extent" : "C3D-CIFilter_extent",
        "u_reverseZ" : "C3D-CIFilter_reverseZ",
        "u_depth" : {
          "target" : "SceneKit-CI-effect-depth",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        }
      },
      "hasConstantAlpha" : false,
      "colorStates" : {
        "clear" : false
      },
      "depthStates" : {
        "clear" : false
      },
      "cullMode" : "none",
      "metalVertexShader" : "scn_filterCompositeVert",
      "metalFragmentShader" : "scn_filterCompositeFrag",
      "draw" : "none",
      "clientProgram" : false,
      "blendStates" : {
        "enable" : true,
        "colorDst" : "oneMinusSrcAlpha",
        "colorSrc" : "one"
      }
    },
uniform sampler2D textureSampler0;
uniform sampler2D textureSampler1;
varying vec2 TexCoord;
void main (void)
gl_FragColor = texture2D(textureSampler0,TexCoord) + texture2D(textureSampler1,TexCoord);
uniform mat4 u_modelViewProjectionTransform;
attribute vec4 a_position;
attribute vec4 a_color;
varying vec3 v_vertexCenter;
void main()
    vec3 pos = a_position.xyz;
    int id = int(a_position.w); 
    gl_Position = (u_modelViewProjectionTransform * vec4(pos, 1.0));
    
    float s = 1.;
    mat3 centers = mat3(vec3(s, 0. ,0.), vec3(0., s, 0.), vec3(0., 0., s));
    v_vertexCenter = centers[id];
void main (void)
gl_FragColor =
vec4(1.0,0.0,1.0,1.0);
uniform sampler2D textureSampler0;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2D(textureSampler0,TexCoord);
attribute vec3 a_position;
varying vec2 TexCoord;
void main(void)
gl_Position = vec4(a_position, 1.0);
TexCoord = (a_position.xy + 1.0) * 0.5;
#define USE_QUAT_FOR_IES 1
struct scn_light
    float4 color; 
    float3 pos; 
    float3 dir; 
    float shadowRadius; 
    uint8_t lightType; 
    uint8_t attenuationType; 
    uint8_t shadowSampleCount; 
                                
    union {
        struct {
            float4      cascadeScale[4]; 
            float4      cascadeBias[4];
        } directional; 
        struct {
            float4      attenuationFactors; 
            float3      shadowScaleBias; 
        } omni;
        struct {
            float4      _attenuationFactors; 
            float2      scaleBias; 
        } spot;
        struct {
            float4      _attenuationFactors; 
            float2      scaleBias; 
#if USE_QUAT_FOR_IES
            float4      light_from_view_quat; 
#else
            float4x4    light_from_view; 
#endif
        } ies;
        union {
            struct {
                float2 halfExtents;
                float doubleSided;
            } rectangle;
            struct {
                uint32_t vertexCount;
                float doubleSided;
            } polygon;
            struct {
                float halfLength;
            } line;
            struct {
                float2 halfExtents;
                float doubleSided;
            } ellipse;
            struct {
                float3 halfExtents;
            } ellipsoid;
        } area;
        struct {
            float3  offset;
            float4  halfExtents; 
            float3  parallaxCenter;
            float3  parallaxExtents;
            int32_t index; 
            int32_t parallaxCorrection; 
        } probe;
    } parameters; 
    float4x4    shadowMatrix; 
#if defined(__METAL_VERSION__) 
#define ambientOcclusionTexcoord ambientTexcoord
struct SCNShaderSurface {
    float3 view;                
    float3 position;            
    float3 normal;              
    float3 geometryNormal;      
    float2 normalTexcoord;      
    float3 tangent;             
    float3 bitangent;           
    float4 ambient;             
    float2 ambientTexcoord;     
    float4 diffuse;             
    float2 diffuseTexcoord;     
    float4 specular;            
    float2 specularTexcoord;    
    float4 emission;            
    float2 emissionTexcoord;    
    float4 selfIllumination;            
    float2 selfIlluminationTexcoord;    
    float4 multiply;            
    float2 multiplyTexcoord;    
    float4 transparent;         
    float2 transparentTexcoord; 
    float4 reflective;          
    float  metalness;           
    float2 metalnessTexcoord;   
    float  roughness;           
    float2 roughnessTexcoord;   
    float clearCoat;            
    float2 clearCoatTexcoord;   
    float clearCoatRoughness;   
    float2 clearCoatRoughnessTexcoord;
    float3 clearCoatNormal;     
    float2 clearCoatNormalTexcoord;
    float shininess;            
    float fresnel;              
    float ambientOcclusion;     
    float3 _normalTS;           
    float3 _clearCoatNormalTS;  
#ifdef USE_SURFACE_EXTRA_DECL
    __SurfaceExtraDecl__
#endif
struct SCNShaderLight {
    float4 intensity;
    float3 direction;
    float  _att;
    float3 _spotDirection;
    float  _distance;
enum SCNLightingModel
    SCNLightingModelConstant,
    SCNLightingModelLambert,
    SCNLightingModelPhong,
    SCNLightingModelBlinn,
    SCNLightingModelNone,
    SCNLightingModelPhysicallyBased,
    SCNLightingModelShadowOnly,
    SCNLightingModelCustom 
enum C3DLightAttenuationType
    kC3DLightAttenuationTypeNone,
    kC3DLightAttenuationTypeConstant,
    kC3DLightAttenuationTypeLinear,
    kC3DLightAttenuationTypeQuadratic,
    kC3DLightAttenuationTypeExponent,
    kC3DLightAttenuationTypePhysicallyBased,
#define PROBES_NORMALIZATION 0
#define PROBES_OUTER_BLENDING 1
struct SCNShaderLightingContribution
    float3 ambient;
    float3 diffuse;
    float3 specular;
    float3 modulate;
#ifdef USE_SHADOWONLY
    float shadowFactor;
#endif
#if PROBES_NORMALIZATION
    float4 probesWeightedSum; 
#else
    float  probeRadianceRemainingFactor;
#endif
    thread SCNShaderSurface& surface;
#ifdef USE_PER_VERTEX_LIGHTING
    commonprofile_io out;
#else
    commonprofile_io in;
#endif
#if USE_REVERSE_Z
    constant static constexpr bool reverseZ = true;
#else
    constant static constexpr bool reverseZ = false;
#endif
#ifdef USE_PBR
    static constexpr sampler linearSampler = sampler(filter::linear, mip_filter::linear);
    float  selfIlluminationOcclusion;
    float3 reflectance;
    float3 probeReflectance;
    float  NoV;
    float  NoVClearCoat;
    float3 probeReflectanceClearCoat;
#endif
    SCNShaderLightingContribution(thread SCNShaderSurface& iSurface, commonprofile_io io):surface(iSurface)
#ifdef USE_PER_VERTEX_LIGHTING
    ,out(io)
#else
    ,in(io)
#endif
    {
        ambient = 0.f;
        diffuse = 0.f;
        specular = 0.f;
#ifdef USE_SHADOWONLY
        shadowFactor = 1.f;
#endif
#if PROBES_NORMALIZATION
#if PROBES_OUTER_BLENDING
        probesWeightedSum = float4(0.f);
#else
        probesWeightedSum = float4(0.f, 0.f, 0.f, 0.000001f); 
#endif
#else
        probeRadianceRemainingFactor = 1.f;
#endif
#ifdef USE_MODULATE
        modulate = 1.f;
#else
        modulate = 0.f;
#endif
    }
#ifdef USE_PBR
    void prepareForPBR(texture2d<float, access::sample> specularDFG, float occ)
    {
        selfIlluminationOcclusion = occ;
        float3 n = surface.normal;
        float3 v = surface.view;
        reflectance = mix(PBR_F0_NON_METALLIC, surface.diffuse.rgb, surface.metalness);
        NoV = saturate(dot(n, v));
        float2 DFG = specularDFG.sample(linearSampler, float2(NoV, surface.roughness)).rg;
        probeReflectance = reflectance * DFG.r + DFG.g;
    }
    void prepareForPBRClearCoat(texture2d<float, access::sample> specularDFG)
    {
        float3 n = surface.clearCoatNormal;
        float3 v = surface.view;
        
        NoVClearCoat = saturate(dot(n, v));
        float2 DFG = specularDFG.sample(linearSampler, float2(NoVClearCoat, surface.clearCoatRoughness)).rg;
        probeReflectanceClearCoat = 0.04 * DFG.r + DFG.g;
    }
#endif
#ifdef USE_LIGHT_MODIFIER
    __LightModifierExtraDecl__
#endif
    float4 debug_pixel(float2 fragmentPosition)
    {
        const int width = 64;
        switch (int(fragmentPosition.x + fragmentPosition.y ) / width) {
            case 0: return float4(surface.view, 1.f);
            case 1: return float4(surface.position, 1.f);
            case 2: return float4(surface.normal, 1.f);
            case 3: return float4(surface.geometryNormal, 1.f);
            case 4: return float4(float3(surface.ambientOcclusion), 1.f);
            case 5: return surface.diffuse;
            case 6: return float4(float3(surface.metalness), 1.f);
            case 7: return float4(float3(surface.roughness), 1.f);
            case 8: return float4(ambient, 1.f);
            case 9: return float4(diffuse, 1.f);
            default: return float4(specular, 1.f);
        }
    }
    
    static inline float3 lambert_diffuse(float3 l, float3 n, float3 color, float intensity) {
        return color * (intensity * saturate(dot(n, l)));
    }
    void lambert(float3 l, float3 color, float intensity)
    {
        diffuse += lambert_diffuse(l, surface.normal, color, intensity);
    }
    void blinn(float3 l, float3 color, float intensity)
    {
        float3 D = lambert_diffuse(l, surface.normal, color, intensity);
        diffuse += D;
        float3 h = normalize(l + surface.view);
        specular += powr(saturate(dot(surface.normal, h)), surface.shininess) * D;
    }
    void phong(float3 l, float3 color, float intensity)
    {
        float3 D = lambert_diffuse(l, surface.normal, color, intensity);
        diffuse += D;
        float3 r = reflect(-l, surface.normal);
        specular += powr(saturate(dot(r, surface.view)), surface.shininess) * D;
    }
#ifdef USE_PBR
    void pbr(float3 l, float3 color, float intensity)
    {
        float3 n = surface.normal;
        float3 v = surface.view;
        float3 h = normalize(l + v);
        float NoL = saturate(dot(n, l));
        float NoH = saturate(dot(n, h));
        float LoH = saturate(dot(l, h));
        
        
        
        
        float roughness = max(surface.roughness, 0.089f);
        float alpha = roughness * roughness; 
        float D   = scn_brdf_D(alpha, NoH);
        float3 F  = scn_brdf_F_opt(reflectance, LoH);
        float Vis = scn_brdf_V(alpha, NoL, NoV);
        
        diffuse  += color * (NoL * M_1_PI_F * intensity);
        specular += color * F * ( NoL * D * Vis * intensity);
        
        #ifdef USE_CLEARCOAT
            n = surface.clearCoatNormal;
            roughness = max(surface.clearCoatRoughness, 0.089f);
            alpha = roughness * roughness; 
        
            
            
            float NoH_coat = saturate(dot(n, h));
            float NoL_coat = saturate(dot(n, l));
            D   = scn_brdf_D(alpha, NoH_coat);
            F  = scn_brdf_F_opt(0.04, LoH) * surface.clearCoat;
            Vis = scn_brdf_V(alpha, NoL_coat, saturate(dot(n,v)));
        
            float attenuation = 1.0 - F.r;
            specular *=  (attenuation * attenuation);
            specular += color * F * ( NoL_coat * D * Vis * intensity);
        #endif
    }
#endif
    void custom(float3 _l, float3 _color, float _intensity)
    {
#ifdef USE_LIGHT_MODIFIER
        thread SCNShaderLightingContribution &_lightingContribution = *this;
        thread SCNShaderSurface& _surface = surface;
        SCNShaderLight _light = {.direction = _l, .intensity = float4(_color, 1.f), ._att = _intensity };
        
        __DoLightModifier__
        
#endif
    }
    void shade(float3 l, float3 color, float intensity)
    {
#ifdef LIGHTING_MODEL
        switch (LIGHTING_MODEL) {
#ifdef USE_SHADOWONLY
            case SCNLightingModelShadowOnly:        shadowFactor *= intensity; break;
#endif
            case SCNLightingModelLambert:           lambert(l, color, intensity); break;
            case SCNLightingModelBlinn:             blinn(l, color, intensity);   break;
            case SCNLightingModelPhong:             phong(l, color, intensity);   break;
#ifdef USE_PBR
            case SCNLightingModelPhysicallyBased:   pbr(l, color, intensity);     break;
#endif
            case SCNLightingModelCustom:            custom(l, color, intensity);  break;
            default:                                                                       break; 
        }
#endif
    }
    
    
    
    float pbr_dist_attenuation_alternate(float3 l, float cutoff) {
        
        float radius = 0.1f; 
        float factor = 1.f / (1.f + length(l)/radius);
        float attenuation = saturate(factor * factor); 
        return saturate((attenuation - cutoff) / (1.f - cutoff));
    }
    float pbr_dist_attenuation(float3 l, float inv_square_radius) {
        float sqr_dist = length_squared(l);
        float atten = 1.f / max(sqr_dist, 0.0001f);
        
        float factor = saturate(1.f - scn::sq(sqr_dist * inv_square_radius));
        return atten * factor * factor;
    }
    float non_pbr_dist_attenuation(float3 l, float4 att)
    {
        return powr(saturate(length(l) * att.x + att.y), att.z);
    }
    float dist_attenuation(float3 unnormalized_l, scn_light light)
    {
#ifdef USE_PBR
        return 1000.f * pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors.w);
        
        
#else
        return non_pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors);
#endif
    }
    float spot_attenuation(float3 l, scn_light light)
    {
        
        return saturate(dot(l, light.dir) * light.parameters.spot.scaleBias.x + light.parameters.spot.scaleBias.y);
    }
    void shade_modulate(float3 l, float4 color, float intensity)
    {
        constexpr half3 white = half3(1.h);
        
        modulate *= float3(mix(white, half3(color.rgb), half(color.a * intensity)));
    }
    float3 gobo(float3 pos, scn_light light, texture2d<half> goboTexture, sampler goboSampler)
    {
        half3 g = texture2DProj(goboTexture, goboSampler, (light.shadowMatrix * float4(pos, 1.f))).rgb;
        return light.color.rgb * float3(mix(1.h, g, half(light.color.a)));
    }
    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap)
    {
        float shadow = ComputeShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, reverseZ);
        return 1.f - shadow * light.color.a; 
    }
    
    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel)
    {
        float shadow = ComputeSoftShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowKernel, light.shadowSampleCount, light.shadowRadius, reverseZ);
        return 1.f - shadow * light.color.a; 
    }
    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int shadowSampleCount)
    {
        float shadow = ComputeSoftShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowKernel, shadowSampleCount, light.shadowRadius, reverseZ);
        return 1.f - shadow * light.color.a; 
    }
    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, int shadowSampleCount)
    {
        float shadow = ComputeSoftShadowGrid(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowSampleCount, reverseZ);
        return 1.f - shadow * light.color.a; 
    }
    float shadow_omni(float3 pos_vs, float3 nrm_vs, scn_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
        
#define USE_TANGENT_SAMPLING 0
        float2 scaleBias = light.parameters.omni.shadowScaleBias.xy;
        float  depthBias = light.parameters.omni.shadowScaleBias.z;
        
        pos_vs += nrm_vs * depthBias;
        
        float3 pos_ls = (light.shadowMatrix * float4(pos_vs, 1.f)).xyz;
        
        float z_lin = scn::reduce_max(abs(pos_ls));
        
        
        
        
        float z_ndc = (z_lin * scaleBias.x + scaleBias.y) / z_lin - depthBias;
        
        float shadow;
        if (sampleCount <= 1) {
            shadow = shadowMap.sample_compare(scn_shadow_sampler, pos_ls.xyz, z_ndc);
        } else {
            
            float filteringSizeFactor = light.shadowRadius;
#if USE_TANGENT_SAMPLING
            float3 tgt_x, tgt_y;
            scn::orthogonal_basis(pos_ls, tgt_x, tgt_y);
#else
            float3 nrm_ls = (light.shadowMatrix * float4(nrm_vs, 0.f)).xyz;
#endif
            
            float totalAccum = 0.0;
            for(int i=0; i < sampleCount; i++){
#if USE_TANGENT_SAMPLING
                float2 scale = shadowKernel[i].xy * filteringSizeFactor * 2.f;
                float3 smp_ls = pos_ls.xyz + tgt_x * scale.x + tgt_y * scale.y;
#else
                float3 smp_ls = pos_ls.xyz + scn::randomHemisphereDir(nrm_ls, shadowKernel[i].xy) * filteringSizeFactor;
#endif
                
                
                
                totalAccum += shadowMap.sample_compare(scn_shadow_sampler, smp_ls, z_ndc);
            }
            shadow = totalAccum / float(sampleCount);
        }
        return 1.f - shadow * light.color.a; 
    }
    float shadow(float3 pos, constant scn_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount)
    {
        float shadow = ComputeCascadedShadow(scn_shadow_sampler, pos, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius).a;
        return 1.f - shadow * light.color.a; 
    }
    
    void add_directional(scn_light light)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        shade(light.dir, light.color.rgb, intensity);
    }
    
    void add_directional(scn_light light, texture2d<half> goboTexture, sampler goboSampler, bool modulated)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);
        if (modulated) {
            shade_modulate(light.dir, light.color, 1.f);
        } else {
            shade(light.dir, light.color.rgb, intensity);
        }
    }
    
    void add_directional(scn_light light, depth2d<float> shadowMap)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        intensity *= shadow(surface.position, light, shadowMap);
        shade(light.dir, light.color.rgb, intensity);
    }
    
    void add_directional(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        intensity *= shadow(surface.position, light, shadowMap, shadowKernel);
        shade(light.dir, light.color.rgb, intensity);
    }
    void add_directional(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        intensity *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);
        shade(light.dir, light.color.rgb, intensity);
    }
    
    void add_directional(scn_light light, depth2d<float> shadowMap, int sampleCount)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        intensity *= shadow(surface.position, light, shadowMap, sampleCount);
        shade(light.dir, light.color.rgb, intensity);
    }
    
    void add_directional(constant scn_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount, bool debugCascades)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        if (debugCascades) {
            float4 shadowDebug = ComputeCascadedShadow(scn_shadow_sampler, surface.position, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius);
            intensity *= (1.f - shadowDebug.a);
            shade(light.dir, light.color.rgb, intensity);
            diffuse.rgb = mix(diffuse.rgb, shadowDebug.rgb, light.color.a);
        } else {
            intensity *= shadow(surface.position, light, shadowMaps, cascadeCount, blendCascade, shadowKernel, sampleCount);
            shade(light.dir, light.color.rgb, intensity);
        }
    }
    
    void add_omni(scn_light light)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light));
    }
    void add_omni(scn_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity *= shadow_omni(surface.position, surface.normal, light, shadowMap, shadowKernel, sampleCount);
        shade(l, light.color.rgb, intensity);
    }
    void add_local_omni(scn_light light)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light));
    }
    
    void add_spot(scn_light light)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= spot_attenuation(l, light);
        shade(l, light.color.rgb, intensity);
    }
    void add_spot(scn_light light, texture2d<half> goboTexture, sampler goboSampler, bool modulated)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= spot_attenuation(l, light);
        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);
        if (modulated) {
            shade_modulate(l, light.color, intensity);
        } else {
            shade(l, light.color.rgb, intensity);
        }
    }
    void add_local_spot(scn_light light)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= spot_attenuation(l, light);
        shade(l, light.color.rgb, intensity);
    }
    
    void add_spot(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= spot_attenuation(l, light);
        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);
        shade(l, light.color.rgb, intensity);
    }
    
#ifdef USE_PBR
    
#ifdef C3D_SUPPORT_CUBE_ARRAY
    void add_local_probe(scn_light light, texturecube_array<half> probeTextureArray)
#else
    void add_local_probe(scn_light light, texture2d_array<half> probeTextureArray)
#endif
    {
#if !PROBES_NORMALIZATION
        if (probeRadianceRemainingFactor <= 0.f)
            return;
#endif
        bool parallaxCorrection = light.parameters.probe.parallaxCorrection;
        int    probeIndex       = light.parameters.probe.index;
        float3 probeExtents     = light.parameters.probe.halfExtents.xyz;
        float  blendDist        = light.parameters.probe.halfExtents.w;
        float3 probeOffset      = light.parameters.probe.offset;
        float3 parallaxExtents  = light.parameters.probe.parallaxExtents;
        float3 parallaxCenter   = light.parameters.probe.parallaxCenter;
        float3 n = surface.normal;
        float3 v = surface.view;
        float3 r = reflect(-v, n); 
        float3 specDir = scn::mat4_mult_float3(light.shadowMatrix, r);
        
        float3 pos_ls = (light.shadowMatrix * float4(surface.position, 1.f)).xyz;
        
        float3 d = abs(pos_ls) - probeExtents;
#if PROBES_OUTER_BLENDING
        if (any(d > blendDist))
#else
        if (any(d > 0.f))
#endif
        {
            return;
        }
#if PROBES_NORMALIZATION
        
        
#if PROBES_OUTER_BLENDING
        float3 nd = saturate(-(d / blendDist) * 0.5f + 0.5f);
#else
        float3 nd = saturate(-(d / blendDist));
#endif
        float probeFactor = (nd.x * nd.y * nd.z) * light.color.r;
#else
        
        float sd = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
#if PROBES_OUTER_BLENDING
        float probeFactor = saturate(1.f - sd / blendDist);
#else
        float probeFactor = saturate(-sd / blendDist);
#endif
        
        
        
        probeFactor *= probeRadianceRemainingFactor * light.color.r; 
#endif
        if (parallaxCorrection ) {
            
            float3 pos_off = pos_ls + parallaxCenter;
            float3 t1 = ( parallaxExtents - pos_off) / specDir;
            float3 t2 = (-parallaxExtents - pos_off) / specDir;
            float3 tmax = max(max(0, t1), t2); 
            float t = min(tmax.x, min(tmax.y, tmax.z));
            
            float3 hit_ls = pos_ls + specDir * t;
            specDir = hit_ls - probeOffset;
        }
        float mipd = float(probeTextureArray.get_num_mip_levels()) - 1.f;
        const float intensity = surface.ambientOcclusion * probeFactor;
        float mips = surface.roughness * mipd;
#ifdef C3D_SUPPORT_CUBE_ARRAY
        float3 LD = float3(probeTextureArray.sample(linearSampler, specDir, probeIndex, level(mips)).rgb);
#else
        float2 specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));
        float3 LD = float3(probeTextureArray.sample(linearSampler, specUV, probeIndex, level(mips)).rgb);
#endif
        
        
#if PROBES_NORMALIZATION
        probesWeightedSum += float4(LD * intensity * probeReflectance, probeFactor);
#else
        probeRadianceRemainingFactor = saturate(probeRadianceRemainingFactor - probeFactor);
        specular += LD * intensity * probeReflectance;
#endif
        
        
#ifdef USE_CLEARCOAT
        n = surface.clearCoatNormal;
        r = reflect(-v, n);
        specDir = scn::mat4_mult_float3(light.shadowMatrix, r);
        if (parallaxCorrection ) {
            float3 pos_off = pos_ls + parallaxCenter;
            
            float3 t1 = ( parallaxExtents - pos_off) / specDir;
            float3 t2 = (-parallaxExtents - pos_off) / specDir;
            float3 tmax = max(max(0, t1), t2); 
            float t = min(tmax.x, min(tmax.y, tmax.z));
            
            
            float3 hit_ls = pos_ls + specDir * t;
            specDir = hit_ls - probeOffset;
        }
        mips = surface.clearCoatRoughness * mipd;
#ifdef C3D_SUPPORT_CUBE_ARRAY
        LD = float3(probeTextureArray.sample(linearSampler, specDir, probeIndex, level(mips)).rgb);
#else
        specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));
        LD = float3(probeTextureArray.sample(linearSampler, specUV, probeIndex, level(mips)).rgb);
#endif
#if PROBES_NORMALIZATION
        probesWeightedSum += float4(LD * intensity * probeReflectance, probeFactor) * surface.clearCoat;
#else
        specular += LD * intensity * probeReflectance  * surface.clearCoat;
#endif
#endif
    }
    void add_global_probe(float4x4 localDirToWorldCubemapDir, float environmentIntensity,
#ifdef C3D_SUPPORT_CUBE_ARRAY
                          texturecube_array<half> probeTextureArray
#else
                          texture2d_array<half> probeTextureArray
#endif
                          )
    {
        float3 n = surface.normal;
        float3 v = surface.view;
        float3 r = reflect(-v, n); 
        float3 specDir = scn::mat4_mult_float3(localDirToWorldCubemapDir, r);
        float mipd = float(probeTextureArray.get_num_mip_levels()) - 1.f;
        const float intensity = surface.ambientOcclusion * environmentIntensity;
        float mips = surface.roughness * mipd;
#ifdef C3D_SUPPORT_CUBE_ARRAY
        float3 LD = float3(probeTextureArray.sample(linearSampler, specDir, 0, level(mips)).rgb);
#else
        float2 specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));
        float3 LD = float3(probeTextureArray.sample(linearSampler, specUV, 0, level(mips)).rgb);
#endif
        
        specular += LD * intensity * probeReflectance;
    }
    void add_global_probe(texturecube<float, access::sample> specularLD,
                          float4x4                           localDirToWorldCubemapDir,
                          float                              environmentIntensity)
    {
        float3 n        = surface.normal;
        float3 v        = surface.view;
        float3 r        = reflect(-v, n); 
        float roughness = surface.roughness;
        float roughness2= roughness * roughness;
#if 1
        float smoothness = 1.0f - roughness2;
        float specularLerpFactor = (1. - smoothness * (sqrt(smoothness) + roughness2));
        
        
        
        float3 specularDominantNDirection = mix(r, n, specularLerpFactor); 
#else
        float3 specularDominantNDirection = r;
#endif
        
        
        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);
#if 0 
        float3 dirAbs = abs(specularDominantNDirection);
        float dirNormInf = max(dirAbs.x, max(dirAbs.y, dirAbs.z));
        float scale = 1.0f - exp2(mipLevel) / float(specularLD.get_width());
        if (dirAbs.x != dirNormInf) specularDominantNDirection.x *= scale;
        if (dirAbs.y != dirNormInf) specularDominantNDirection.y *= scale;
        if (dirAbs.z != dirNormInf) specularDominantNDirection.z *= scale;
#endif
        float3 LD = specularLD.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection), level(mipLevel)).rgb;
#if 1 
        float specularOcclusion = saturate(pow(NoV + surface.ambientOcclusion, exp2(-16.0f * roughness - 1.0f)) - 1.0f + surface.ambientOcclusion);
        LD *= specularOcclusion;
#endif
        
        specular += LD * (surface.ambientOcclusion * environmentIntensity) * probeReflectance;
    }
    void add_global_probeClearCoat(texturecube<float, access::sample> specularLD,
                          float4x4                           localDirToWorldCubemapDir,
                          float                              environmentIntensity)
    {
        float3 n = surface.clearCoatNormal;
        
        float3 v        = surface.view;
        float3 r        = reflect(-v, n); 
        float roughness = surface.clearCoatRoughness;
        
        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);
        float3 LD = specularLD.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, r), level(mipLevel)).rgb;
        LD *= surface.ambientOcclusion;
        
        
        float Fc = scn_brdf_F_opt(0.04f, NoVClearCoat).r * surface.clearCoat;
        float attenuation = 1.0f - Fc;
        specular *= (attenuation * attenuation);
        
        specular += LD * environmentIntensity * probeReflectanceClearCoat * surface.clearCoat;
    }
    
    
    void add_irradiance_from_selfIllum()
    {
        float selfIlluminationAO = saturate(mix(1.f, surface.ambientOcclusion, selfIlluminationOcclusion));
        float3 irradiance = selfIlluminationAO * surface.selfIllumination.rgb;
        diffuse  += irradiance;
    }
    void add_global_irradiance_from_sh(float4x4         localDirToWorldCubemapDir,
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
                                       sh2_coefficients shCoefficients)
#else
    sh3_coefficients shCoefficients)
#endif
    {
        float3 n_sh_space = scn::mat4_mult_float3(localDirToWorldCubemapDir, surface.normal);
        float3 irradiance = shEvalDirection(float4(n_sh_space, 1.), shCoefficients);
        diffuse  += surface.ambientOcclusion * irradiance;
    }
    void add_global_irradiance_probe(texturecube<float, access::sample> irradianceTexture,
                                     float4x4                           localDirToWorldCubemapDir,
                                     float                              environmentIntensity)
    {
        float3 n_cube_space = scn::mat4_mult_float3(localDirToWorldCubemapDir, surface.normal);
        float3 irradiance = irradianceTexture.sample(linearSampler, n_cube_space).rgb;
        diffuse  += (surface.ambientOcclusion * environmentIntensity) * irradiance;
    }
#endif 
    
    static constexpr sampler iesSampler = sampler(filter::linear, mip_filter::none, address::clamp_to_edge);
    
    float ies_attenuation(float3 l, scn_light light, texture2d<half> iesTexture)
    {
#if USE_QUAT_FOR_IES
        float3 v    = scn::quaternion_rotate_vector(light.parameters.ies.light_from_view_quat, -l);
#else
        float3 v    = scn::matrix_rotate(light.parameters.ies.light_from_view, -l);
#endif
        float phi   = (v.z * light.parameters.ies.scaleBias.x + light.parameters.ies.scaleBias.y);
        float theta = atan2(v.y, v.x) * 0.5f * M_1_PI_F;
        return iesTexture.sample(iesSampler, float2(phi, abs(theta))).r;
    }
    void add_ies(scn_light light, texture2d<half> iesTexture)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= ies_attenuation(l, light, iesTexture);
        shade(l, light.color.rgb, intensity);
    }
    void add_ies(scn_light light, texture2d<half> iesTexture, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= ies_attenuation(l, light, iesTexture);
        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);
        shade(l, light.color.rgb, intensity);
    }
    
    void add_area_rectangle(scn_light light, texture2d_array<float> bakedDataTexture)
    {
#ifdef USE_PBR
        float3 v = surface.view;
        float3 n = surface.normal;
        float3 p = surface.position;
        
        float3 tangent = normalize(v - n * dot(v, n));
        float3 bitangent = cross(n, tangent);
        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));
        float3 lightCenter = light.shadowMatrix[3].xyz;
        
        
        float sidedness = dot(light.dir, lightCenter - p);
        if (light.parameters.area.rectangle.doubleSided == false && sidedness <= 0.f)
            return;
        
        float3 lightRight = light.shadowMatrix[0].xyz * light.parameters.area.rectangle.halfExtents.x * sign(sidedness);
        float3 lightTop   = light.shadowMatrix[1].xyz * light.parameters.area.rectangle.halfExtents.y;
        
        float4x3 cornerDirections = float4x3((lightCenter + lightRight + lightTop) - p,
                                             (lightCenter + lightRight - lightTop) - p,
                                             (lightCenter - lightRight - lightTop) - p,
                                             (lightCenter - lightRight + lightTop) - p);
        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];
        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];
        cornerDirections[2] = shadingSpaceTransform * cornerDirections[2];
        cornerDirections[3] = shadingSpaceTransform * cornerDirections[3];
        float diffuseAmount = pbr_area_light_eval_rectangle(cornerDirections);
        float brdfNorm = 1.f;
        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);
        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];
        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];
        cornerDirections[2] = inverseLTCMatrix * cornerDirections[2];
        cornerDirections[3] = inverseLTCMatrix * cornerDirections[3];
        float specularAmount = brdfNorm * pbr_area_light_eval_rectangle(cornerDirections);
        float3 lightColor = light.color.rgb;
        diffuse  += diffuseAmount * lightColor;
        specular += specularAmount * lightColor * reflectance;
#endif
    }
    void add_area_polygon(scn_light light, texture2d_array<float> bakedDataTexture, device packed_float2 *vertexPositions)
    {
#ifdef USE_PBR
        float3 v = surface.view;
        float3 n = surface.normal;
        float3 p = surface.position;
        
        float3 tangent = normalize(v - n * dot(v, n));
        float3 bitangent = cross(n, tangent);
        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));
        float3 lightCenter = light.shadowMatrix[3].xyz;
        
        
        float sidedness = dot(light.dir, lightCenter - p);
        if (light.parameters.area.polygon.doubleSided == false && sidedness <= 0.f)
            return;
        
        float3 lightRight = light.shadowMatrix[0].xyz * sign(sidedness);
        float3 lightTop   = light.shadowMatrix[1].xyz;
        p           = shadingSpaceTransform * p;
        lightCenter = shadingSpaceTransform * lightCenter;
        lightRight  = shadingSpaceTransform * lightRight;
        lightTop    = shadingSpaceTransform * lightTop;
        float diffuseAmount = pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);
        float brdfNorm = 1.f;
        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);
        p           = inverseLTCMatrix * p;
        lightCenter = inverseLTCMatrix * lightCenter;
        lightRight  = inverseLTCMatrix * lightRight;
        lightTop    = inverseLTCMatrix * lightTop;
        float specularAmount = brdfNorm * pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);
        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); 
        float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), surface.diffuse.rgb, surface.metalness);
        float3 lightColor = light.color.rgb;
        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;
        specular += specularAmount * lightColor * reflectance;
#endif
    }
    void add_area_line(scn_light light, texture2d_array<float> bakedDataTexture)
    {
#ifdef USE_PBR
        float3 v = surface.view;
        float3 n = surface.normal;
        float3 p = surface.position;
        
        float3 tangent = normalize(v - n * dot(v, n));
        float3 bitangent = cross(n, tangent);
        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));
        float3 lightCenter = light.shadowMatrix[3].xyz;
        float3 lightRight  = light.shadowMatrix[0].xyz * light.parameters.area.line.halfLength;
        float2x3 cornerDirections = float2x3((lightCenter + lightRight) - p,
                                             (lightCenter - lightRight) - p);
        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];
        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];
        float diffuseAmount = pbr_area_light_eval_line(cornerDirections);
        float brdfNorm = 1.f;
        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);
        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];
        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];
        float specularAmount = brdfNorm * pbr_area_light_eval_line(cornerDirections);
        float3 ortho = normalize(cross(cornerDirections[0], cornerDirections[1]));
        float ltcWidthFactor = 1.0 / length(scn_ltc_matrix_invert_transpose(inverseLTCMatrix) * ortho);
        specularAmount *= ltcWidthFactor;
        float3 lightColor = light.color.rgb;
        diffuse  += diffuseAmount * lightColor;
        specular += specularAmount * lightColor * reflectance;
#endif
    }
    void add_area_ellipse(scn_light light, texture2d_array<float> bakedDataTexture)
    {
#ifdef USE_PBR
#endif
    }
    void add_area_ellipsoid(scn_light light, texture2d_array<float> bakedDataTexture)
    {
#ifdef USE_PBR
#endif
    }
#endif 
attribute vec4 a_position;
varying vec2 v_texCoord;
void main(void)
gl_Position = a_position;
    v_texCoord = (a_position.xy + 1.0) * 0.5;
attribute vec4 a_position;
uniform vec2 u_inversePixelSize;
varying vec2 v_tcColor0;
varying vec2 v_tcColor1;
varying vec2 v_tcDepth0;
varying vec2 v_tcDepth1;
varying vec2 v_tcDepth2;
varying vec2 v_tcDepth3;
void main(void)
gl_Position = a_position;
    vec2 tc = (a_position.xy + 1.0) * 0.5;
    v_tcColor0 = tc + vec2( -1.5, -1.5) * u_inversePixelSize * 0.25;
    v_tcColor1 = tc + vec2( +0.5, -1.5) * u_inversePixelSize * 0.25;
    v_tcDepth0 = tc + vec2( -2., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth1 = tc + vec2( -1., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth2 = tc + vec2( +0., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth3 = tc + vec2( +1., -2. ) * u_inversePixelSize * 0.25;
float hash(vec2 p)
    p  = fract(p * vec2(443.8975,397.2973));
    p += dot(p.xy, p.yx+19.19);
    return fract(p.x * p.y);
#pragma body
float x = hash(u_modelTransform[3].xy);
_output.color = vec4(x+1./255.);
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
#import "C3D-PBR.metal"
#import "scn_tessellation.h"
namespace NAMESPACE_HASH {
#ifdef USE_LAYERED_RENDERING
#define texture2d_layer texture2d_array
#define sampleLayer(a,b) sample(a,b,in.sliceIndex)
#else
#define texture2d_layer texture2d
#define sampleLayer(a,b) sample(a,b)
#endif
#if defined(HAS_NORMAL) || defined(USE_OPENSUBDIV)
#define HAS_OR_GENERATES_NORMAL 1
#endif
#ifdef C3D_USE_TEXTURE_FOR_LIGHT_INDICES
#define LightIndex(lid) u_lightIndicesTexture.read((ushort)lid).x
#else
#define LightIndex(lid) u_lightIndicesBuffer[lid]
#endif
typedef struct {
#ifdef USE_MODELTRANSFORM
    float4x4 modelTransform;
#endif
#ifdef USE_INVERSEMODELTRANSFORM
    float4x4 inverseModelTransform;
#endif
#ifdef USE_MODELVIEWTRANSFORM
    float4x4 modelViewTransform;
#endif
#ifdef USE_INVERSEMODELVIEWTRANSFORM
    float4x4 inverseModelViewTransform;
#endif
#ifdef USE_NORMALTRANSFORM
    float4x4 normalTransform;
#endif
#ifdef USE_MODELVIEWPROJECTIONTRANSFORM
    float4x4 modelViewProjectionTransform;
#endif
#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM
    float4x4 inverseModelViewProjectionTransform;
#endif
#ifdef USE_MOTIONBLUR
    float4x4 lastFrameModelTransform;
    float motionBlurIntensity;
#endif
#ifdef USE_BOUNDINGBOX
    float2x3 boundingBox;
#endif
#ifdef USE_WORLDBOUNDINGBOX
    float2x3 worldBoundingBox;
#endif
#ifdef USE_NODE_OPACITY
    float nodeOpacity;
#endif
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
    sh2_coefficients shCoefficients;
#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)
    sh3_coefficients shCoefficients;
#endif
#ifdef USE_SKINNING 
    float4 skinningJointMatrices[765]; 
#endif
} commonprofile_node;
typedef struct {
    float3 position         [[attribute(SCNVertexSemanticPosition)]];
#ifdef HAS_NORMAL
    float3 normal           [[attribute(SCNVertexSemanticNormal)]];
#endif
#ifdef USE_TANGENT
    float4 tangent          [[attribute(SCNVertexSemanticTangent)]];
#endif
#ifdef USE_VERTEX_COLOR
    float4 color            [[attribute(SCNVertexSemanticColor)]];
#endif
#ifdef USE_SKINNING
    float4 skinningWeights  [[attribute(SCNVertexSemanticBoneWeights)]];
    uint4  skinningJoints   [[attribute(SCNVertexSemanticBoneIndices)]];
#endif
#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)
    float2 texcoord0        [[attribute(SCNVertexSemanticTexcoord0)]];
#endif
#ifdef NEED_IN_TEXCOORD1
    float2 texcoord1        [[attribute(SCNVertexSemanticTexcoord1)]];
#endif
#ifdef NEED_IN_TEXCOORD2
    float2 texcoord2        [[attribute(SCNVertexSemanticTexcoord2)]];
#endif
#ifdef NEED_IN_TEXCOORD3
    float2 texcoord3        [[attribute(SCNVertexSemanticTexcoord3)]];
#endif
#ifdef NEED_IN_TEXCOORD4
    float2 texcoord4        [[attribute(SCNVertexSemanticTexcoord4)]];
#endif
#ifdef NEED_IN_TEXCOORD5
    float2 texcoord5        [[attribute(SCNVertexSemanticTexcoord5)]];
#endif
#ifdef NEED_IN_TEXCOORD6
    float2 texcoord6        [[attribute(SCNVertexSemanticTexcoord6)]];
#endif
#ifdef NEED_IN_TEXCOORD7
    float2 texcoord7        [[attribute(SCNVertexSemanticTexcoord7)]];
#endif
} scn_vertex_t; 
typedef struct {
    float4 fragmentPosition [[position]]; 
#ifdef USE_POINT_RENDERING
    float fragmentSize [[point_size]];
#endif
#ifdef USE_VERTEX_COLOR
    float4 vertexColor;
#endif
#ifdef USE_PER_VERTEX_LIGHTING
    float3 diffuse;
#ifdef USE_SPECULAR
    float3 specular;
#endif
#ifdef USE_CLEARCOAT
    float clearCoat;
#endif
#ifdef USE_CLEARCOATROUGHNESS
    float clearCoatRoughness;
#endif
#ifdef USE_CLEARCOATNORMAL
    float clearCoatNormal;
#endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
    float3 position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)
    float3 normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    float3 tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    float3 bitangent;
#endif
#ifdef USE_DISPLACEMENT_MAP
    float2 displacementTexcoord;   
#endif
#ifdef USE_CLEARCOAT_MAP
    float2 clearCoatTexcoord;   
#endif
#ifdef USE_CLEARCOATROUGHNESS_MAP
    float2 clearCoatRoughnessTexcoord;   
#endif
#ifdef USE_CLEARCOATNORMAL_MAP
    float2 clearCoatNormalTexcoord;   
#endif
#ifdef USE_NODE_OPACITY
    float nodeOpacity;
#endif
#ifdef USE_TEXCOORD
    __TexcoordDecl__
#endif
    
#ifdef USE_EXTRA_VARYINGS
    __ExtraVaryingsDecl__
#endif
    
#ifdef USE_MOTIONBLUR
    float3 mv_fragment;
    float3 mv_lastFragment;
#endif
#ifdef USE_OUTLINE
    float outlineHash [[ flat ]];
#endif
#ifdef USE_LAYERED_RENDERING
    uint   sliceIndex [[render_target_array_index]];
#endif
#ifdef USE_MULTIPLE_VIEWPORTS_RENDERING
    uint   sliceIndex [[viewport_array_index]];
#endif
#if DEBUG_PIXEL
    float2 uv0;
#endif
} commonprofile_io;
#ifdef USE_SHADER_MODIFIERS
__ShaderModifiersDecl__
#endif
#import "C3D-Lighting.metal"
enum C3DColorMask {
    kC3DColorMaskRed    = 0x1 << 3,
    kC3DColorMaskGreen  = 0x1 << 2,
    kC3DColorMaskBlue   = 0x1 << 1,
    kC3DColorMaskAlpha  = 0x1 << 0
inline float4 colorFromMask(float4 col, int mask)
    switch (mask) {
        case kC3DColorMaskRed:                      return col.r;
        case kC3DColorMaskRed|kC3DColorMaskGreen:   return float4(col.rg, 0.f, 1.f);
        case kC3DColorMaskRed|kC3DColorMaskBlue:    return float4(col.rb, 0.f, 1.f);
        case kC3DColorMaskRed|kC3DColorMaskAlpha:   return float4(col.ra, 0.f, 1.f);
        case kC3DColorMaskGreen:                    return col.g;
        case kC3DColorMaskGreen|kC3DColorMaskBlue:  return float4(col.bg, 0.f, 1.f);
        case kC3DColorMaskGreen|kC3DColorMaskAlpha: return float4(col.ag, 0.f, 1.f);
        case kC3DColorMaskBlue:     return col.b;
        case kC3DColorMaskBlue|kC3DColorMaskAlpha:  return float4(col.ab, 0.f, 1.f);
        case kC3DColorMaskAlpha:    return col.a;
    }
    return col;
#ifndef USE_PBR
inline float3 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    float3 albedo = surface.diffuse.rgb * surface.ambientOcclusion;
    float3 color = lighting.diffuse * albedo;
#if defined(USE_AMBIENT_LIGHTING) && (defined(LOCK_AMBIENT_WITH_DIFFUSE) || defined(USE_AMBIENT_AS_AMBIENTOCCLUSION))
    color +=  lighting.ambient * albedo;
#endif
#ifdef USE_SELFILLUMINATION
    color += surface.diffuse.rgb * surface.selfIllumination.rgb;
#endif
    
    
    
#ifdef USE_SPECULAR
    float3 S = lighting.specular;
#elif defined(USE_REFLECTIVE)
    float3 S = float3(0.);
#endif
#ifdef USE_REFLECTIVE
    S += surface.reflective.rgb * surface.ambientOcclusion;
#endif
#ifdef USE_SPECULAR
    S *= surface.specular.rgb;
#endif
#if (defined(USE_SPECULAR) || defined(USE_REFLECTIVE)) && !defined(DISABLE_SPECULAR)
    color += S;
#endif
#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)
    color += surface.ambient.rgb * lighting.ambient;
#endif
#ifdef USE_EMISSION
    color += surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
    color *= surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
    color *= lighting.modulate;
#endif
    return color;
#endif
struct SCNShaderGeometry
    float4 position;
    float3 normal;
    float4 tangent;
    float4 color;
    float pointSize;
    float2 texcoords[8]; 
struct commonprofile_uniforms {
    
    float4 diffuseColor;
    float4 specularColor;
    float4 ambientColor;
    float4 emissionColor;
    float4 selfIlluminationColor;
    float4 reflectiveColor;
    float4 multiplyColor;
    float4 transparentColor;
    float clearCoat;
    float clearCoatRoughness;
    float3 clearCoatNormal;
    float metalness;
    
    float roughness;
    float diffuseIntensity;
    float specularIntensity;
    float normalIntensity;
    float ambientIntensity;
    float emissionIntensity;
    float selfIlluminationIntensity;
    float reflectiveIntensity;
    float multiplyIntensity;
    float transparentIntensity;
    
    float metalnessIntensity;
    float roughnessIntensity;
    float clearCoatIntensity;
    float clearCoatRoughnessIntensity;
    float clearCoatNormalIntensity;
    float displacementIntensity;
    float materialShininess;
    float selfIlluminationOcclusion;
    float transparency;
    float3 fresnel; 
#if USE_ARGUMENT_BUFFERS
    
    texture2d<float>    emissionTexture;
    sampler             emissionSampler;
    texture2d<float>    ambientTexture;
    sampler             ambientSampler;
    
    texture2d<float>    diffuseTexture;
    sampler             diffuseSampler;
    texture2d<float>    specularTexture;
    sampler             specularSampler;
#if defined(USE_REFLECTIVE_CUBEMAP)
    texturecube<float>  reflectiveTexture;
#else
    texture2d<float>    reflectiveTexture;
#endif
    sampler             reflectiveSampler;
    texture2d<float>    transparentTexture;
    sampler             transparentSampler;
    texture2d<float>    multiplyTexture;
    sampler             multiplySampler;
    
    texture2d<float>    normalTexture;
    sampler             normalSampler;
    texture2d<float>    selfIlluminationTexture;
    sampler             selfIlluminationSampler;
    texture2d<float>    metalnessTexture;
    sampler             metalnessSampler;
    texture2d<float>    roughnessTexture;
    sampler             roughnessSampler;
    texture2d<float>    displacementTexture;
    sampler             displacementSampler;
    
    
#endif 
#ifdef TEXTURE_TRANSFORM_COUNT
    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];
#endif
#ifdef USE_OPENSUBDIV
__OpenSubdivDeclPerGeometry__
__OpenSubdivDeclPerPatchType__
__OpenSubdivDeclShared__
struct osd_packed_vertex {
    packed_float3 position;
#if defined(OSD_USER_VARYING_DECLARE_PACKED)
    OSD_USER_VARYING_DECLARE_PACKED
#endif
#endif
#ifdef USE_DISPLACEMENT_MAP
static void applyDisplacement(texture2d<float>                 displacementTexture,
                              sampler                          displacementTextureSampler,
                              float2                           displacementTexcoord,
                              thread SCNShaderGeometry&        geometry,
                              constant commonprofile_uniforms& scn_commonprofile)
#ifdef USE_DISPLACEMENT_TEXTURE_COMPONENT
float altitude = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;
#ifdef USE_DISPLACEMENT_INTENSITY
altitude *= scn_commonprofile.displacementIntensity;
#endif
#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)
float3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));
geometry.position.xyz += geometry.normal * altitude;
float3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);
float3 h;
h.x = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;
h.y = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;
h.z = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord-offset.zy), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;
#ifdef USE_DISPLACEMENT_INTENSITY
h *= scn_commonprofile.displacementIntensity;
#endif
float3 n = normalize( float3( (h.x - h.y)/offset.x, 1., (h.x - h.z)/offset.y) );
geometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;
geometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));
#endif 
#else 
float3 displacement = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;
#ifdef USE_DISPLACEMENT_INTENSITY
displacement *= scn_commonprofile.displacementIntensity;
#endif
#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)
float3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));
geometry.position.xyz += geometry.tangent.xyz * displacement.x + geometry.normal.xyz * displacement.y + bitangent.xyz * displacement.z;
float3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);
float3 a = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;
float3 b = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz).rgb;
float3 c = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.zy).rgb;
#ifdef USE_DISPLACEMENT_INTENSITY
a *= scn_commonprofile.displacementIntensity;
b *= scn_commonprofile.displacementIntensity;
c *= scn_commonprofile.displacementIntensity;
#endif
b += offset.xzz;
c -= offset.zzy;
float3 n = (normalize( cross( b-a, c-a ) ));
geometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;
geometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));
#endif 
#endif 
#endif 
#ifdef USE_OUTLINE
static inline float hash(float2 p)
    const float2 kMod2 = float2(443.8975f, 397.2973f);
    p  = fract(p * kMod2);
    p += dot(p.xy, p.yx+19.19f);
    return fract(p.x * p.y);
#endif
    
using namespace NAMESPACE_HASH;
    
    
#if defined(USE_TESSELLATION)
struct scn_patch_t {
    patch_control_point<scn_vertex_t> controlPoints;
#endif
#if defined(USE_OPENSUBDIV)
#if OSD_IS_ADAPTIVE
[[ patch(quad, VERTEX_CONTROL_POINTS_PER_PATCH) ]]
#endif
#elif defined(USE_TESSELLATION)
[[ patch(triangle, 3) ]]
#endif
    
    
vertex commonprofile_io commonprofile_vert(
#if !defined(USE_TESSELLATION)
                                           scn_vertex_t                       in                               [[ stage_in ]]
                                           , uint                             scn_vertexID                     [[ vertex_id ]]
#else 
                                           
#ifdef USE_OPENSUBDIV
#if OSD_IS_ADAPTIVE
#if USE_STAGE_IN
                                           PatchInput                         patchInput                       [[ stage_in ]]
#else
                                           OsdVertexBufferSet                 patchInput
#endif
                                           , float2                           patchCoord                       [[ position_in_patch ]]
                                           , uint                             patchID                          [[ patch_id ]]
                                           , constant float&                  osdTessellationLevel             [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]]
#else 
                                           device const unsigned*             osdIndicesBuffer                 [[ buffer(INDICES_BUFFER_INDEX) ]]
                                           , device const osd_packed_vertex*  osdVertexBuffer                  [[ buffer(VERTEX_BUFFER_INDEX) ]]
                                           , uint                             vertexID                         [[ vertex_id ]]
#endif 
#if defined(OSD_FVAR_WIDTH)
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
                                           , constant uint32_t&               osdFaceVaryingChannelCount       [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX) ]]
                                           , device const OsdFVarChannelDesc* osdFaceVaryingChannelDescriptors [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX) ]]
                                           , constant uint32_t&               osdFaceVaryingPatchArrayIndex    [[ buffer(OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX) ]]
                                           , device const void*               osdFaceVaryingChannelsPackedData [[ buffer(OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX) ]]
#else
                                           , device const float*              osdFaceVaryingData               [[ buffer(OSD_FVAR_DATA_BUFFER_INDEX) ]]
                                           , device const int*                osdFaceVaryingIndices            [[ buffer(OSD_FVAR_INDICES_BUFFER_INDEX) ]]
#if OSD_IS_ADAPTIVE
                                           , device const packed_int3*        osdFaceVaryingPatchParams        [[ buffer(OSD_FVAR_PATCHPARAM_BUFFER_INDEX) ]]
                                           , constant packed_int4&            osdFaceVaryingPatchArray         [[ buffer(OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX) ]]
#endif
#endif 
#endif 
#else 
                                           scn_patch_t                        in                               [[ stage_in ]]
                                           , float3                           patchCoord                       [[ position_in_patch ]]
#endif 
#endif 
                                           
#ifdef USE_MULTIPLE_RENDERING
                                           , device const SCNSceneBuffer*     scn_frames                       [[ buffer(0) ]]
#else
                                           , constant SCNSceneBuffer&         scn_frame                        [[ buffer(0) ]]
#endif
#ifdef USE_INSTANCING
                                           
                                           , device const commonprofile_node* scn_nodeInstances                [[ buffer(1) ]]
#else
                                           , constant commonprofile_node&     scn_node                         [[ buffer(1) ]]
#endif
#ifdef USE_PER_VERTEX_LIGHTING
                                           , constant scn_light*              scn_lights                       [[ buffer(2) ]]
                                           , constant float4*                 u_shadowKernel
                                           , texture2d_array<float>           u_areaLightBakedDataTexture
#endif
                                           
                                           , constant commonprofile_uniforms& scn_commonprofile
                                           , uint                             scn_instanceID                   [[ instance_id ]]
                                           
#ifdef USE_POINT_RENDERING
                                           
                                           , constant float3&                 scn_pointSize
#endif
#ifdef USE_DISPLACEMENT_MAP
#if USE_ARGUMENT_BUFFERS
#define u_displacementTexture           scn_commonprofile.displacementTexture
#define u_displacementTextureSampler    scn_commonprofile.displacementSampler
#else
                                           , texture2d<float>                 u_displacementTexture
                                           , sampler                          u_displacementTextureSampler
#endif 
#endif 
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
                                           __VertexExtraArguments__
#endif
                                           )
    commonprofile_io out;
    
#ifdef USE_MULTIPLE_RENDERING
    
    out.sliceIndex = scn_instanceID % USE_MULTIPLE_RENDERING;
    
    device const SCNSceneBuffer& scn_frame = scn_frames[0];
    device const SCNSceneBuffer& scn_frame_slice = scn_frames[out.sliceIndex];
#ifdef USE_INSTANCING
    device const commonprofile_node& scn_node = scn_nodeInstances[scn_instanceID / USE_MULTIPLE_RENDERING];
#endif
    
#else
    
#ifdef USE_INSTANCING
    device const commonprofile_node& scn_node = scn_nodeInstances[scn_instanceID];
#endif
    
#endif
    
    
#ifdef USE_TESSELLATION
    uint scn_vertexID; 
    scn_vertexID = 0;
#endif
    
    
    
    
    
    SCNShaderGeometry _geometry;
    
#if !defined(USE_TESSELLATION)
    
    
    _geometry.position = float4(in.position, 1.f);
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
    _geometry.normal = in.normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = in.tangent;
#endif
#ifdef NEED_IN_TEXCOORD0
    _geometry.texcoords[0] = in.texcoord0;
#endif
#ifdef NEED_IN_TEXCOORD1
    _geometry.texcoords[1] = in.texcoord1;
#endif
#ifdef NEED_IN_TEXCOORD2
    _geometry.texcoords[2] = in.texcoord2;
#endif
#ifdef NEED_IN_TEXCOORD3
    _geometry.texcoords[3] = in.texcoord3;
#endif
#ifdef NEED_IN_TEXCOORD4
    _geometry.texcoords[4] = in.texcoord4;
#endif
#ifdef NEED_IN_TEXCOORD5
    _geometry.texcoords[5] = in.texcoord5;
#endif
#ifdef NEED_IN_TEXCOORD6
    _geometry.texcoords[6] = in.texcoord6;
#endif
#ifdef NEED_IN_TEXCOORD7
    _geometry.texcoords[7] = in.texcoord7;
#endif
#ifdef HAS_VERTEX_COLOR
    _geometry.color = in.color;
#elif USE_VERTEX_COLOR
    _geometry.color = float4(1.);
#endif
    
#else 
    
#ifdef USE_OPENSUBDIV
#if OSD_IS_ADAPTIVE
#if USE_STAGE_IN
    int3 patchParam = patchInput.patchParam;
#else
    int3 patchParam = patchInput.patchParamBuffer[patchID];
#endif
    
    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);
    float tessellationLevel = min(osdTessellationLevel, (float)OSD_MAX_TESS_LEVEL) / exp2((float)refinementLevel - 1);
    
    OsdPatchVertex patchVertex = OsdComputePatch(tessellationLevel, patchCoord, patchID, patchInput);
    
#if defined(OSD_FVAR_WIDTH)
    int patchIndex = OsdGetPatchIndex(patchID);
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);
#else
    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingIndices, osdFaceVaryingData, osdFaceVaryingPatchParams, osdFaceVaryingPatchArray);
#endif
#endif
    
    _geometry.position = float4(patchVertex.position, 1.f);
    
#if defined(USE_NORMAL)
    _geometry.normal = patchVertex.normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = float4(patchVertex.tangent, -1.f);
    
#endif
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[0] = patchVertex.texcoord0;
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[1] = patchVertex.texcoord1;
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[2] = patchVertex.texcoord2;
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[3] = patchVertex.texcoord3;
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[4] = patchVertex.texcoord4;
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[5] = patchVertex.texcoord5;
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[6] = patchVertex.texcoord6;
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[7] = patchVertex.texcoord7;
#endif
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.color = patchVertex.color;
#endif
    
#else 
    
#if OSD_PATCH_QUADS
    const uint primitiveIndex = vertexID / 6;
#ifdef USE_NORMAL
    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 0]].position;
    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 1]].position;
    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 2]].position;
    float3 normal = normalize(cross(p2 - p1, p0 - p1));
#endif
    const uint triangleIndices[6] = { 0, 1, 2, 0, 2, 3 };
    const uint quadVertexIndex = triangleIndices[vertexID % 6];
    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + quadVertexIndex]];
#elif OSD_PATCH_TRIANGLES
    const uint primitiveIndex = vertexID / 3;
#ifdef USE_NORMAL
    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 0]].position;
    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 1]].position;
    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 2]].position;
    float3 normal = normalize(cross(p2 - p1, p0 - p1));
#endif
    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[vertexID]];
#endif
    
    float3 position = osdVertex.position;
    
#if defined(OSD_FVAR_WIDTH)
    int patchIndex = OsdGetPatchIndex(primitiveIndex);
#if OSD_PATCH_QUADS
    float2 quadUVs[4] = { float2(0,0), float2(1,0), float2(1,1), float2(0,1) };
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);
#else
    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingIndices, osdFaceVaryingData);
#endif
#elif OSD_PATCH_TRIANGLES
    
#endif
#endif 
    
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[0] = osdVertex.texcoord0;
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[1] = osdVertex.texcoord1;
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[2] = osdVertex.texcoord2;
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[3] = osdVertex.texcoord3;
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[4] = osdVertex.texcoord4;
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[5] = osdVertex.texcoord5;
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[6] = osdVertex.texcoord6;
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[7] = osdVertex.texcoord7;
#endif
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.color = osdVertex.color;
#endif
    
    _geometry.position = float4(position, 1.f);
#ifdef USE_NORMAL
    _geometry.normal = normal;
#endif
    
#endif 
    
#else 
    
    
    
    
    
#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE) || defined(TESSELLATION_SMOOTHING_MODE_PHONG)
    float3 P0 = in.controlPoints[0].position;
    float3 P1 = in.controlPoints[1].position;
    float3 P2 = in.controlPoints[2].position;
    float3 N0 = in.controlPoints[0].normal;
    float3 N1 = in.controlPoints[1].normal;
    float3 N2 = in.controlPoints[2].normal;
#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)
    float3 position, normal;
    scn_smooth_geometry_pn_triangle(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);
#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)
    float3 position, normal;
    scn_smooth_geometry_phong(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);
#endif
    _geometry.position = float4(position, 1.f);
#ifdef USE_NORMAL
    _geometry.normal = normal;
#endif
#else 
    
    _geometry.position = float4(scn::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.f);
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
    _geometry.normal = normalize(scn::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));
#endif
#endif 
    
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = normalize(scn::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));
#endif
#ifdef NEED_IN_TEXCOORD0
    _geometry.texcoords[0] = scn::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD1
    _geometry.texcoords[1] = scn::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD2
    _geometry.texcoords[2] = scn::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD3
    _geometry.texcoords[3] = scn::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD4
    _geometry.texcoords[4] = scn::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD5
    _geometry.texcoords[5] = scn::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD6
    _geometry.texcoords[6] = scn::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD7
    _geometry.texcoords[7] = scn::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);
#endif
#ifdef HAS_VERTEX_COLOR
    _geometry.color = scn::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord);
#elif USE_VERTEX_COLOR
    _geometry.color = float4(1.);
#endif
    
#endif 
    
#endif 
    
#ifdef USE_POINT_RENDERING
    _geometry.pointSize = scn_pointSize.x;
#endif
    
#ifdef USE_TEXCOORD
    __VertexDoVertexOnlyTexcoord__
#endif
    
#ifdef USE_DISPLACEMENT_MAP
    applyDisplacement(u_displacementTexture, u_displacementTextureSampler, _displacementTexcoord, _geometry, scn_commonprofile);
#endif
    
    
    
    
    
#ifdef USE_SKINNING
#if !defined(USE_TESSELLATION)
    {
        float3 pos = 0.f;
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
        float3 nrm = 0.f;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        float3 tgt = 0.f;
#endif
        for (int i = 0; i < MAX_BONE_INFLUENCES; ++i) {
#if MAX_BONE_INFLUENCES == 1
            float weight = 1.f;
#else
            float weight = in.skinningWeights[i];
            if (weight <= 0.f)
                continue;
            
#endif
            int idx = int(in.skinningJoints[i]) * 3;
            float4x4 jointMatrix = float4x4(scn_node.skinningJointMatrices[idx],
                                            scn_node.skinningJointMatrices[idx+1],
                                            scn_node.skinningJointMatrices[idx+2],
                                            float4(0., 0., 0., 1.));
            
            pos += (_geometry.position * jointMatrix).xyz * weight;
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
            nrm += _geometry.normal * scn::mat3(jointMatrix) * weight;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
            tgt += _geometry.tangent.xyz * scn::mat3(jointMatrix) * weight;
#endif
        }
        
        _geometry.position.xyz = pos;
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
        _geometry.normal = nrm;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        _geometry.tangent.xyz = tgt;
#endif
    }
    
#else 
    
#if !defined(USE_OPENSUBDIV)
    {
        float3 pos[3] = {0.f, 0.f, 0.f};
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
        float3 nrm[3] = {0.f, 0.f, 0.f};
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        float3 tgt[3] = {0.f, 0.f, 0.f};
#endif
        for (int controlPointIndex = 0; controlPointIndex < 3; ++controlPointIndex) {
            for (int i = 0; i < MAX_BONE_INFLUENCES; ++i) {
#if MAX_BONE_INFLUENCES == 1
                float weight = 1.f;
#else
                float weight = in.controlPoints[controlPointIndex].skinningWeights[i];
                if (weight <= 0.f)
                    continue;
                
#endif
                int idx = int(in.controlPoints[controlPointIndex].skinningJoints[i]) * 3;
                float4x4 jointMatrix = float4x4(scn_node.skinningJointMatrices[idx],
                                                scn_node.skinningJointMatrices[idx+1],
                                                scn_node.skinningJointMatrices[idx+2],
                                                float4(0., 0., 0., 1.));
                
                pos[controlPointIndex] += (_geometry.position * jointMatrix).xyz * weight;
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
                nrm[controlPointIndex] += _geometry.normal * scn::mat3(jointMatrix) * weight;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
                tgt[controlPointIndex] += _geometry.tangent.xyz * scn::mat3(jointMatrix) * weight;
#endif
            }
        }
        
        _geometry.position.xyz = scn::barycentric_mix(pos[0], pos[1], pos[2], patchCoord);
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
        _geometry.normal = scn::barycentric_mix(nrm[0], nrm[1], nrm[2], patchCoord);
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        _geometry.tangent.xyz = scn::barycentric_mix(tgt[0], tgt[1], tgt[2], patchCoord);
#endif
    }
#endif 
#endif 
#endif 
    
    
#ifdef USE_DISPLACEMENT_MAP
    out.displacementTexcoord = _displacementTexcoord;
#endif
    
    
    
    
    
#ifdef USE_GEOMETRY_MODIFIER
    
    __DoGeometryModifier__
    
#endif
    
    
    
    
    
    
#if defined(USE_POSITION) || (defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)
    SCNShaderSurface _surface;
#endif
#if defined(USE_POSITION) || defined(USE_INSTANCING)
#ifdef USE_MULTIPLE_RENDERING
    _surface.position = (scn_frame.viewTransform * (scn_node.modelTransform * _geometry.position)).xyz;
#else
    _surface.position = (scn_node.modelViewTransform * _geometry.position).xyz;
#endif
#endif
#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)
#ifdef USE_MULTIPLE_RENDERING
#ifdef HINT_UNIFORM_SCALE
    _surface.normal = (scn_frame.viewTransform * scn_node.modelTransform * float4(_geometry.normal,0.)).xyz;
#else
    _surface.normal = normalize( (scn_frame.inverseTransposeViewTransform * scn_node.modelTransform * float4(_geometry.normal,0.)).xyz );
#endif
#else
    float3x3 nrmTransform = scn::mat3(scn_node.modelViewTransform);
#ifdef HINT_UNIFORM_SCALE
    _surface.normal = nrmTransform * _geometry.normal;
#else
    float3 invScaleSquared = 1.f / float3(length_squared(nrmTransform[0]), length_squared(nrmTransform[1]), length_squared(nrmTransform[2]));
    _surface.normal = normalize(nrmTransform * (_geometry.normal * invScaleSquared));
#endif
#endif
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
#ifdef USE_MULTIPLE_RENDERING
    _surface.tangent = normalize( (scn_frame.viewTransform * scn_node.modelTransform * float4(_geometry.tangent.xyz, 0.f)).xyz );
#else
    _surface.tangent = normalize(scn::mat3(scn_node.modelViewTransform) * _geometry.tangent.xyz);
#endif
    _surface.bitangent = _geometry.tangent.w * cross(_surface.tangent, _surface.normal); 
    
#endif
    
    
#ifdef USE_VIEW
    _surface.view = normalize(-_surface.position);
#endif
    
    
    
    
    
#ifdef USE_PER_VERTEX_LIGHTING
    
    SCNShaderLightingContribution _lightingContribution(_surface, out);
    _lightingContribution.diffuse = 0.;
  #ifdef USE_SPECULAR
    _lightingContribution.specular = 0.;
    _surface.shininess = scn_commonprofile.materialShininess;
  #endif
    __VertexDoLighting__
    out.diffuse = _lightingContribution.diffuse;
  #ifdef USE_SPECULAR
    out.specular = _lightingContribution.specular;
  #endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
    out.position = _surface.position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)
    out.normal = _surface.normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    out.tangent = _surface.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    out.bitangent = _surface.bitangent;
#endif
#ifdef USE_VERTEX_COLOR
    out.vertexColor = _geometry.color;
#endif
#if DEBUG_PIXEL
    out.uv0 = in.texcoord0;
#endif
#ifdef USE_TEXCOORD
    __VertexDoTexcoord__
#endif
    
    
    
    
    
#if defined(USE_POSITION) || defined(USE_INSTANCING)
#ifdef USE_MULTIPLE_RENDERING
    out.fragmentPosition = scn_frame_slice.viewProjectionTransform * scn_node.modelTransform * _geometry.position;
#else
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.);
#endif
#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) 
#ifdef USE_MULTIPLE_RENDERING
    out.fragmentPosition = scn_frame_slice.viewProjectionTransform * scn_node.modelTransform * _geometry.position;
#else
    out.fragmentPosition = scn_node.modelViewProjectionTransform * _geometry.position;
#endif
#endif
    
#ifdef USE_NODE_OPACITY
    out.nodeOpacity = scn_node.nodeOpacity;
#endif
    
#ifdef USE_POINT_RENDERING
    float screenSize = _geometry.pointSize / out.fragmentPosition.w;
    out.fragmentSize = clamp(screenSize, scn_pointSize.y, scn_pointSize.z);
#endif
    
#ifdef USE_MOTIONBLUR
    float4 lastFrameFragmentPosition = scn_frame.lastFrameViewProjectionTransform * scn_node.lastFrameModelTransform * _geometry.position;
    out.mv_fragment = out.fragmentPosition.xyw;
    out.mv_lastFragment = lastFrameFragmentPosition.xyw;
#endif
    
#ifdef USE_OUTLINE
out.outlineHash = hash(scn_node.modelTransform[3].xy)+1.f/255.f;
#endif
    
    return out;
struct SCNOutput
    float4 color [[ color(0) ]];
#ifdef USE_COLOR1_OUTPUT
    half4 color1 [[ color(1) ]];
#endif
#ifdef USE_NORMALS_OUTPUT
    half4 normals [[ color(2) ]];
#endif
#ifdef USE_MOTIONBLUR
    half4 motionblur [[ color(3) ]];
#endif
#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT
    half4 reflectanceRoughnessOutput [[ color(4) ]];
#endif
#ifdef USE_RADIANCE_OUTPUT
    half4 radiance [[ color(5) ]];
#endif
fragment SCNOutput commonprofile_frag(commonprofile_io                   in                          [[ stage_in  ]]
                                      , constant commonprofile_uniforms& scn_commonprofile           [[ buffer(0) ]]
#ifdef USE_MULTIPLE_RENDERING
                                      , device const SCNSceneBuffer*     scn_frames                  [[ buffer(1) ]]
#else
                                      , constant SCNSceneBuffer&         scn_frame                   [[ buffer(1) ]]
#endif
                                      , constant commonprofile_node&     scn_node                    [[ buffer(2) ]]
#ifdef USE_PER_PIXEL_LIGHTING
                                      , constant scn_light*              scn_lights                  [[ buffer(3) ]]
                                      , constant float4*                 u_shadowKernel
                                      , texture2d_array<float>           u_areaLightBakedDataTexture
#ifdef C3D_SUPPORT_CUBE_ARRAY
                                      , texturecube_array<half>          u_reflectionProbeTexture
#else
                                      , texture2d_array<half>            u_reflectionProbeTexture
#endif
                                      , texture3d<ushort>                u_clusterTexture
#ifdef C3D_USE_TEXTURE_FOR_LIGHT_INDICES
                                      , texture1d<ushort>                u_lightIndicesTexture
#else
                                      , constant C3DLightIndexType*      u_lightIndicesBuffer
#endif
#endif
#if USE_ARGUMENT_BUFFERS
#define u_emissionTexture               scn_commonprofile.emissionTexture
#define u_emissionTextureSampler        scn_commonprofile.emissionSampler
#define u_ambientTexture                scn_commonprofile.ambientTexture
#define u_ambientTextureSampler         scn_commonprofile.ambientSampler
#define u_diffuseTexture                scn_commonprofile.diffuseTexture
#define u_diffuseTextureSampler         scn_commonprofile.diffuseSampler
#define u_specularTexture               scn_commonprofile.specularTexture
#define u_specularTextureSampler        scn_commonprofile.specularSampler
#define u_reflectiveTexture             scn_commonprofile.reflectiveTexture
#define u_reflectiveTextureSampler      scn_commonprofile.reflectiveSampler
#define u_transparentTexture            scn_commonprofile.transparentTexture
#define u_transparentTextureSampler     scn_commonprofile.transparentSampler
#define u_multiplyTexture               scn_commonprofile.multiplyTexture
#define u_multiplyTextureSampler        scn_commonprofile.multiplySampler
#define u_normalTexture                 scn_commonprofile.normalTexture
#define u_normalTextureSampler          scn_commonprofile.normalSampler
#define u_selfIlluminationTexture       scn_commonprofile.selfIlluminationTexture
#define u_selfIlluminationTextureSampler scn_commonprofile.selfIlluminationSampler
#define u_metalnessTexture              scn_commonprofile.metalnessTexture
#define u_metalnessTextureSampler       scn_commonprofile.metalnessSampler
#define u_roughnessTexture              scn_commonprofile.roughnessTexture
#define u_roughnessTextureSampler       scn_commonprofile.roughnessSampler
#else
#ifdef USE_EMISSION_MAP
                                      , texture2d<float>              u_emissionTexture
                                      , sampler                       u_emissionTextureSampler
#endif
#ifdef USE_AMBIENT_MAP
                                      , texture2d<float>              u_ambientTexture
                                      , sampler                       u_ambientTextureSampler
#endif
#ifdef USE_DIFFUSE_MAP
                                      , texture2d<float>              u_diffuseTexture
                                      , sampler                       u_diffuseTextureSampler
#endif
#ifdef USE_SPECULAR_MAP
                                      , texture2d<float>              u_specularTexture
                                      , sampler                       u_specularTextureSampler
#endif
#ifdef USE_REFLECTIVE_MAP
                                      , texture2d<float>              u_reflectiveTexture
                                      , sampler                       u_reflectiveTextureSampler
#elif defined(USE_REFLECTIVE_CUBEMAP)
                                      , texturecube<float>            u_reflectiveTexture
                                      , sampler                       u_reflectiveTextureSampler
#endif
#ifdef USE_TRANSPARENT_MAP
                                      , texture2d<float>              u_transparentTexture
                                      , sampler                       u_transparentTextureSampler
#endif
#ifdef USE_MULTIPLY_MAP
                                      , texture2d<float>              u_multiplyTexture
                                      , sampler                       u_multiplyTextureSampler
#endif
#ifdef USE_NORMAL_MAP
                                      , texture2d<float>              u_normalTexture
                                      , sampler                       u_normalTextureSampler
#endif
#ifdef USE_SELFILLUMINATION_MAP
                                      , texture2d<float>              u_selfIlluminationTexture
                                      , sampler                       u_selfIlluminationTextureSampler
#endif
#ifdef USE_DISPLACEMENT_MAP
                                      , texture2d<float>              u_displacementTexture
                                      , sampler                       u_displacementTextureSampler
#endif
#ifdef USE_PBR
#ifdef USE_METALNESS_MAP
                                      , texture2d<float>              u_metalnessTexture
                                      , sampler                       u_metalnessTextureSampler
#endif
#ifdef USE_ROUGHNESS_MAP
                                      , texture2d<float>              u_roughnessTexture
                                      , sampler                       u_roughnessTextureSampler
#endif
#ifdef USE_CLEARCOAT_MAP
                                      , texture2d<float>              u_clearCoatTexture
                                      , sampler                       u_clearCoatTextureSampler
#endif
#ifdef USE_CLEARCOATROUGHNESS_MAP
                                      , texture2d<float>              u_clearCoatRoughnessTexture
                                      , sampler                       u_clearCoatRoughnessTextureSampler
#endif
#ifdef USE_CLEARCOATNORMAL_MAP
                                      , texture2d<float>              u_clearCoatNormalTexture
                                      , sampler                       u_clearCoatNormalTextureSampler
#endif
#endif 
#endif 
#ifdef USE_PBR
                                      , texturecube<float>            u_radianceTexture
                                      , texture2d<float>              u_specularDFGTexture
#if !defined(USE_SELFILLUMINATION_MAP)
                                      , texturecube<float>            u_irradianceTexture
#endif
#endif 
#ifdef USE_SSAO
                                      , texture2d<float>              u_ssaoTexture
#endif
#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS
                                      __FragmentExtraArguments__
#endif
#if defined(USE_DOUBLE_SIDED)
                                      , bool                          isFrontFacing                    [[front_facing]]
#endif
#ifdef USE_POINT_RENDERING
                                      , float2                        pointCoord                       [[point_coord]]
#endif
                                      )
#ifdef USE_MULTIPLE_RENDERING
    device const SCNSceneBuffer& scn_frame = scn_frames[0];
    device const SCNSceneBuffer& scn_frame_slice = scn_frames[in.sliceIndex];
#endif
    SCNOutput _output;
    
    
    
    
    SCNShaderSurface _surface;
#ifdef USE_TEXCOORD
    __FragmentDoTexcoord__
#endif
    _surface.ambientOcclusion = 1.f; 
#ifdef USE_AMBIENT_MAP
    #ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
        _surface.ambientOcclusion = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord).r;
        #ifdef USE_AMBIENT_INTENSITY
            _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, scn_commonprofile.ambientIntensity));
        #endif
    #else 
        _surface.ambient = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);
        #ifdef USE_AMBIENT_INTENSITY
            _surface.ambient *= scn_commonprofile.ambientIntensity;
        #endif
    #endif 
#if defined(USE_AMBIENT_TEXTURE_COMPONENT)
    _surface.ambient = colorFromMask(_surface.ambient, USE_AMBIENT_TEXTURE_COMPONENT).r;
#endif
#elif defined(USE_AMBIENT_COLOR)
    _surface.ambient = scn_commonprofile.ambientColor;
#elif defined(USE_AMBIENT)
    _surface.ambient = float4(0.);
#endif
#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)
    _surface.ambient *= in.vertexColor;
#endif
#if  defined(USE_SSAO)
    _surface.ambientOcclusion *= u_ssaoTexture.sample( sampler(filter::linear), in.fragmentPosition.xy * scn_frame.inverseResolution.xy ).x;
#endif
    
#ifdef USE_DIFFUSE_MAP
    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);
#if defined(USE_DIFFUSE_TEXTURE_COMPONENT)
    _surface.diffuse = colorFromMask(_surface.diffuse, USE_DIFFUSE_TEXTURE_COMPONENT);
#endif
#ifdef USE_DIFFUSE_INTENSITY
    _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
    _surface.diffuse = scn_commonprofile.diffuseColor;
#else
    _surface.diffuse = float4(0.f,0.f,0.f,1.f);
#endif
#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)
    _surface.diffuse.rgb    *= in.vertexColor.rgb;
    _surface.diffuse        *= in.vertexColor.a; 
#endif
#ifdef USE_SPECULAR_MAP
    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);
#if defined(USE_SPECULAR_TEXTURE_COMPONENT)
    _surface.specular = colorFromMask(_surface.specular, USE_SPECULAR_TEXTURE_COMPONENT);
#endif
#ifdef USE_SPECULAR_INTENSITY
    _surface.specular *= scn_commonprofile.specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
    _surface.specular = scn_commonprofile.specularColor;
#elif defined(USE_SPECULAR)
    _surface.specular = float4(0.f);
#endif
    
#ifdef USE_CLEARCOAT_MAP
    _surface.clearCoat = u_clearCoatTexture.sample(u_clearCoatTextureSampler, _surface.clearCoatTexcoord).r;
#if defined(USE_CLEARCOAT_TEXTURE_COMPONENT)
    _surface.clearCoat = colorFromMask(_surface.clearCoat, USE_CLEARCOAT_TEXTURE_COMPONENT).r;
#endif
#ifdef USE_CLEARCOAT_INTENSITY
    _surface.clearCoat *= scn_commonprofile.clearCoatIntensity;
#endif
#elif defined(USE_CLEARCOAT_COLOR)
    _surface.clearCoat = scn_commonprofile.clearCoat;
#elif defined(USE_CLEARCOAT)
    _surface.clearCoat = 0.f;
#endif
    
#ifdef USE_CLEARCOATROUGHNESS_MAP
#if defined(USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT)
    _surface.clearCoatRoughness = colorFromMask(u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord), USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT).r;
#else
    _surface.clearCoatRoughness = u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord).r;
#endif
#ifdef USE_CLEARCOATROUGHNESS_INTENSITY
    _surface.clearCoatRoughness *= scn_commonprofile.clearCoatRoughnessIntensity;
#endif
#elif defined(USE_CLEARCOATROUGHNESS_COLOR)
    _surface.clearCoatRoughness = scn_commonprofile.clearCoatRoughness;
#else
    _surface.clearCoatRoughness = 0.03f;
#endif
#ifdef USE_EMISSION_MAP
    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);
#if defined(USE_EMISSION_TEXTURE_COMPONENT)
    _surface.emission = colorFromMask(_surface.emission, USE_EMISSION_TEXTURE_COMPONENT);
#endif
#ifdef USE_EMISSION_INTENSITY
    _surface.emission *= scn_commonprofile.emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
    _surface.emission = scn_commonprofile.emissionColor;
#elif defined(USE_EMISSION)
    _surface.emission = float4(0.);
#endif
#ifdef USE_SELFILLUMINATION_MAP
    _surface.selfIllumination = u_selfIlluminationTexture.sample(u_selfIlluminationTextureSampler, _surface.selfIlluminationTexcoord);
#if defined(USE_SELFILLUMINATION_TEXTURE_COMPONENT)
    _surface.selfIllumination = colorFromMask(_surface.selfIllumination, USE_SELFILLUMINATION_TEXTURE_COMPONENT);
#endif
#ifdef USE_SELFILLUMINATION_INTENSITY
    _surface.selfIllumination *= scn_commonprofile.selfIlluminationIntensity;
#endif
#elif defined(USE_SELFILLUMINATION_COLOR)
    _surface.selfIllumination = scn_commonprofile.selfIlluminationColor;
#elif defined(USE_SELFILLUMINATION)
    _surface.selfIllumination = float4(0.);
#endif
#ifdef USE_MULTIPLY_MAP
    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);
#if defined(USE_MULTIPLY_TEXTURE_COMPONENT)
    _surface.multiply = colorFromMask(_surface.multiply, USE_MULTIPLY_TEXTURE_COMPONENT);
#endif
#ifdef USE_MULTIPLY_INTENSITY
    _surface.multiply = mix(float4(1.), _surface.multiply, scn_commonprofile.multiplyIntensity);
#endif
#elif defined(USE_MULTIPLY_COLOR)
    _surface.multiply = scn_commonprofile.multiplyColor;
#elif defined(USE_MULTIPLY)
    _surface.multiply = float4(1.);
#endif
#ifdef USE_TRANSPARENT_MAP
    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);
#if defined(USE_TRANSPARENT_TEXTURE_COMPONENT)
    _surface.transparent = colorFromMask(_surface.transparent, USE_TRANSPARENT_TEXTURE_COMPONENT);
#endif
#ifdef USE_TRANSPARENT_INTENSITY
    _surface.transparent *= scn_commonprofile.transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
    _surface.transparent = scn_commonprofile.transparentColor;
#elif defined(USE_TRANSPARENT)
    _surface.transparent = float4(1.f);
#endif
    
#ifdef USE_METALNESS_MAP
#if defined(USE_METALNESS_TEXTURE_COMPONENT)
    _surface.metalness = colorFromMask(u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord), USE_METALNESS_TEXTURE_COMPONENT).r;
#else
    _surface.metalness = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord).r;
#endif
#ifdef USE_METALNESS_INTENSITY
    _surface.metalness *= scn_commonprofile.metalnessIntensity;
#endif
#elif defined(USE_METALNESS_COLOR)
    _surface.metalness = scn_commonprofile.metalness;
#else
    _surface.metalness = 0.f;
#endif
    
#ifdef USE_ROUGHNESS_MAP
#if defined(USE_ROUGHNESS_TEXTURE_COMPONENT)
    _surface.roughness = colorFromMask(u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord), USE_ROUGHNESS_TEXTURE_COMPONENT).r;
#else
    _surface.roughness = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;
#endif
#ifdef USE_ROUGHNESS_INTENSITY
    _surface.roughness *= scn_commonprofile.roughnessIntensity;
#endif
#elif defined(USE_ROUGHNESS_COLOR)
    _surface.roughness = scn_commonprofile.roughness;
#else
    _surface.roughness = 0.f;
#endif
#if (defined USE_POSITION) && (USE_POSITION == 2)
    _surface.position = in.position;
#endif
#if (defined USE_NORMAL) && (USE_NORMAL == 2)
#if defined(HAS_NORMAL) || defined(USE_OPENSUBDIV)
#ifdef USE_DOUBLE_SIDED
    _surface.geometryNormal = normalize(in.normal.xyz) * (isFrontFacing ? 1.f : -1.f );
#else
    _surface.geometryNormal = normalize(in.normal.xyz);
#endif
#else 
    _surface.geometryNormal = normalize( cross(dfdy( _surface.position ), dfdx( _surface.position ) ));
#endif
    _surface.normal = _surface.geometryNormal;
    _surface.clearCoatNormal = _surface.geometryNormal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    _surface.tangent = in.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    _surface.bitangent = in.bitangent;
#endif
#if (defined USE_VIEW) && (USE_VIEW == 2)
    _surface.view = normalize(-in.position);
#endif
#if defined(USE_NORMAL_MAP)
    {
        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);
#ifdef USE_NORMAL_MAP
#if defined(USE_NORMAL_TEXTURE_COMPONENT)
        _surface._normalTS.xy = colorFromMask(u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord), USE_NORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;
        _surface._normalTS.z = sqrt(1.f - saturate(length_squared(_surface._normalTS.xy)));
#else
        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;
        _surface._normalTS = _surface._normalTS * 2.f - 1.f;
#endif
#ifdef USE_NORMAL_INTENSITY
        _surface._normalTS = mix(float3(0.f, 0.f, 1.f), _surface._normalTS, scn_commonprofile.normalIntensity);
#endif
#else
        _surface._normalTS = float3(0.f, 0.f, 1.f);
#endif
        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS.xyz );
    }
#else
    _surface._normalTS = float3(0.f, 0.f, 1.f);
#endif
#if defined(USE_CLEARCOATNORMAL_MAP)
    {
        
        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.geometryNormal);
#ifdef USE_CLEARCOATNORMAL_MAP
#if defined(USE_CLEARCOATNORMAL_TEXTURE_COMPONENT)
        _surface._clearCoatNormalTS.xy = colorFromMask(u_clearCoatNormalTexture.sample(u_clearCoatnormalTextureSampler, _surface.clearCoatNormalTexcoord), USE_CLEARCOATNORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;
        _surface._clearCoatNormalTS.z = sqrt(1.f - saturate(length_squared(_surface._clearCoatNormalTS.xy)));
#else
        _surface._clearCoatNormalTS = u_clearCoatNormalTexture.sample(u_clearCoatNormalTextureSampler, _surface.clearCoatNormalTexcoord).rgb;
        _surface._clearCoatNormalTS = _surface._clearCoatNormalTS * 2.f - 1.f;
#endif
#ifdef USE_CLEARCOATNORMAL_INTENSITY
        _surface._clearCoatNormalTS = mix(float3(0.f, 0.f, 1.f), _surface._clearCoatNormalTS, scn_commonprofile.clearCoatNormalIntensity);
#endif
#else
        _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);
#endif
        _surface.clearCoatNormal.rgb = normalize(ts2vs * _surface._clearCoatNormalTS.xyz );
    }
#else
    _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);
#endif
    
#ifdef USE_REFLECTIVE_MAP
    float3 refl = reflect( -_surface.view, _surface.normal );
    float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.f)*(refl.z+1.f));
    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);
#if defined(USE_REFLECTIVE_TEXTURE_COMPONENT)
    _surface.reflective = colorFromMask(_surface.reflective, USE_REFLECTIVE_TEXTURE_COMPONENT).r;
#endif
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective *= scn_commonprofile.reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_CUBEMAP)
    float3 refl = reflect( _surface.position, _surface.normal );
    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); 
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective *= scn_commonprofile.reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_COLOR)
    _surface.reflective = scn_commonprofile.reflectiveColor;
#elif defined(USE_REFLECTIVE)
    _surface.reflective = float4(0.);
#endif
#ifdef USE_FRESNEL
    _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);
    _surface.reflective *= _surface.fresnel;
#endif
#ifdef USE_SHININESS
    _surface.shininess = scn_commonprofile.materialShininess;
#endif
    
    
    
    
    
#ifdef USE_SURFACE_MODIFIER
    
    __DoSurfaceModifier__
    
#endif
    
    
    
    
    
    SCNShaderLightingContribution _lightingContribution(_surface, in);
#ifdef USE_LIGHT_MODIFIER
    __LightModifierCopyDecl__
#endif
#ifdef USE_AMBIENT_LIGHTING
    _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;
#endif
#ifdef USE_LIGHTING
#ifdef USE_PER_PIXEL_LIGHTING
#ifdef USE_CLUSTERED_LIGHTING
    uint3 clusterIndex;
    clusterIndex.xy = uint2(in.fragmentPosition.xy * scn_frame.clusterScale.xy); 
    clusterIndex.z = in.position.z * scn_frame.clusterScale.z + scn_frame.clusterScale.w; 
    
    
    ushort4 cluster_offset_count = u_clusterTexture.read(clusterIndex);
    int lid = cluster_offset_count.x;
#endif
#ifdef USE_PBR
    _lightingContribution.prepareForPBR(u_specularDFGTexture, scn_commonprofile.selfIlluminationOcclusion);
#ifdef USE_CLEARCOAT
    _lightingContribution.prepareForPBRClearCoat(u_specularDFGTexture);
#endif
    
    
#ifdef USE_SELFILLUMINATION
    _lightingContribution.add_irradiance_from_selfIllum();
#else
#ifdef USE_PROBES_LIGHTING 
    _lightingContribution.add_global_irradiance_from_sh(scn_frame.viewToCubeTransform, scn_node.shCoefficients);
#else
    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);
#endif
#endif
    
#ifndef DISABLE_SPECULAR
#ifdef C3D_USE_REFLECTION_PROBES
    int probe_count = (cluster_offset_count.z & 0xff);
    for (int i = 0 ; i < probe_count; ++i, ++lid) {
        _lightingContribution.add_local_probe(scn_lights[LightIndex(lid)], u_reflectionProbeTexture);
    }
#if PROBES_NORMALIZATION
#if PROBES_OUTER_BLENDING
    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / max(1.f, _lightingContribution.probesWeightedSum.a);
#else
    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / _lightingContribution.probesWeightedSum.a;
#endif
    float globalFactor = saturate(1.f - _lightingContribution.probesWeightedSum.a);
#else
    float globalFactor = _lightingContribution.probeRadianceRemainingFactor;
#endif
    _lightingContribution.add_global_probe(scn_frame.viewToCubeTransform, globalFactor * scn_frame.environmentIntensity,
                                           u_reflectionProbeTexture);
#else 
   _lightingContribution.add_global_probe(u_radianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);
    
#ifdef USE_CLEARCOAT
    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);
#endif
    
#endif 
#endif 
#endif 
    #if DEBUG_PIXEL
        switch (DEBUG_PIXEL) {
            case 1: _output.color = float4(_surface.normal * 0.5f + 0.5f, 1.f); break;
            case 2: _output.color = float4(_surface.geometryNormal * 0.5f + 0.5f, 1.f); break;
            case 3: _output.color = float4(_surface.tangent * 0.5f + 0.5f, 1.f); break;
            case 4: _output.color = float4(in.uv0, 0.f, 1.f); break;
            case 5: _output.color = float4(_surface.diffuse.rgb, 1.f); break;
            case 6: _output.color = float4(float3(_surface.roughness), 1.f); break;
            case 7: _output.color = float4(float3(_surface.metalness), 1.f); break;
            case 8: _output.color = float4(float3(_surface.ambientOcclusion), 1.f); break;
            default: break;
        }
        return _output;
    #endif
__FragmentDoLighting__
    #ifdef USE_CLUSTERED_LIGHTING
        
        int omni_count = cluster_offset_count.y & 0xff;
        for (int i = 0 ; i < omni_count; ++i, ++lid) {
            _lightingContribution.add_local_omni(scn_lights[LightIndex(lid)]);
        }
        
        int spot_count = (cluster_offset_count.y >> 8);
        for (int i = 0 ; i < spot_count; ++i, ++lid) {
            _lightingContribution.add_local_spot(scn_lights[LightIndex(lid)]);
        }
    #endif
#else 
        _lightingContribution.diffuse = in.diffuse;
    #ifdef USE_SPECULAR
        _lightingContribution.specular = in.specular;
    #endif
#endif 
    #ifdef AVOID_OVERLIGHTING
        _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);
    #ifdef USE_SPECULAR
        _lightingContribution.specular = saturate(_lightingContribution.specular);
    #endif 
    #endif 
#else 
    _lightingContribution.diffuse = float3(1.);
#endif 
    
    
    
    
#ifdef USE_PBR
    { 
        float3 albedo = _surface.diffuse.rgb;
        float3 diffuseAlbedo = mix(albedo, float3(0.0), _surface.metalness);
        
        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * albedo;
        color += _lightingContribution.diffuse * diffuseAlbedo;
#ifndef DISABLE_SPECULAR
        color += _lightingContribution.specular;
#endif
#ifdef USE_EMISSION
        color += _surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
        color *= _surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
        color *= _lightingContribution.modulate;
#endif
        _output.color.rgb = color;
    }
#else 
#ifdef USE_SHADOWONLY
    _output.color.rgb = float3(0.0);
    _output.color.a = 1. - _lightingContribution.shadowFactor;
#else
    _output.color.rgb = illuminate(_surface, _lightingContribution);
#endif
#endif
#ifndef USE_SHADOWONLY
    _output.color.a = _surface.diffuse.a;
#endif
#ifdef USE_FOG
    float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);
    _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);
#endif
#ifndef DIFFUSE_PREMULTIPLIED
    _output.color.rgb *= _surface.diffuse.a;
#endif
    
    
    
    
#ifdef USE_SHADOWONLY
    float transparencyFactor = 1.0;
#ifdef USE_NODE_OPACITY
    transparencyFactor *= in.nodeOpacity;
#endif
    _output.color.a *= transparencyFactor; 
#else
#ifdef USE_TRANSPARENT 
    
#ifdef USE_TRANSPARENCY
    _surface.transparent *= scn_commonprofile.transparency;
#endif
    
#ifdef USE_TRANSPARENCY_RGBZERO
#ifdef USE_NODE_OPACITY
    _output.color *= in.nodeOpacity;
#endif
    
    _surface.transparent.a = (_surface.transparent.r * 0.212671f) + (_surface.transparent.g * 0.715160f) + (_surface.transparent.b * 0.072169f);
    _output.color *= (float4(1.f) - _surface.transparent);
#else 
#ifdef USE_NODE_OPACITY
    _output.color *= (in.nodeOpacity * _surface.transparent.a);
#else
    _output.color *= _surface.transparent.a;
#endif
#endif
#else
#ifdef USE_TRANSPARENCY 
#ifdef USE_NODE_OPACITY
    _output.color *= (in.nodeOpacity * scn_commonprofile.transparency);
#else
    _output.color *= scn_commonprofile.transparency;
#endif 
#endif
#endif
#endif 
    
    
    
    
    
#ifdef USE_FRAGMENT_MODIFIER
    
    __DoFragmentModifier__
    
#endif
#if defined(USE_CLUSTERED_LIGHTING) && defined(DEBUG_CLUSTER_TILE)
    _output.color.rgb = mix(_output.color.rgb, float3(scn::debugColorForCount(clusterIndex.z).xyz), 0.1f);
    _output.color.rgb = mix(_output.color.rgb, float3(clusterIndex.x & 0x1 ^ clusterIndex.y & 0x1).xyz, 0.01f);
#endif
#ifdef DISABLE_LINEAR_RENDERING
    _output.color.rgb = scn::linear_to_srgb(_output.color.rgb);
#endif
    
#ifdef USE_DISCARD
    if (_output.color.a == 0.) 
        discard_fragment();
#endif
#ifdef USE_POINT_RENDERING
    if ((dfdx(pointCoord.x) < 0.5f) && (length_squared(pointCoord * 2.f - 1.f) > 1.f)) {
        discard_fragment();
    }
#endif
    
    
#ifdef USE_OUTLINE
    _output.color.rgb = in.outlineHash;
#endif
    
#ifdef USE_MOTIONBLUR
#ifdef USE_MULTIPLE_RENDERING
        _output.motionblur.xy = (half2(((in.fragmentPosition.xy-scn_frame_slice.viewportSize.zw)/scn_frame_slice.viewportSize.xy)*2.f-1.f) - half2((in.velocity.xy) / in.velocity.z)) * scn_frame_slice.motionBlurIntensity;
#else
    _output.motionblur.xy = half2((in.mv_fragment.xy / in.mv_fragment.z) - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * scn_frame.motionBlurIntensity;
#endif
    _output.motionblur.z = length(_output.motionblur.xy);
    _output.motionblur.w = half(-_surface.position.z);
#endif
#ifdef USE_NORMALS_OUTPUT
    _output.normals = half4( half3(_surface.normal.xyz), half(_surface.roughness) );
#endif
    
#ifdef USE_RADIANCE_OUTPUT
    _output.radiance.rgb = half3(_lightingContribution.specular.rgb);
#endif
                                 
#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT
#ifdef USE_PBR
    _output.reflectanceRoughnessOutput = half4( half3(_lightingContribution.probeReflectance), half(_surface.roughness) );
#else 
    _output.reflectanceRoughnessOutput = half4( 0.h );
#endif
#endif
    _output.color = min(_output.color, float4(160.));
    return _output;
struct OsdFVarPrimvar {
    uint8_t isUsed;
    uint8_t offset;
struct OsdFVarChannelDesc {
    uint32_t indicesBufferOffset;
    uint32_t dataBufferOffset;
    uint32_t dataBufferFVarWidth;
    uint32_t patchParamsBufferOffset;
    uint32_t patchArraysBufferOffset;
    OsdFVarPrimvar colorPrimvar;
    OsdFVarPrimvar texcoordPrimvars[8];
uniform mat4 u_modelViewProjectionTransform;
uniform mat4 u_transform;
uniform vec4 u_color;
attribute vec3 a_position;
varying vec4 v_vertexColor;
void main()
    gl_Position = u_modelViewProjectionTransform * u_transform * vec4(a_position, 1.);
    v_vertexColor = u_color;
varying vec2 TexCoord;
uniform sampler2D textureSampler0;
uniform vec2  offsets[MAX_SAMPLE];
uniform float weights[MAX_SAMPLE];
uniform int n_sample;
const float alphaThreshold = 0.9;
void main (void)
    int i;
    vec4 accum = vec4(0.0);
    float total = 0.0;
    for(i=0;i<n_sample;i++){
        vec4 c = texture2D(textureSampler0, TexCoord+offsets[i]);
        c.rgb *= c.a;
        accum += c * weights[i];
        total += weights[i] * c.a;
    }
    accum /= total;
gl_FragColor = accum;
    "sequence" : [ "SceneKit_PostProcess"],
    "passes" : {
        "SceneKit_PostProcess" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "inputs" : {
                "colorBuffer" : "COLOR"
            },
            "draw" : "DRAW_QUAD",
            "clientProgram" : "NO",
            "program" : "C3D-GLSL-UNAVAILABLE",
        }
    },
    "symbols" : {
    },
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
struct SCNTessellatorTransforms {
    float4x4 modelViewTransform;
    float4x4 modelViewProjectionTransform;
    float4x4 projectionTransform;
#if OSD_IS_ADAPTIVE
kernel void compute_opensubdiv(
                               constant SCNTessellatorTransforms&     transforms                     [[ buffer(TRANSFORMS_BUFFER_INDEX) ]],
                               constant float&                        tessellationLevel              [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]],
                               unsigned                               thread_position_in_grid        [[ thread_position_in_grid ]],
                               unsigned                               thread_position_in_threadgroup [[ thread_position_in_threadgroup ]],
                               unsigned                               threadgroup_position_in_grid   [[ threadgroup_position_in_grid ]],
                               OsdPatchParamBufferSet                 osdBuffers, 
                               device MTLQuadTessellationFactorsHalf* quadTessellationFactors        [[ buffer(QUAD_TESSFACTORS_INDEX) ]]
#if OSD_USE_PATCH_INDEX_BUFFER
                               ,device unsigned* patchIndex                                          [[ buffer(OSD_PATCH_INDEX_BUFFER_INDEX) ]]
                               ,device MTLDrawPatchIndirectArguments* drawIndirectCommands           [[ buffer(OSD_DRAWINDIRECT_BUFFER_INDEX) ]]
#endif
                         )
    
    
    
    
    
    
    
    threadgroup int3 patchParam[PATCHES_PER_THREADGROUP];
    
    threadgroup PatchVertexType patchVertices[PATCHES_PER_THREADGROUP * CONTROL_POINTS_PER_PATCH];
    
    const auto real_threadgroup = thread_position_in_grid / REAL_THREADGROUP_DIVISOR;
    const auto subthreadgroup_in_threadgroup = thread_position_in_threadgroup / REAL_THREADGROUP_DIVISOR;
    const auto real_thread_in_threadgroup = thread_position_in_threadgroup & (REAL_THREADGROUP_DIVISOR - 1);
    
#if NEEDS_BARRIER
    const auto validThread = thread_position_in_grid * CONTROL_POINTS_PER_THREAD < osdBuffers.kernelExecutionLimit;
#else
    const auto validThread = true;
    if(thread_position_in_grid * CONTROL_POINTS_PER_THREAD >= osdBuffers.kernelExecutionLimit)
        return;
#endif
    
    
    
    
    if(validThread)
    {
        patchParam[subthreadgroup_in_threadgroup] = OsdGetPatchParam(real_threadgroup, osdBuffers.patchParamBuffer);
        
        for(unsigned threadOffset = 0; threadOffset < CONTROL_POINTS_PER_THREAD; threadOffset++)
        {
            const auto vertexId = osdBuffers.indexBuffer[(thread_position_in_grid * CONTROL_POINTS_PER_THREAD + threadOffset) * IndexLookupStride];
            const auto v = osdBuffers.vertexBuffer[vertexId];
            
            threadgroup auto& patchVertex = patchVertices[thread_position_in_threadgroup * CONTROL_POINTS_PER_THREAD + threadOffset];
            
            
            
            
            
            OsdComputePerVertex(float4(v.position,1), patchVertex, vertexId, transforms.modelViewProjectionTransform, osdBuffers);
        }
    }
    
#if NEEDS_BARRIER
    threadgroup_barrier(mem_flags::mem_threadgroup);
#endif
    
    
    
    
    
    if(validThread)
    {
#if PATCHES_PER_THREADGROUP > 1
        auto patch = patchVertices + subthreadgroup_in_threadgroup * CONTROL_POINTS_PER_THREAD * CONTROL_POINTS_PER_PATCH;
#else
        
        auto patch = patchVertices;
#endif
        
        if(!OsdCullPerPatchVertex(patch, transforms.modelViewTransform))
        {
#if !OSD_USE_PATCH_INDEX_BUFFER
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[0] = 0.0h;
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[1] = 0.0h;
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[2] = 0.0h;
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[3] = 0.0h;
            quadTessellationFactors[real_threadgroup].insideTessellationFactor[0] = 0.0h;
            quadTessellationFactors[real_threadgroup].insideTessellationFactor[1] = 0.0h;
#endif
            
            patchParam[subthreadgroup_in_threadgroup].z = -1;
#if !NEEDS_BARRIER
            return;
#endif
        }
    }
    
#if NEEDS_BARRIER
    threadgroup_barrier(mem_flags::mem_threadgroup);
#endif
    
    
    
    
    if(validThread && patchParam[subthreadgroup_in_threadgroup].z != -1)
    {
        for(unsigned threadOffset = 0; threadOffset < CONTROL_POINTS_PER_THREAD; threadOffset++)
        {
            OsdComputePerPatchVertex(
                                     patchParam[subthreadgroup_in_threadgroup],
                                     real_thread_in_threadgroup * CONTROL_POINTS_PER_THREAD + threadOffset,
                                     real_threadgroup,
                                     thread_position_in_grid * CONTROL_POINTS_PER_THREAD + threadOffset,
                                     patchVertices + subthreadgroup_in_threadgroup * CONTROL_POINTS_PER_PATCH,
                                     osdBuffers
                                     );
        }
    }
    
#if NEEDS_BARRIER
    threadgroup_barrier(mem_flags::mem_device_and_threadgroup);
#endif
    
    
    
    
    if(validThread && real_thread_in_threadgroup == 0)
    {
        
#if OSD_USE_PATCH_INDEX_BUFFER
        const auto patchId = atomic_fetch_add_explicit((device atomic_uint*)&drawIndirectCommands->patchCount, 1, memory_order_relaxed);
        patchIndex[patchId] = real_threadgroup;
#else
        const auto patchId = real_threadgroup;
#endif
        
        OsdComputePerPatchFactors(
                                  patchParam[subthreadgroup_in_threadgroup],
                                  tessellationLevel,
                                  real_threadgroup,
                                  transforms.projectionTransform,
                                  transforms.modelViewTransform,
                                  osdBuffers,
                                  patchVertices + subthreadgroup_in_threadgroup * CONTROL_POINTS_PER_PATCH,
                                  quadTessellationFactors[patchId]
                                  );
    }
#endif 
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_JitterCopyFirstFrame</string>
<string>SceneKit_JitterToEven</string>
<string>SceneKit_JitterToOdd</string>
<string>SceneKit_JitterResolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_JitterCopyFirstFrame</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToOdd</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-even</string>
<key>factor</key>
<string>C3D-jitter-factor</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToEven</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-odd</string>
<key>textureSampler0</key>
<string>COLOR</string>
<key>factor</key>
<string>C3D-jitter-factor</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterResolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-jitter-odd</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
</dict>
<key>SceneKit-jitter-even</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-jitter-factor</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
</dict>
</plist>
#ifdef __METAL_VERSION__ 
#define DECLARE_BOOL(a) constant bool a [[ function_constant( __COUNTER__ ) ]];
#define DECLARE_INT(a) constant int a [[ function_constant( 1000 + __COUNTER__ ) ]];
#define DECLARE_UINT(a) constant uint a [[ function_constant( 2000 + __COUNTER__ ) ]];
#define DECLARE_OPT_INT(a) constant int a [[ function_constant( 3000 + __COUNTER__ ) ]];
#define DECLARE_OPT_UINT(a) constant uint a [[ function_constant( 4000 + __COUNTER__ ) ]];
#else
#if !defined(DECLARE_BOOL) || !defined(DECLARE_INT) || !defined(DECLARE_UINT) || !defined(DECLARE_OPT_INT) || !defined(DECLARE_OPT_UINT)
#error Need to declare DECLARE_BOOL and DECLARE_INT macros
#endif
#endif
#define kSCNTexcoordCount 8
DECLARE_BOOL(need_vertex_color)
DECLARE_BOOL(need_position)
DECLARE_BOOL(need_normal)
DECLARE_BOOL(need_tangent)
DECLARE_BOOL(need_texcoord0)
DECLARE_BOOL(need_texcoord1)
DECLARE_BOOL(need_texcoord2)
DECLARE_BOOL(need_texcoord3)
DECLARE_BOOL(need_texcoord4)
DECLARE_BOOL(need_texcoord5)
DECLARE_BOOL(need_texcoord6)
DECLARE_BOOL(need_texcoord7)
DECLARE_BOOL(use_io_vertex_color)
DECLARE_BOOL(use_io_position)
DECLARE_BOOL(use_io_normal)
DECLARE_BOOL(use_io_view)
DECLARE_BOOL(use_ambient)
DECLARE_BOOL(use_diffuse)
DECLARE_BOOL(use_specular)
DECLARE_BOOL(use_emission)
DECLARE_BOOL(use_multiply)
DECLARE_BOOL(use_reflective)
DECLARE_BOOL(use_transparent)
DECLARE_BOOL(use_diffuse_map)
DECLARE_BOOL(use_normal_map)
DECLARE_BOOL(use_transparent_map)
DECLARE_BOOL(use_emission_map)
DECLARE_BOOL(use_ambient_map)
DECLARE_BOOL(use_multiply_map)
DECLARE_BOOL(use_specular_map)
DECLARE_BOOL(use_reflective_map)
DECLARE_BOOL(use_reflectivecube_map)
DECLARE_BOOL(use_roughness_map)
DECLARE_BOOL(use_metalness_map)
DECLARE_OPT_INT(diffuse_texture_component)
DECLARE_OPT_INT(normal_texture_component)
DECLARE_OPT_INT(transparent_texture_component)
DECLARE_OPT_INT(emission_texture_component)
DECLARE_OPT_INT(ambient_texture_component)
DECLARE_OPT_INT(multiply_texture_component)
DECLARE_OPT_INT(specular_texture_component)
DECLARE_OPT_INT(reflective_texture_component)
DECLARE_OPT_INT(roughness_texture_component)
DECLARE_OPT_INT(metalness_texture_component)
DECLARE_BOOL(use_diffuse_intensity)
DECLARE_BOOL(use_normal_intensity)
DECLARE_BOOL(use_transparent_intensity)
DECLARE_BOOL(use_emission_intensity)
DECLARE_BOOL(use_ambient_intensity)
DECLARE_BOOL(use_multiply_intensity)
DECLARE_BOOL(use_specular_intensity)
DECLARE_BOOL(use_reflective_intensity)
DECLARE_BOOL(use_roughness_intensity)
DECLARE_BOOL(use_metalness_intensity)
DECLARE_BOOL(use_fresnel)
DECLARE_BOOL(use_transparency)
DECLARE_BOOL(use_transparency_rgbzero)
DECLARE_INT(diffuse_channel)
DECLARE_INT(normal_channel)
DECLARE_INT(transparent_channel)
DECLARE_INT(emission_channel)
DECLARE_INT(ambient_channel)
DECLARE_INT(multiply_channel)
DECLARE_INT(specular_channel)
DECLARE_INT(roughness_channel)
DECLARE_INT(metalness_channel)
DECLARE_OPT_INT(diffuse_texcoord_io_index)
DECLARE_OPT_INT(normal_texcoord_io_index)
DECLARE_OPT_INT(transparent_texcoord_io_index)
DECLARE_OPT_INT(emission_texcoord_io_index)
DECLARE_OPT_INT(ambient_texcoord_io_index)
DECLARE_OPT_INT(multiply_texcoord_io_index)
DECLARE_OPT_INT(specular_texcoord_io_index)
DECLARE_OPT_INT(roughness_texcoord_io_index)
DECLARE_OPT_INT(metalness_texcoord_io_index)
DECLARE_OPT_INT(diffuse_transform_index)
DECLARE_OPT_INT(normal_transform_index)
DECLARE_OPT_INT(transparent_transform_index)
DECLARE_OPT_INT(emission_transform_index)
DECLARE_OPT_INT(ambient_transform_index)
DECLARE_OPT_INT(multiply_transform_index)
DECLARE_OPT_INT(specular_transform_index)
DECLARE_OPT_INT(roughness_transform_index)
DECLARE_OPT_INT(metalness_transform_index)
DECLARE_BOOL(use_emission_as_selfIllumination)
DECLARE_BOOL(use_ambient_as_ambientOcclusion)
DECLARE_BOOL(use_texture_transforms)
DECLARE_BOOL(use_point_rendering)
DECLARE_BOOL(diffuse_premultiplied)
DECLARE_BOOL(use_discard)
DECLARE_BOOL(use_instancing)
DECLARE_INT(max_bone_count)
DECLARE_INT(lighting_model)
DECLARE_BOOL(use_lighting) 
DECLARE_BOOL(use_ambient_lighting)
DECLARE_BOOL(use_modulate_lighting)
DECLARE_BOOL(use_per_vertex_lighting)
DECLARE_BOOL(avoid_overlighting) 
DECLARE_BOOL(use_double_sided)
DECLARE_BOOL(use_probes_lighting)
DECLARE_OPT_UINT(use_light0);
DECLARE_OPT_UINT(use_light1);
DECLARE_OPT_UINT(use_light2);
DECLARE_OPT_UINT(use_light3);
DECLARE_BOOL(use_node_opacity)
DECLARE_BOOL(use_fog)
DECLARE_BOOL(use_ssao)
DECLARE_INT(io_texcoord_count)
#undef DECLARE_BOOL
#undef DECLARE_INT
#undef DECLARE_UINT
#undef DECLARE_OPT_INT
#undef DECLARE_OPT_UINT
attribute vec4 a_position;
varying vec2 uv;
void main(void)
    gl_Position = a_position;
    uv = (a_position.xy + 1.0) * 0.5;
struct SCNShaderSurface
vec3 view; 
vec3 position; 
vec3 normal; 
vec3 tangent; 
vec3 bitangent; 
float shininess;
    float fresnel;
    float ambientOcclusion;
vec3 _normalTS; 
uniform sampler2D u_color;
uniform sampler2D u_depth;
uniform float     u_middleZ;
varying vec2 TexCoord;
void main (void)
gl_FragColor = texture2D(u_color,TexCoord);
    
#ifndef GL_ES
    gl_FragDepth = texture2D(u_depth,TexCoord).r;
    
    if(gl_FragDepth == 1.0){
        gl_FragDepth = u_middleZ;
    }
#endif
    
    
    
    
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_renderScene</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderScene</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>layerMask</key>
<integer>3</integer>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>Outline-pickedObjects</string>
<string>Outline-outline</string>
</array>
<key>passes</key>
<dict>
<key>Outline-pickedObjects</key>
<dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>pickedObjects-depth</string>
<key>color</key>
<string>pickedObjects-color</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>u_modelViewProjectionTransform</key>
<string>u_modelViewProjectionTransform-symbol</string>
<key>u_modelTransform</key>
<string>u_modelTransform-symbol</string>
</dict>
<key>draw</key>
<string>DRAW_NODES</string>
<key>samples</key>
<integer>1</integer>
<key>overridesCustomProgram</key>
<true/>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>&quot;0. 0. 0. 1.&quot;</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>Outline-outline</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>pickedColorBuffer</key>
<string>pickedObjects-color</string>
<key>pickedDepthBuffer</key>
<string>pickedObjects-depth</string>
<key>colorBuffer</key>
<string>COLOR</string>
<key>depthBuffer</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-Outline</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outline_vert</string>
<key>metalFragmentShader</key>
<string>outline_frag</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>u_modelViewProjectionTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelViewProjectionTransform</string>
</dict>
<key>u_modelTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelTransform</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>pickedObjects-depth</key>
<dict>
<key>type</key>
<string>depth</string>
<key>format</key>
<string>depth24</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>pickedObjects-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>r8</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
  struct scn_floor {
    float4 u_floor_viewport;
    float u_floorReflectivity;
#ifdef USE_FALLOFF
    float4x4 u_floorMVP_i;
    float4 u_floorPlane;
    float u_floorFalloff;
#ifdef USE_FALLOFF_START
    float u_floorFalloffStart;
#endif
#endif
static inline float3 floorUnprojectPoint(float3 screenPos, float4x4 mvp_i)
    float4 pTmp = mvp_i * float4(screenPos.xy * 2.0 - 1.0, screenPos.z, 1.0);
    return pTmp.xyz / pTmp.w;
#pragma arguments
scn_floor scn_floorSurf
texture2d_layer u_floorReflectionColor;
depth2d u_floorReflectionDepth;
#pragma body
float2 normalizedFragCoord =  scn_floorSurf.u_floor_viewport.xy + in.fragmentPosition.xy * scn_floorSurf.u_floor_viewport.zw;
normalizedFragCoord.xy += 0.2 * _surface._normalTS.xy;
constexpr sampler linear_sampler(filter::linear);
float4 floorColor = u_floorReflectionColor.sampleLayer(linear_sampler, normalizedFragCoord);
float reflectionFactor = scn_floorSurf.u_floorReflectivity;
#ifdef USE_FALLOFF
float floorDepth = u_floorReflectionDepth.sample(linear_sampler, normalizedFragCoord);
float3  floorPW = floorUnprojectPoint(float3(normalizedFragCoord.x, 1. - normalizedFragCoord.y, floorDepth), scn_floorSurf.u_floorMVP_i);
float floorDist = -dot(floorPW.xyz, scn_floorSurf.u_floorPlane.xyz) - scn_floorSurf.u_floorPlane.w;;
#ifdef USE_FALLOFF_START
floorDist -= scn_floorSurf.u_floorFalloffStart; 
#endif 
reflectionFactor *= 1.0 - clamp(floorDist / scn_floorSurf.u_floorFalloff, 0.0, 1.0);
#endif 
floorColor *= reflectionFactor; 
_output.color.rgb *= (1. - floorColor.a); 
_output.color.rgba += floorColor.rgba; 
attribute vec3 a_position;
varying vec2 TexCoord;
uniform mat4 u_textureMatrix;
void main(void)
gl_Position = vec4(a_position, 1.0);
    TexCoord = (u_textureMatrix * vec4(a_position.xy, 0., 1.)).xy * 0.5 + 0.5;
TexCoord.y = 1.0 - TexCoord.y;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>computeVelocity</string>
<string>blur1</string>
<string>blur2</string>
<string>renderMovableNodes</string>
</array>
<key>passes</key>
<dict>
<key>blur1</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>velocitySampler</key>
<string>VELOCITY</string>
<key>intensity</key>
<string>C3D-MotionBlur-Intensity-symbol</string>
</dict>
<key>program</key>
<string>C3D-GLSL-UNAVAILABLE</string>
<key>clientProgram</key>
<string>NO</string>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>metalFragmentShader</key>
<string>scn_motionblur_blur_6taps</string>
<key>metalVertexShader</key>
<string>scn_motionblur_vert</string>
</dict>
<key>blur2</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>velocitySampler</key>
<string>VELOCITY</string>
<key>intensity</key>
<string>C3D-MotionBlur-Intensity-symbol</string>
</dict>
<key>program</key>
<string>C3D-GLSL-UNAVAILABLE</string>
<key>clientProgram</key>
<string>NO</string>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>metalFragmentShader</key>
<string>scn_motionblur_blur_12taps</string>
<key>metalVertexShader</key>
<string>scn_motionblur_vert</string>
</dict>
<key>renderMovableNodes</key>
<dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>onlyMovableNodes</key>
<true/>
<key>samples</key>
<integer>1</integer>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>C3D-MotionBlur-Intensity-symbol</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-oldViewProjectionTransform-symbol</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
<key>C3D-viewProjectionInverseTransform-symbol</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>VELOCITY</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba16f</string>
<key>scaleFactor</key>
<real>0.25</real>
</dict>
<key>blur-target</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
uniform float u_floorReflectivity;
uniform sampler2D u_floorReflectionColor;
uniform vec4 u_floor_viewport;
#ifdef USE_FALLOFF
uniform mat4 u_floorMVP_i;
uniform vec4 u_floorPlane;
uniform float u_floorFalloff;
#ifdef USE_FALLOFF_START
uniform float u_floorFalloffStart;
#endif
uniform sampler2D u_floorReflectionDepth;
vec3 floorUnprojectPoint(vec3 screenPos)
    vec4 pTmp;
    pTmp.xyz = (2.0 * screenPos.xyz) - 1.0;
    pTmp.w = 1.0;
    pTmp = u_floorMVP_i * pTmp;
    pTmp /= pTmp.w;
    return vec3(pTmp);
#endif 
#pragma body
vec2 normalizedFragCoord = gl_FragCoord.xy * u_floor_viewport.zw;
normalizedFragCoord.xy += 0.2 * _surface._normalTS.xy;
vec4 floorColor = texture2D(u_floorReflectionColor, normalizedFragCoord);
float reflectionFactor = u_floorReflectivity;
#ifdef USE_FALLOFF
float floorDepth = texture2D(u_floorReflectionDepth, normalizedFragCoord).x;
vec3  floorPW = floorUnprojectPoint(vec3(normalizedFragCoord, floorDepth));
float floorDist = - dot(vec4(floorPW.xyz, 1.0), u_floorPlane);
#ifdef USE_FALLOFF_START
floorDist -= u_floorFalloffStart; 
#endif 
reflectionFactor *= 1.0 - clamp(floorDist / u_floorFalloff, 0.0, 1.0);
#endif 
floorColor *= reflectionFactor; 
_output.color.rgb *= (1. - floorColor.a); 
_output.color.rgba += floorColor.rgba; 
  "passes" : {
    "SceneKit_ApplyCIFilter" : {
      "outputs" : {
        "color" : "SceneKit-CI-effect-color"
      },
      "inputs" : {
        "myInput1" : "SceneKit-CI-nodetree-color"
      },
      "draw" : "CUSTOM"
    },
    "SceneKit_renderCINodeTree" : {
      "outputs" : {
        "depth" : "SceneKit-CI-nodetree-depth",
        "color" : "SceneKit-CI-nodetree-color"
      },
      "ignoreFloors" : true,
      "draw" : "DRAW_NODE",
      "node" : "self"
    },
    "SceneKit_renderCIQuad" : {
      "inputs" : {
        "u_m" : "C3D-CIFilter_modelMatrix",
        "u_color" : {
          "target" : "SceneKit-CI-effect-color",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_middleZ" : "C3D-CIFilter_middleZ",
        "u_depth" : {
          "target" : "SceneKit-CI-nodetree-depth",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        }
      },
      "hasConstantAlpha" : false,
      "colorStates" : {
        "clear" : false
      },
      "depthStates" : {
        "clear" : false
      },
      "program" : "C3D-CIFilterComposite",
      "draw" : "none",
      "clientProgram" : false,
      "blendStates" : {
        "enable" : true,
        "colorDst" : "oneMinusSrcAlpha",
        "colorSrc" : "one"
      }
    }
  },
  "sequence" : [
    "SceneKit_renderCINodeTree",
    "SceneKit_ApplyCIFilter",
    "SceneKit_renderCIQuad"
  ],
  "symbols" : {
    "C3D-CIFilter_middleZ" : {
      "type" : "float"
    },
    "C3D-CIFilter_modelMatrix" : {
      "type" : "mat4"
    }
  },
  "targets" : {
    "SceneKit-CI-effect-color" : {
      "type" : "color"
    },
    "SceneKit-CI-nodetree-color" : {
      "target" : "texture_rectangle",
      "type" : "color"
    },
    "SceneKit-CI-nodetree-depth" : {
      "type" : "depth"
    }
#ifdef ENABLE_CUBE_MAP
uniform samplerCube u_textureSampler0;
uniform float u_fresnelExponent;
varying vec4 v_normal;
#ifdef ENABLE_FOG
uniform vec4 u_fogColor;
#endif
#else 
uniform sampler2D u_textureSampler0;
#endif
varying vec4 v_vertexColor;
#ifdef ENABLE_ANIMATION
varying vec3 v_uv0;
varying vec2 v_uv1;
#else
varying vec2 v_uv0;
#endif
#if __VERSION__ > 120 
#ifndef texture2D
#define texture2D(tex,coord) texture( tex, coord )
#endif
#define textureCube(tex,coord) texture( tex, coord )
#endif
#ifdef ENABLE_SOFT
uniform sampler2D u_depthSampler0;
uniform vec4 u_softParameters; 
uniform mat4 u_invProj; 
varying float v_eyeLinearZ;
float ComputeSoftFactor()
    vec2 normalizedFragCoord = gl_FragCoord.xy * u_softParameters.zw;
float depthValue = texture2D(u_depthSampler0, gl_FragCoord.xy * u_softParameters.zw).x;
    
    vec3 screenPos = vec3(normalizedFragCoord, depthValue);
vec4 viewPos = u_invProj * vec4(screenPos * 2. - 1., 1.);
viewPos /= viewPos.w;
    
    float factor = clamp((v_eyeLinearZ - viewPos.z) * u_softParameters.x ,0. , 1.);
    
    
    
    return factor;
#endif
void main(){
#ifdef ENABLE_CUBE_MAP
    vec2 p = v_uv0 * 2. - 1.;
    float r = dot(p,p); 
    vec4 tex = textureCube(u_textureSampler0, v_normal.xyz) * clamp(9.6 - 10. * r, 0., 1.0);
    
    tex.rgb *= pow(r, u_fresnelExponent);
#else 
#ifdef ENABLE_ANIMATION 
    vec4 tex = mix(texture2D(u_textureSampler0, v_uv0.xy),
                   texture2D(u_textureSampler0, v_uv1.xy), v_uv0.z);
#else
    vec4 tex = texture2D(u_textureSampler0, v_uv0);
#endif 
#endif 
#ifdef ENABLE_SOFT
    tex *= ComputeSoftFactor();
#endif
    
    
#ifdef ENABLE_CUBE_MAP
    gl_FragColor.a = v_vertexColor.a * tex.a; 
#ifdef ENABLE_FOG
    gl_FragColor.rgb = mix(v_vertexColor.rgb + tex.rgb, u_fogColor.rgb, v_normal.a) * gl_FragColor.a; 
#else
    gl_FragColor.rgb = (v_vertexColor.rgb + tex.rgb) * gl_FragColor.a; 
#endif 
#else
    gl_FragColor = v_vertexColor * tex; 
#endif
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_JitterCopyFirstFrame</string>
<string>SceneKit_JitterToEven</string>
<string>SceneKit_JitterToOdd</string>
<string>SceneKit_JitterResolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_JitterCopyFirstFrame</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToOdd</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-even</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToEven</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-odd</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterResolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit-jitter-odd</string>
<key>factor</key>
<string>C3D-jitter-factor-resolve</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-jitter-odd</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
<key>format</key>
<string>rgba32f</string>
</dict>
<key>SceneKit-jitter-even</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
<key>format</key>
<string>rgba32f</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-jitter-factor-resolve</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
</dict>
</plist>
  "passes" : {
    "SceneKit_renderSceneFromLight" : {
      "outputs" : {
        "depth" : "SceneKit-spotShadowDepth"
      },
      "depthStates" : {
        "clear" : true
      },
      "isViewDependant" : false,
      "samples" : 1,
      "onlyShadowCasters" : true,
      "pointOfView" : "self",
      "ignoreFloors" : true,
      "draw" : "DRAW_SCENE"
    }
  },
  "sequence" : [
    "SceneKit_renderSceneFromLight"
  ],
  "targets" : {
    "SceneKit-spotShadowDepth" : {
      "global" : true,
      "type" : "depth"
    }
#if defined(__METAL_IOS__)
    #define RETURN_IF_OUTSIDE(dst) if ((index.x >= dst.get_width()) || (index.y >= dst.get_height())) return;
    #define RETURN_IF_OUTSIDE3D(dst) if ((index.x >= dst.get_width()) || (index.y >= dst.get_height()) || (index.z >= dst.get_depth())) return;
#elif defined(__METAL_MACOS__) 
    #define RETURN_IF_OUTSIDE(dst)
    #define RETURN_IF_OUTSIDE3D(dst)
#endif
namespace scn {
    
    
    static inline float4 reduce_op(float4 d0, float4 d1)
    {
        d0.x = min(d0.x, d1.x);
        d0.y = max(d0.y, d1.y);
        d0.z += d1.z;
        d0.w += d1.w;
        return d0;
    }
    
    inline float vector_reduce_min(float4 v)
    {
        float2 min_lh = min(v.xy, v.zw);
        return min(min_lh.x, min_lh.y);
    }
    
    inline float vector_reduce_max(float4 v)
    {
        float2 max_lh = max(v.xy, v.zw);
        return max(max_lh.x, max_lh.y);
    }
    
    inline int vector_reduce_add(int4 v)
    {
        int2 add_lh = v.xy + v.zw;
        return add_lh.x + add_lh.y;
    }
    
    inline float3x3 mat3(float4x4 mat4)
    {
        return float3x3(mat4[0].xyz, mat4[1].xyz, mat4[2].xyz);
    }
    
    inline float3 mat4_mult_float3_normalized(float4x4 matrix, float3 src)
    {
        float3 dst  =  src.xxx * matrix[0].xyz;
        dst         += src.yyy * matrix[1].xyz;
        dst         += src.zzz * matrix[2].xyz;
        return normalize(dst);
    }
    
    inline float3 mat4_mult_float3(float4x4 matrix, float3 src)
    {
        float3 dst  =  src.xxx * matrix[0].xyz;
        dst         += src.yyy * matrix[1].xyz;
        dst         += src.zzz * matrix[2].xyz;
        return dst;
    }
    inline float3 matrix_rotate(float4x4 mat, float3 dir)
    {
        return  dir.xxx * mat[0].xyz +
                dir.yyy * mat[1].xyz +
                dir.zzz * mat[2].xyz;
    }
    inline float4 matrix_transform(float4x4 mat, float3 pos)
    {
        return  pos.xxxx * mat[0] +
                pos.yyyy * mat[1] +
                pos.zzzz * mat[2] +
                           mat[3];
    }
    inline float3 quaternion_rotate_vector(float4 q, float3 v)
    {
        float3 t = 2.f * cross(q.xyz, v);
        return v + q.w * t + cross(q.xyz, t);
    }
    
    template <class T>
    inline vec<T, 3> robust_normalize(vec<T, 3> v)
    {
        vec<T, 3> zero = 0.;
        return all(v == zero) ? zero : normalize(v);
    }
    template <class T>
    inline void generate_basis(vec<T, 3> inR, thread vec<T, 3> *outS, thread vec<T, 3> *outT)
    {
        
        T x  = -inR.x;
        T y  = inR.y;
        T z  = inR.z;
        T sz = copysign(T(1.), z);
        T a  = y / (abs(z) + T(1.));
        T b  = y * a;
        T c  = x * a;
        *outS = (vec<T, 3>){ z + sz * b,  sz * c,       x       };
        *outT = (vec<T, 3>){ c,           T(1.) - b,    -sz * y };
    }
    
    
    
    inline float3 blend_add(float3 base, float3 blend)
    {
        return min(base + blend, 1.0);
    }
    
    inline float3 blend_lighten(float3 base, float3 blend)
    {
        return max(blend, base);
    }
    
    inline float3 blend_screen(float3 base, float3 blend)
    {
        return (1.0 - ((1.0 - base) * (1.0 - blend)));
    }
    
    
    inline half sq(half f) {
        return f * f;
    }
    inline float sq(float f) {
        return f * f;
    }
    
    inline float2 sincos(float angle) {
        float cs;
        float sn = ::sincos(angle, cs);
        return float2(sn, cs);
    }
    
    
    inline float acos_fast(float f) {
        float x = abs(f);
        float res = -0.156583f * x + M_PI_2_F;
        res *= sqrt(1.0f - x);
        return (f >= 0.f) ? res : M_PI_F - res;
    }
    inline float asin_fast(float f)
    {
        return M_PI_2_F - acos_fast(f);
    }
    
    inline float atan_fast(float inX)
    {
        float  x = inX;
        return x*(-0.1784f * abs(x) - 0.0663f * x * x + 1.0301f);
    }
    
    inline float atan2_fast(float y, float x)
    {
        float sx = x > 0.f ? -1.f : 1.f;
        float abs_y = abs(y) + 1e-10f; 
        float r = (x + abs_y*sx) / (abs_y - x*sx);
        float angle = sx * M_PI_4_F + M_PI_2_F;
        angle      += (0.1963f * r * r - 0.9817f) * r;
        return y > 0.f ? angle : -angle;
    }
    
    
    template <class T>
    inline vec<T, 3> cartesian_from_spherical(vec<T, 2> uv)
    {
        
        
        T cos_phi;
        T phi = uv.x * 2.0f * M_PI_F;
        T sin_phi = ::sincos(phi, cos_phi);
        
        T cos_theta;
        T theta     = uv.y * M_PI_F;
        T sin_theta = ::sincos(theta, cos_theta);
        return vec<T, 3>(cos_phi * sin_theta,
                         cos_theta,
                         -sin_phi * sin_theta);
    }
    inline float2 spherical_from_cartesian(float3 dir)
    {
        return float2( atan2(-dir.z, dir.x) * (0.5f * M_1_PI_F), acos(dir.y) * M_1_PI_F);
    }
    inline half2 spherical_from_cartesian(half3 dir)
    {
        return half2(atan2(-dir.z, dir.x) * 0.5h, acos(dir.y)) * M_1_PI_H;
    }
    inline float2 spherical_from_cartesian_fast(float3 dir)
    {
        return float2( atan2_fast(-dir.z, dir.x) * (0.5f * M_1_PI_F), acos_fast(dir.y) * M_1_PI_F);
    }
    inline half2 spherical_from_cartesian_fast(half3 dir)
    {
        return half2( atan2_fast(-dir.z, dir.x) * 0.5h, acos_fast(dir.y)) * M_1_PI_H;
    }
    #define dual_contract_factor  1.0
    template <class T>
    inline vec<T, 2> dual_paraboloid_from_cartesian(vec<T, 3> dir)
    {
        dir.xy /= abs(dir.z) + 1.0;
        dir.y = 0.5 - dir.y * 0.5;
        T s   = sign(dir.z) * 0.25;
        dir.x = s * (dir.x - 1.0) + 0.5;
        return dir.xy;
    }
    
    
    template <class T>
    inline vec<T, 3> cartesian_from_dual_paraboloid(vec<T, 2>  uv)
    {
        
        T zside = 0.5 * sign(0.5 - uv.x);
        uv.x = 1.0 - abs(4.0 * uv.x - 2.0); 
        uv.y   = 1.0 - uv.y * 2.0;
        T z = length_squared(uv); 
        z = (1.0 - z) * zside;
        
        return vec<T, 3>(uv.x, uv.y, z);
    }
    inline float reduce_min(float3 v) {
        return min(v.x, min(v.y, v.z));
    }
    
    inline float reduce_min(float4 v) {
        return min(min(v.x, v.y), min(v.z, v.w));
    }
    inline float reduce_max(float3 v) {
        return max(v.x, max(v.y, v.z));
    }
    inline float reduce_max(float4 v) {
        return max(max(v.x, v.y), max(v.z, v.w));
    }
    
    inline float3 randomSphereDir(float2 rnd)
    {
        float s = rnd.x * M_PI_F * 2.f;
        float t = rnd.y * 2.f - 1.f;
        return float3(sin(s), cos(s), t) / sqrt(1.f + t * t);
    }
    
    
    template <class T>
    inline T interleaved_gradient_noise(vec<T, 2> pos)
    {
        vec<T, 3> magic( 0.06711056f, 0.00583715f, 52.9829189f );
        return fract( magic.z * fract( dot( pos, magic.xy ) ) );
    }
    
    inline float3 hemisphere_reflect(float3 v, float3 nrm)
    {
        return v * sign(dot(v, nrm));
    }
    
    inline float3 randomHemisphereDir(float3 dir, float2 rnd)
    {
        return hemisphere_reflect(randomSphereDir( rnd ), dir);
    }
    
    inline void orthogonal_basis(float3 n, thread float3& xp, thread float3& yp)
    {
        
        float sz = n.z >= 0.f ? 1.f : -1.f;
        float a  =  n.y / (1.f + abs(n.z));
        float b  =  n.y * a;
        float c  = -n.x * a;
        
        xp = float3(n.z + sz * b,   sz * c,     -n.x);
        yp = float3(c,              1.f - b,    -sz * n.y);
    }
    template <class U>
    inline float2 normalized_coordinate(ushort2 index, U texture)
    {
        return float2(float(index.x) / float(texture.get_width()  - 1),
                      float(index.y) / float(texture.get_height() - 1));
    }
    template <class U>
    inline float2 normalized_coordinate(uint2 index, U texture)
    {
        return float2(float(index.x) / float(texture.get_width()  - 1),
                      float(index.y) / float(texture.get_height() - 1));
    }
    template <class U>
    inline half2 normalized_coordinate_half(uint2 index, U texture)
    {
        return half2(half(index.x) / half(texture.get_width()  - 1),
                     half(index.y) / half(texture.get_height() - 1));
    }
    
    template <class T>
    inline vec<T, 3> cubemap_dir_from_sampleCoord(uint face, vec<T, 2> sampleCoord) 
    {
        switch(face) {
            case 0: 
                return vec<T, 3>( 1.0, -sampleCoord.y, -sampleCoord.x);
            case 1: 
                return vec<T, 3>(-1.0, -sampleCoord.y,  sampleCoord.x);
            case 2: 
                return vec<T, 3>(sampleCoord.x,  1.0,  sampleCoord.y);
            case 3: 
                return vec<T, 3>(sampleCoord.x, -1.0, -sampleCoord.y);
            case 4: 
                return vec<T, 3>( sampleCoord.x, -sampleCoord.y,  1.0);
            default: 
                return vec<T, 3>(-sampleCoord.x, -sampleCoord.y, -1.0);
        }
    }
    
    template <class T>
    inline T signed_unit(T uv) {
        return uv * 2.0 - 1.0;
    }
    
    template <class T>
    inline T unsigned_unit(T uv) {
        return uv * 0.5 + 0.5;
    }
    template <class T>
    inline vec<T, 3> cubemap_dir_from_uv(uint face, vec<T, 2> uv) 
    {
        return cubemap_dir_from_sampleCoord(face, signed_unit(uv));
    }
    template <class T>
    inline vec<T, 3> cubemap_dir_from_uv_unit(uint face, vec<T, 2> uv) 
    {
        return normalize(cubemap_dir_from_uv(face, uv));
    }
    
    
    inline float2 barycentric_mix(float2 __x, float2 __y, float2 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }
    inline float3 barycentric_mix(float3 __x, float3 __y, float3 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }
    inline float4 barycentric_mix(float4 __x, float4 __y, float4 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }
    
    static inline float rect(float2 lt, float2 rb, float2 uv)
    {
        float2 borders = step(lt, uv) * step(uv, rb);
        return borders.x * borders.y;
    }
    
    inline half4 debugColorForCascade(int cascade)
    {
        switch (cascade) {
            case 0:
            return half4(1.h, 0.h, 0.h, 1.h);
            case 1:
            return half4(0.9, 0.5, 0., 1.);
            case 2:
            return half4(1., 1., 0., 1.);
            case 3:
            return half4(0., 1., 0., 1.);
            default:
            return half4(0., 0., 0., 1.);
        }
    }
    inline half3 debugColorForFace(int count)
    {
        switch (count) {
            case 0:  return half3(1.0h, 0.1h, 0.1h);
            case 1:  return half3(0.1h, 1.0h, 1.0h);
            case 2:  return half3(0.1h, 1.0h, 0.1h);
            case 3:  return half3(1.0h, 0.1h, 1.0h);
            case 4:  return half3(0.1h, 0.1h, 1.0h);
            default: return half3(1.0h, 1.0h, 0.1h);
        }
    }
    inline half4 debugColorForCount(int count)
    {
        switch (count) {
            case 0: return half4(0.0h, 0.0h, 0.0h, 1.h);
            case 1: return half4(0.0h, 0.0h, 0.4h, 1.h);
            case 2: return half4(0.0h, 0.0h, 0.9h, 1.h);
            case 3: return half4(0.0h, 0.4h, 0.7h, 1.h);
            case 4: return half4(0.0h, 0.9h, 0.4h, 1.h);
            case 5: return half4(0.0h, 0.9h, 0.0h, 1.h);
            case 6: return half4(0.4h, 0.7h, 0.0h, 1.h);
            case 7: return half4(0.9h, 0.7h, 0.0h, 1.h);
            default: return half4(1., 0., 0., 1.);
        }
    }
    inline float grid(float2 lt, float2 rb, float2 gridSize, float thickness, float2 uv)
    {
        float insideRect = rect(lt, rb + thickness, uv);
        float2 gt = thickness * gridSize;
        float2 lines = step(abs(lt - fract(uv * gridSize)), gt);
        return insideRect * (lines.x + lines.y);
    }
    inline float checkerboard(float2 gridSize, float2 uv)
    {
        float2 check = floor(uv * gridSize);
        return step(fmod(check.x + check.y, 2.f), 0.f);
    }
    
    
    inline float luminance(float3 color)
    {
        
        
        return color.r * 0.212671 + color.g * 0.715160 + color.b * 0.072169;
    }
    
    inline float srgb_to_linear(float c)
    {
        return (c <= 0.04045f) ? c / 12.92f : powr((c + 0.055f) / 1.055f, 2.4f);
    }
    
    inline half srgb_to_linear_fast(half c)
    {
        return powr(c, 2.2h);
    }
    
    inline half3 srgb_to_linear_fast(half3 c)
    {
        return powr(c, 2.2h);
    }
    
    inline half srgb_to_linear(half c)
    {
        
        return (c <= 0.04045h) ? (c * 0.0773993808h) :  powr(0.9478672986h * c + 0.05213270142h, 2.4h);
    }
    
    inline float3 srgb_to_linear(float3 c)
    {
        return float3(srgb_to_linear(c.x), srgb_to_linear(c.y), srgb_to_linear(c.z));
    }
    
    inline float linear_to_srgb(float c)
    {
        return (c < 0.0031308f) ? (12.92f * c) : (1.055f * powr(c, 1.f/2.4f) - 0.055f);
    }
    
    inline float3 linear_to_srgb(float3 v) { 
        return float3(linear_to_srgb(v.x), linear_to_srgb(v.y), linear_to_srgb(v.z));
    }
    
template <typename T>
inline T dFdx(T v) {
    return dfdx(v);
template <typename T>
inline T dFdy(T v) {
    return -dfdy(v);
inline float4 texture2DProj(texture2d<float> tex, sampler smp, float4 uv)
    return tex.sample(smp, uv.xy / uv.w);
inline half4 texture2DProj(texture2d<half> tex, sampler smp, float4 uv)
    return tex.sample(smp, uv.xy / uv.w);
static constexpr sampler scn_shadow_sampler_rev_z = sampler(coord::normalized, filter::linear, mip_filter::none, address::clamp_to_zero, compare_func::less_equal);
static constexpr sampler scn_shadow_sampler_ord_z = sampler(coord::normalized, filter::linear, mip_filter::none, address::clamp_to_edge, compare_func::greater_equal);
#if defined(USE_REVERSE_Z) && USE_REVERSE_Z
static constexpr sampler scn_shadow_sampler = scn_shadow_sampler_rev_z;
#else
static constexpr sampler scn_shadow_sampler = scn_shadow_sampler_ord_z;
#endif
inline float shadow2D(sampler shadow_sampler, depth2d<float> tex, float3 uv)
    return tex.sample_compare(shadow_sampler, uv.xy, uv.z);
inline float shadow2DProj(sampler shadow_sampler, depth2d<float> tex, float4 uv)
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(shadow_sampler, uvp.xy, uvp.z);
inline float shadow2DArray(sampler shadow_sampler, depth2d_array<float> tex, float3 uv, uint slice)
    return tex.sample_compare(shadow_sampler, uv.xy, slice, uv.z);
inline float shadow2DArrayProj(sampler shadow_sampler, depth2d_array<float> tex, float4 uv, uint slice)
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(shadow_sampler, uvp.xy, slice, uvp.z);
inline float4 transformViewPosInShadowSpace(float3 pos, float4x4 shadowMatrix, bool reverseZ)
    
    float4 lightScreen =  shadowMatrix * float4(pos, 1.f);
    
    
    
    if (!reverseZ) {
        lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
    } else {
        if (lightScreen.z <= 0.0) { 
            lightScreen.z = 2.0;
        }
    }
    return lightScreen;
inline float ComputeShadow(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, bool reverseZ)
    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);
    float shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);
    
    shadow *= step(0., lightScreen.w);
    
    return shadow;
inline float ComputeSoftShadowGrid(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, int sampleCount, bool reverseZ)
    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);
    
    float shadow;
    if (sampleCount <= 1) {
        shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);
    } else {
        float3 uvp = lightScreen.xyz / lightScreen.w;
        uvp.z += reverseZ ? 0.005f : -0.005f; 
        float2 texelSize = 2.f / float2(shadowMap.get_width(), shadowMap.get_height());
        float2 origin    = uvp.xy - (sampleCount * 0.5f) * texelSize;
        
        if (sampleCount <= 4) { 
            half totalAccum = 0.h;
            for (int y = 0; y < sampleCount; ++y) {
                for (int x = 0; x < sampleCount; ++x) {
                    totalAccum  += half(shadowMap.sample_compare(shadow_sampler, origin, uvp.z, 2 * int2(x,y)));
                }
            }
            shadow = totalAccum / half(sampleCount * sampleCount);
        } else {
            float totalAccum = 0.f;
            for (int y = 0; y < sampleCount; ++y) {
                for (int x = 0; x < sampleCount; ++x) {
                    float2 samplePos = origin + texelSize * float2(x, y);
                    totalAccum  += shadowMap.sample_compare(shadow_sampler, samplePos, uvp.z);
                }
            }
            shadow = totalAccum / float(sampleCount * sampleCount);
        }
    }
    
    shadow *= step(0., lightScreen.w);
    return shadow;
inline float ComputeSoftShadow(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount, float shadowRadius, bool reverseZ)
    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);
    
    float shadow;
    if (sampleCount <= 1) {
        shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);
    } else {
        
        float3 center_uv = lightScreen.xyz / lightScreen.w;
        float3 scale_uv  = float3(shadowRadius, shadowRadius, reverseZ ? shadowRadius * center_uv.z : shadowRadius / lightScreen.w );
        
        float totalAccum = 0.0;
        for (int i = 0; i < sampleCount; i++) {
            totalAccum += shadow2D(shadow_sampler, shadowMap, center_uv + shadowKernel[i].xyz * scale_uv);
        }
        
        shadow = totalAccum / float(sampleCount);
    }
    
    shadow *= step(0., lightScreen.w);
    return shadow;
inline float ComputeCascadeBlendAmount(float3 shadowPos, bool cascadeBlending)
    const float cascadeBlendingFactor = 0.1f; 
    float3 cascadePos = abs(shadowPos.xyz * 2.f - 1.f);
    
    if (cascadeBlending) {
#if 0
        const float edge = 1.f - cascadeBlendingFactor;
        
        cascadePos = 1.f - saturate((cascadePos - edge) / cascadeBlendingFactor);
        return cascadePos.x * cascadePos.y * cascadePos.z; 
#else
        
        float distToEdge = 1.0f - max(max(cascadePos.x, cascadePos.y), cascadePos.z);
        return smoothstep(0.0f, cascadeBlendingFactor, distToEdge);
#endif
    } else {
        return step(cascadePos.x, 1.f) * step(cascadePos.y, 1.f) * step(cascadePos.z, 1.f);
    }
inline float4 SampleShadowCascade(sampler shadow_sampler, depth2d_array<float> shadowMaps, float3 shadowPosition, uint cascadeIndex, constant float4* shadowKernel, int sampleCount, float shadowRadius)
    
    float2 gridSize = float2(shadowMaps.get_width(), shadowMaps.get_height()) / 32;
    float gd = scn::checkerboard(shadowPosition.xy, gridSize);
    float3 gridCol = mix(float3(scn::debugColorForCascade(cascadeIndex).rgb), float3(0.f), float3(gd > 0.f));
    
    float shadow = 0.f;
    if (sampleCount > 1) {
        
        for (int i = 0; i < sampleCount; ++i) {
            shadow += shadow2DArray(shadow_sampler, shadowMaps, shadowKernel[i].xyz * shadowRadius + shadowPosition, cascadeIndex);
        }
        shadow /= float(sampleCount);
    } else {
        
        shadow = shadow2DArray(shadow_sampler, shadowMaps, shadowPosition, cascadeIndex);
    }
    return float4(gridCol, shadow);
inline float4 ComputeCascadedShadow(sampler shadow_sampler, float3 viewPos, float4x4 shadowMatrix, constant float4 *cascadeScale, constant float4 *cascadeBias, int cascadeCount, depth2d_array<float> shadowMaps, bool enableCascadeBlending, constant float4* shadowKernel, int sampleCount, float shadowRadius)
    float4 shadow = 0.f;
    float opacitySum = 1.f;
    
    
    float3 pos_ls =  (shadowMatrix * float4(viewPos, 1.f)).xyz;
    for (int c = 0; c < cascadeCount; ++c) {
        
        float3 pos_cs =  pos_ls * cascadeScale[c].xyz + cascadeBias[c].xyz;
        
        float cascadeRadius = shadowRadius * cascadeScale[c].x;
        float opacity = ComputeCascadeBlendAmount(pos_cs, enableCascadeBlending);
        if (opacity > 0.f) { 
            
            float alpha = opacity * opacitySum;
            shadow += SampleShadowCascade(shadow_sampler, shadowMaps, pos_cs, c, shadowKernel, sampleCount, cascadeRadius) * alpha;
            opacitySum -= alpha;
        }
        if (opacitySum <= 0.f) 
            break;
    }
    return shadow;
#define LIGHT_TYPE(a)           ((a      ) & 0x7)
#define LIGHT_DIST_ATT(a)       ((a >> 3) & 0x7)
#define LIGHT_SPOT_ATT(a)       ((a >> 6) & 0x7)
#define LIGHT_HAS_GOBO(a)       (a & (1 << 9))
#define LIGHT_HAS_SHADOW(a)     (a & (1 << 10))
#define LIGHT_IS_MODULATE(a)    (a & (1 << 12))
#define LIGHT_IES_TYPE(a)       ((a >> 13) & 0x3)
#define LIGHT_SHADOW_SAMPLE(a)  ((a >> 15) & 0x1f)
#if defined(__METAL_VERSION__) 
enum C3DLightAttenuationType
    kC3DLightAttenuationTypeNone,
    kC3DLightAttenuationTypeConstant,
    kC3DLightAttenuationTypeLinear,
    kC3DLightAttenuationTypeQuadratic,
    kC3DLightAttenuationTypeExponent,
    kC3DLightAttenuationTypePhysicallyBased,
enum C3DLightType
    kC3DLightTypeAmbient,
    kC3DLightTypeDirectional,
    kC3DLightTypeOmni,
    kC3DLightTypeSpot,
    kC3DLightTypeProbe,
    kC3DLightTypeIES,
    kC3DLightTypeArea
enum C3DLightIESType
    kC3DLightIESType1D,
    kC3DLightIESType2D,
    kC3DLightIESTypeCubemap,
    kC3DLightIESTypeNone
#endif
struct SCNLightData {
    float4 color; 
    float4 pbrColor; 
    
    
    float3 position;  
    float3 direction; 
    float3 up; 
    float3 right; 
    
    float3 distanceAttenuation; 
    float3 spotAttenuation; 
    float shadowRadius; 
    float4x4 shadowMatrix; 
    "sequence" : [ "SceneKit_PostProcess"],
    "passes" : {
        "SceneKit_PostProcess" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "inputs" : {
                "colorBuffer" : "COLOR",
                "depthBuffer" : "DEPTH"
            },
            "draw" : "DRAW_QUAD",
            "clientProgram" : "NO",
            "program" : "C3D-GLSL-UNAVAILABLE",
        }
    },
    "symbols" : {
    },
uniform sampler2D downSampler;
uniform sampler2D blurSampler;
varying vec2 v_texCoord;
void main (void)
    vec4 down = texture2D( downSampler, v_texCoord);
    vec4 blur = texture2D( blurSampler, v_texCoord);
    float coc = max( down.a, 2. * blur.a - down.a );
gl_FragColor = vec4(down.rgb, coc);
    
    
    "sequence": [
                 "SceneKit_SSAO_DEPTH",
                 "SceneKit_SSAO"
                 ],
    "passes": {
        "SceneKit_SSAO_DEPTH": {
            "outputs": {
                "depth": "depth-target",
                "color": "ssao-depth"
            },
            "depthStates": {
                "clear": true
            },
            "colorStates": {
                "clear": true,
                "clearColor": "-100000. -100000. -100000. -100000."
            },
            "samples": 1,
            "__clientProgram": "NO",
            "draw": "DRAW_SCENE",
        },
        "SceneKit_SSAO": {
            "outputs": {
                "color": "COLOR"
            },
            "inputs": {
                "color": "COLOR"
            },
            "draw": "DRAW_QUAD",
            "clientProgram": "NO",
            "program": "C3D-GLSL-UNAVAILABLE"
        }
    },
    "symbols": {},
    "targets": {
        "depth-target": {
            "type": "depth",
        },
        "ssao-depth": {
            "format": "rgba16f",
            "type": "color",
            "global": true,
            "mipmapped": true,
            "scaleFactor": 1.0
        }
    }
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_renderScene</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderScene</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>color1</key>
<string>ALBEDO</string>
<key>color2</key>
<string>NORMAL_DEPTH</string>
<key>color3</key>
<string>DS3</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>drawSceneIncludesOverlays</key>
<true/>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
<key>targets</key>
<dict>
<key>ALBEDO</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>NORMAL_DEPTH</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba32f</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>DS3</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba32f</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
attribute vec4 a_position;
uniform mat4 u_modelViewProjectionTransform;
void main()
    gl_Position = u_modelViewProjectionTransform * a_position;
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
#import "scn_standard_lighting.h"
#import "scn_standard_constants.h"
#import "C3D-PBR.metal"
enum C3DLightingModel
    C3DLightingModelConstant,
    C3DLightingModelLambert,
    C3DLightingModelPhong,
    C3DLightingModelBlinn,
    C3DLightingModelNone,
    C3DLightingModelPhysicallyBased,
constant bool use_per_vertex_diffuse    = use_per_vertex_lighting;
constant bool use_per_vertex_specular   = use_per_vertex_lighting && use_specular;
constant bool use_per_pixel_lighting    = !use_per_vertex_lighting; 
constant bool lighting_model_is_pbr     = (lighting_model == C3DLightingModelPhysicallyBased);
constant bool use_pbr                   = is_function_constant_defined(lighting_model) && lighting_model_is_pbr;
constant bool use_io_texcoord0          = io_texcoord_count > 0;
constant bool use_io_texcoord1          = io_texcoord_count > 1;
constant bool use_io_texcoord2          = io_texcoord_count > 2;
constant bool use_io_texcoord3          = io_texcoord_count > 3;
constant bool use_io_texcoord4          = io_texcoord_count > 4;
constant bool use_io_texcoord5          = io_texcoord_count > 5;
constant bool use_io_texcoord6          = io_texcoord_count > 6;
constant bool use_io_texcoord7          = io_texcoord_count > 7;
constant bool use_no_instancing             = !use_instancing;
constant bool use_skinning                  = max_bone_count > 0;
constant bool has_multiple_bone_per_vertex  = max_bone_count > 1; 
constant bool use_skinningWeights           = use_skinning && has_multiple_bone_per_vertex; 
constant bool use_skinningJoints            = use_skinning;
constant bool dummy_shadow0             = LIGHT_HAS_SHADOW(use_light0);
constant bool use_shadow0               = is_function_constant_defined(use_light0) && dummy_shadow0;
constant bool dummy_shadow1             = LIGHT_HAS_SHADOW(use_light1);
constant bool use_shadow1               = is_function_constant_defined(use_light1) && dummy_shadow1;
constant bool dummy_shadow2             = LIGHT_HAS_SHADOW(use_light2);
constant bool use_shadow2               = is_function_constant_defined(use_light2) && dummy_shadow2;
constant bool dummy_shadow3             = LIGHT_HAS_SHADOW(use_light3);
constant bool use_shadow3               = is_function_constant_defined(use_light3) && dummy_shadow3;
constant bool dummy_gobo0               = LIGHT_HAS_GOBO(use_light0);
constant bool use_gobo0                 = is_function_constant_defined(use_light0) && dummy_gobo0;
constant bool dummy_gobo1               = LIGHT_HAS_GOBO(use_light1);
constant bool use_gobo1                 = is_function_constant_defined(use_light1) && dummy_gobo1;
constant bool dummy_gobo2               = LIGHT_HAS_GOBO(use_light2);
constant bool use_gobo2                 = is_function_constant_defined(use_light2) && dummy_gobo2;
constant bool dummy_gobo3               = LIGHT_HAS_GOBO(use_light3);
constant bool use_gobo3                 = is_function_constant_defined(use_light3) && dummy_gobo3;
constant bool dummy_ies0                = LIGHT_TYPE(use_light0) == kC3DLightTypeIES;
constant bool dummy_iesType2d0          = (LIGHT_IES_TYPE(use_light0) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube0        = (LIGHT_IES_TYPE(use_light0) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d0              = dummy_ies0 && dummy_iesType2d0;
constant bool dummy_iesCube0            = dummy_ies0 && dummy_iesTypeCube0;
constant bool use_ies0                  = is_function_constant_defined(use_light0) && dummy_ies2d0;
constant bool use_iesCube0              = is_function_constant_defined(use_light0) && dummy_iesCube0;
constant bool dummy_ies1                = LIGHT_TYPE(use_light1) == kC3DLightTypeIES;
constant bool dummy_iesType2d1          = (LIGHT_IES_TYPE(use_light1) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube1        = (LIGHT_IES_TYPE(use_light1) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d1              = dummy_ies1 && dummy_iesType2d1;
constant bool dummy_iesCube1            = dummy_ies1 && dummy_iesTypeCube1;
constant bool use_ies1                  = is_function_constant_defined(use_light1) && dummy_ies2d1;
constant bool use_iesCube1              = is_function_constant_defined(use_light1) && dummy_iesCube1;
constant bool dummy_ies2                = LIGHT_TYPE(use_light2) == kC3DLightTypeIES;
constant bool dummy_iesType2d2          = (LIGHT_IES_TYPE(use_light2) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube2        = (LIGHT_IES_TYPE(use_light2) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d2              = dummy_ies2 && dummy_iesType2d2;
constant bool dummy_iesCube2            = dummy_ies2 && dummy_iesTypeCube2;
constant bool use_ies2                  = is_function_constant_defined(use_light2) && dummy_ies2d2;
constant bool use_iesCube2              = is_function_constant_defined(use_light2) && dummy_iesCube2;
constant bool dummy_ies3                = LIGHT_TYPE(use_light3) == kC3DLightTypeIES;
constant bool dummy_iesType2d3          = (LIGHT_IES_TYPE(use_light3) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube3        = (LIGHT_IES_TYPE(use_light3) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d3              = dummy_ies3 && dummy_iesType2d3;
constant bool dummy_iesCube3            = dummy_ies3 && dummy_iesTypeCube3;
constant bool use_ies3                  = is_function_constant_defined(use_light3) && dummy_ies2d3;
constant bool use_iesCube3              = is_function_constant_defined(use_light3) && dummy_iesCube3;
constexpr sampler linearSampler(filter::linear, mip_filter::linear);
constexpr sampler shadowSampler(filter::linear, mip_filter::none, compare_func::greater_equal);
#define MAX_LIGHT_COUNT 8
typedef struct {
    
    float4x4 modelViewTransform;            
    
    float4x4 normalTransform;               
    
    float4x4 modelTransform;            
    uint8_t lightIndices[MAX_LIGHT_COUNT];  
    float nodeOpacity;                      
    
} scn_std_node;
typedef struct {
    float3 position         [[ attribute(SCNVertexSemanticPosition)]];
    float3 normal           [[ attribute(SCNVertexSemanticNormal),      function_constant(need_normal) ]];
    float4 tangent          [[ attribute(SCNVertexSemanticTangent),     function_constant(need_tangent) ]];
    float4 color            [[ attribute(SCNVertexSemanticColor)        function_constant(need_vertex_color) ]];
    float4 skinningWeights  [[ attribute(SCNVertexSemanticBoneWeights), function_constant(use_skinningWeights)]];
    uint4  skinningJoints   [[ attribute(SCNVertexSemanticBoneIndices), function_constant(use_skinningJoints)]];
    float2 texcoord0        [[ attribute(SCNVertexSemanticTexcoord0),   function_constant(need_texcoord0) ]];
    float2 texcoord1        [[ attribute(SCNVertexSemanticTexcoord1),   function_constant(need_texcoord1) ]];
    float2 texcoord2        [[ attribute(SCNVertexSemanticTexcoord2),   function_constant(need_texcoord2) ]];
    float2 texcoord3        [[ attribute(SCNVertexSemanticTexcoord3),   function_constant(need_texcoord3) ]];
    float2 texcoord4        [[ attribute(SCNVertexSemanticTexcoord4),   function_constant(need_texcoord4) ]];
    float2 texcoord5        [[ attribute(SCNVertexSemanticTexcoord5),   function_constant(need_texcoord5) ]];
    float2 texcoord6        [[ attribute(SCNVertexSemanticTexcoord6),   function_constant(need_texcoord6) ]];
    float2 texcoord7        [[ attribute(SCNVertexSemanticTexcoord7),   function_constant(need_texcoord7) ]];
} scn_vertex_t; 
typedef struct {
    float4 fragmentPosition [[position]]; 
    
    float fragmentSize  [[ point_size, function_constant(use_point_rendering) ]];
    float4 vertexColor  [[ function_constant(use_io_vertex_color) ]];
    float3 position     [[ function_constant(use_io_position) ]];
    float3 normal       [[ function_constant(use_io_normal) ]];
    float3 tangent      [[ function_constant(need_tangent) ]];
    float3 bitangent    [[ function_constant(need_tangent) ]];
    
    float2 texcoord0    [[ function_constant(use_io_texcoord0) ]];
    float2 texcoord1    [[ function_constant(use_io_texcoord1) ]];
    float2 texcoord2    [[ function_constant(use_io_texcoord2) ]];
    float2 texcoord3    [[ function_constant(use_io_texcoord3) ]];
    float2 texcoord4    [[ function_constant(use_io_texcoord4) ]];
    float2 texcoord5    [[ function_constant(use_io_texcoord5) ]];
    float2 texcoord6    [[ function_constant(use_io_texcoord6) ]];
    float2 texcoord7    [[ function_constant(use_io_texcoord7) ]];
    float3 diffuse      [[ function_constant(use_per_vertex_diffuse) ]];
    float3 specular     [[ function_constant(use_per_vertex_specular) ]];
    
#ifdef USE_EXTRA_VARYINGS
    __ExtraVaryingsDecl__
#endif
    
} commonprofile_io;
struct SCNShaderSurface {
    float3 view;                
    float3 position;            
    float3 normal;              
    float3 geometryNormal;      
    float2 normalTexcoord;      
    float3 tangent;             
    float3 bitangent;           
    float4 ambient;             
    float2 ambientTexcoord;     
    float4 diffuse;             
    float2 diffuseTexcoord;     
    float4 specular;            
    float2 specularTexcoord;    
    float4 emission;            
    float2 emissionTexcoord;    
    float4 multiply;            
    float2 multiplyTexcoord;    
    float4 transparent;         
    float2 transparentTexcoord; 
    float4 reflective;          
    float  metalness;           
    float2 metalnessTexcoord;   
    float  roughness;           
    float2 roughnessTexcoord;   
    float shininess;            
    float fresnel;              
    float ambientOcclusion;     
    float3 _normalTS;           
    
#ifdef USE_SURFACE_EXTRA_DECL
    __SurfaceExtraDecl__
#endif
struct SCNShaderGeometry
    float4 position;
    float3 normal;
    float4 tangent;
    float4 color;
    float2 texcoords[8]; 
struct commonprofile_uniforms {
    float4 diffuseColor;
    float4 specularColor;
    float4 ambientColor;
    float4 emissionColor;
    float4 reflectiveColor;
    float4 multiplyColor;
    float4 transparentColor;
    float metalness;
    float roughness;
    
    float diffuseIntensity;
    float specularIntensity;
    float normalIntensity;
    float ambientIntensity;
    float emissionIntensity;
    float reflectiveIntensity;
    float multiplyIntensity;
    float transparentIntensity;
    float metalnessIntensity;
    float roughnessIntensity;
    float displacementIntensity;
    
    float materialShininess;
    float selfIlluminationOcclusion;
    float transparency;
    float3 fresnel; 
    
    
    float4x4 textureTransforms[1];
#ifdef USE_SHADER_MODIFIERS
__ShaderModifiersDecl__
#endif
struct SCNShaderLightingContribution {
    float3 ambient;
    float3 diffuse;
    float3 specular;
    float3 modulate;
struct SCNLightingParameters {
    
    SCNLightData        lightData;
    uint                lightInfo;
    float3              lightDirection;
    float3              attenuation;
    SCNShaderSurface    surface;
static float3 scn_lighting_direction(SCNLightData lightData, uint lightInfo, thread SCNShaderSurface& surface)
    uint lightType = LIGHT_TYPE(lightInfo);
    if (lightType == kC3DLightTypeDirectional) {
        return lightData.direction;
    }
    return normalize(lightData.position - surface.position);
    
static void scn_lambert_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    
    float3 intensity = lightData.color.rgb * max(0.f, dot(surface.normal, l));
    lightingContribution.diffuse += intensity;
static void scn_blinn_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    float3 intensity =  lightData.color.rgb * max(0.f, dot(surface.normal, l));
    lightingContribution.diffuse += intensity;
    float3 h = normalize(l + surface.view);
    lightingContribution.specular += powr(max(0.f, dot(surface.normal, h)), surface.shininess) * intensity;
static void scn_phong_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    
    float3 intensity = lightData.color.rgb * max(0.f, dot(surface.normal, l));
    lightingContribution.diffuse += intensity;
    
    float3 r = reflect(-l, surface.normal);
    lightingContribution.specular += pow(max(0.f, dot(r, surface.view)), surface.shininess) * intensity;
inline void scn_pbr_lightingContribution_pointLight(float3         l,
                                                    float3         n,
                                                    float3         v,
                                                    float3         albedo,
                                                    float          metalness,
                                                    float          roughness,
                                                    thread float3& lightingContributionDiffuse,
                                                    thread float3& lightingContributionSpecular)
    float3 h = normalize(l + v);
    
    float NoL = saturate(dot(n, l));
    float NoH = saturate(dot(n, h));
    float LoH = saturate(dot(l, h));
    
    float  effectiveAlbedo = (1.f - metalness); 
    float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), albedo, metalness);
    
    float alpha = roughness * roughness; 
    
    float D   = scn_brdf_D(alpha, NoH);
    float3 F  = scn_brdf_F_opt(reflectance, LoH);
#if 0 
    float Vis = scn_brdf_V_opt(alpha, LoH);
#else
    float NoV = saturate(dot(n, v));
    float Vis = scn_brdf_V(alpha, NoL, NoV);
#endif
    
    lightingContributionDiffuse = NoL * effectiveAlbedo * M_1_PI_F;
    lightingContributionSpecular = NoL * D * F * Vis;
static void scn_pbr_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    
    float3 diffuseOut, specularOut;
    scn_pbr_lightingContribution_pointLight(l, surface.normal.xyz, surface.view, surface.diffuse.rgb, surface.metalness, surface.roughness, diffuseOut, specularOut);
    
    lightingContribution.diffuse    += diffuseOut  * lightData.pbrColor.rgb;
    lightingContribution.specular   += specularOut * lightData.pbrColor.rgb;
static float scn_distance_attenuation(SCNLightingParameters params)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    float3 l = params.surface.position - lightData.position;
    if (use_pbr) {
        uint lightType = LIGHT_TYPE(lightInfo);
        if (lightType == kC3DLightTypeDirectional) { 
            return 1.f;
        }
        return scn_pbr_distanceAttenuation(l);
    } else {
        uint distAttType = LIGHT_DIST_ATT(lightInfo);
        if (distAttType != kC3DLightAttenuationTypeNone) {
            
            float3 att = lightData.distanceAttenuation;
            float dist = length(l);
            switch (distAttType) {
                case kC3DLightAttenuationTypeConstant:
                    return step(dist, att.x);
                case kC3DLightAttenuationTypeLinear:
                    return saturate(dist * att.x + att.y);
                case kC3DLightAttenuationTypeQuadratic:
                    return scn::sq(saturate(dist * att.x + att.y));
                case kC3DLightAttenuationTypeExponent:
                    return pow(saturate(dist * att.x + att.y), att.z);
            }
        }
    }
    return 1.f;
static float scn_spot_attenuation(SCNLightingParameters params)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    float3 l                = params.lightDirection;
    
    uint spotAttType = LIGHT_SPOT_ATT(lightInfo);
    if (spotAttType != kC3DLightAttenuationTypeNone) {
        
        float3 spotFactors = lightData.spotAttenuation;
        switch (spotAttType) {
            case kC3DLightAttenuationTypeConstant:
                return step(spotFactors.x, dot(l, lightData.direction));
            case kC3DLightAttenuationTypeLinear:
                return saturate(dot(l, lightData.direction) * spotFactors.x + spotFactors.y);
            case kC3DLightAttenuationTypeQuadratic:
                return scn::sq(saturate(dot(l, lightData.direction) * spotFactors.x + spotFactors.y));
            case kC3DLightAttenuationTypeExponent:
                return pow(saturate(dot(l, lightData.direction) * spotFactors.x + spotFactors.y), spotFactors.z);
        }
    }
    return 1.f;
static void scn_do_gobo(thread SCNLightingParameters& params, texture2d<float> goboMap)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    float goboIntensity = lightData.color.a; 
    float3 goboColor = texture2DProj(goboMap, linearSampler, (lightData.shadowMatrix * float4(params.surface.position, 1.f))).rgb;
    if (LIGHT_IS_MODULATE(lightInfo)) {
        params.attenuation *= mix(float3(1.), goboColor, goboIntensity);
    } else {
        params.attenuation *= goboColor * goboIntensity;
    }
static void scn_do_ies(thread SCNLightingParameters& params, texture2d<float> iesMap, sampler iesSampler)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    
    params.lightDirection   = scn_lighting_direction(params.lightData, lightInfo, params.surface);
    float3 spotFactors      = lightData.spotAttenuation;
    float att = 0.f;
    switch (LIGHT_IES_TYPE(lightInfo)) {
        case kC3DLightIESType1D:
            att = iesMap.sample(iesSampler, float2(acos(dot(params.lightDirection, lightData.direction))*spotFactors.x, 0.f)).r;
            break;
            
        case kC3DLightIESType2D:
        {
            
            float vertAngle     = acos(dot(params.lightDirection, lightData.direction));
            
            float3 surfaceRay   = params.surface.position - lightData.position;
            float3 projPos = normalize(surfaceRay - dot(surfaceRay, lightData.direction) * lightData.direction);
            float2 texCoord = float2(dot(projPos, lightData.right), dot(projPos, lightData.up)) * vertAngle * spotFactors.x;
            att = iesMap.sample(iesSampler, texCoord * 0.5f + 0.5f).r;
            
        } break;
    }
    params.attenuation.rgb *= att;
static void scn_do_ies(thread SCNLightingParameters& params, texturecube<float> iesMap, sampler iesSampler)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    
    params.lightDirection   = scn_lighting_direction(params.lightData, lightInfo, params.surface);
    if (LIGHT_IES_TYPE(lightInfo) == kC3DLightIESTypeCubemap) {
        float att = iesMap.sample(iesSampler, (lightData.shadowMatrix * float4(params.surface.position, 1.f)).xyz).r;
        params.attenuation.rgb *= att;
    } 
static void scn_do_shadow(thread SCNLightingParameters& params, depth2d<float> shadowMap, constant float4* u_shadowKernel)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    
    uchar sampleCount = LIGHT_SHADOW_SAMPLE(lightInfo);
    
    float4 lightScreen = lightData.shadowMatrix * float4(params.surface.position, 1.f);
    
    float shadowRadius = lightData.shadowRadius;
    
    float shadowingTerm = 0.f;
    if (sampleCount > 1) { 
        float filteringSizeFactor = shadowRadius * lightScreen.w;
        for (int i = 0; i < sampleCount; i++) {
            
            shadowingTerm += shadow2DProj(shadowSampler, shadowMap, lightScreen + (u_shadowKernel[i] * filteringSizeFactor));
        }
        shadowingTerm /= float(sampleCount);
    } else {
        shadowingTerm = shadow2DProj(shadowSampler, shadowMap, lightScreen);
    }
    
    
    
    params.attenuation *= (1.f - shadowingTerm * lightData.color.a);
static void scn_do_light(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContrib)
    uint lightInfo          = params.lightInfo;
    
    params.lightDirection   = scn_lighting_direction(params.lightData, lightInfo, params.surface);
    
    
    
    float attenuation = scn_distance_attenuation(params);
    
    
    uint lightType = LIGHT_TYPE(lightInfo);
    if (lightType == kC3DLightTypeSpot) {
        attenuation *= scn_spot_attenuation(params);
    }
    params.attenuation *= attenuation;
    
    params.lightData.color.rgb *= params.attenuation;
    params.lightData.pbrColor.rgb *= params.attenuation;
    switch (lighting_model) {
        case C3DLightingModelLambert:
            scn_lambert_lighting(params, lightingContrib);
            break;
        case C3DLightingModelBlinn:
            scn_blinn_lighting(params, lightingContrib);
            break;
        case C3DLightingModelPhong:
            scn_phong_lighting(params, lightingContrib);
            break;
        case C3DLightingModelPhysicallyBased:
            scn_pbr_lighting(params, lightingContrib);
            break;
        default:
            
            break;
            
            
    }
inline SCNPBRSurface SCNShaderSurfaceToSCNPBRSurface(SCNShaderSurface surface)
    SCNPBRSurface s;
    
    s.n = surface.normal;
    s.v = surface.view;
    s.albedo = surface.diffuse.xyz;
    
    if (use_emission)
        s.emission = surface.emission.xyz;
    else
        s.emission = float3(0.);
    
    s.metalness = surface.metalness;
    s.roughness = surface.roughness;
    s.ao = surface.ambientOcclusion;
    return s;
static float4 scn_pbr_combine_cubemap(SCNPBRSurface                      surface,
                                     SCNShaderLightingContribution      lighting,
                                     texture2d<float, access::sample>   specularDFG,
                                     texturecube<float, access::sample> specularLD,
                                     texturecube<float, access::sample> irradianceTexture,
                                     constant SCNSceneBuffer&           scn_frame)
    
    float4x4 localDirToWorldCubemapDir = scn_frame.viewToCubeTransform;
    float environmentIntensity = scn_frame.environmentIntensity;
    
    float3 n = surface.n;
    float3 v = surface.v;
    float3 albedo = surface.albedo;
    float metalness = surface.metalness;
    float roughness = surface.roughness;
    float ambientOcclusion = surface.ao;
    
    float3 r = reflect(-v, n); 
    float NoV = saturate(dot(n, v));
    
    float3 diffuseDominantNDirection = n;
    float3 specularDominantNDirection = r;
    
    
    diffuseDominantNDirection = scn::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);
    
    float3 irradiance;
    if (use_emission_as_selfIllumination) {
        irradiance = surface.emission;
    } else {
        
        irradiance = irradianceTexture.sample(linearSampler, diffuseDominantNDirection).rgb * environmentIntensity;
    }
    
    
    float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);
    
    float3 LD = specularLD.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection), level(mipLevel)).rgb * environmentIntensity;
    float2 DFG = specularDFG.sample(linearSampler, float2(NoV, roughness)).rg;
    
    float3 effectiveAlbedo = mix(albedo, float3(0.0), metalness);
    float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), albedo, metalness);
    
    float3 diffuse = effectiveAlbedo * irradiance;
    float3 specular = LD * (reflectance * DFG.r + DFG.g);
    
    
    float3 ibl_color;
    if (use_emission_as_selfIllumination) { 
        
        float selfIlluminationAmbientOcclusion = saturate(mix(1., ambientOcclusion, surface.selfIlluminationOcclusion));
        ibl_color = selfIlluminationAmbientOcclusion * diffuse + ambientOcclusion * specular;
    } else {
        ibl_color = ambientOcclusion * (diffuse + specular);
    }
    
    float4 color;
    color.rgb = (lighting.ambient * surface.ao + lighting.diffuse) * surface.albedo.rgb + lighting.specular + ibl_color;
    
    if (use_emission && !use_emission_as_selfIllumination)
        color.rgb += surface.emission.rgb;
    
    return color;
static float4 scn_pbr_combine_probes(SCNPBRSurface                      surface,
                              SCNShaderLightingContribution      lighting,
                              texture2d<float, access::sample>   specularDFG,
                              texturecube<float, access::sample> specularLD,
                              sh3_coefficients                   shCoefficients,
                              constant SCNSceneBuffer&           scn_frame)
    
    float4x4 localDirToWorldCubemapDir = scn_frame.viewToCubeTransform;
    float environmentIntensity = scn_frame.environmentIntensity;
    
    float3 n = surface.n;
    float3 v = surface.v;
    float3 albedo = surface.albedo;
    float metalness = surface.metalness;
    float roughness = surface.roughness;
    float ambientOcclusion = surface.ao;
    
    float3 r = reflect(-v, n); 
    float NoV = saturate(dot(n, v));
    
    float3 diffuseDominantNDirection = n;
    float3 specularDominantNDirection = r;
    
    
    diffuseDominantNDirection = scn::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);
    
    float3 irradiance;
    if (use_emission_as_selfIllumination) {
        irradiance = surface.emission;
    } else {
        irradiance = shEvalDirection(float4(diffuseDominantNDirection, 1.), shCoefficients) * environmentIntensity;
    }
    
    
    float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);
    
    float3 LD = specularLD.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection), level(mipLevel)).rgb * environmentIntensity;
    float2 DFG = specularDFG.sample(linearSampler, float2(NoV, roughness)).rg;
    
    float3 effectiveAlbedo = mix(albedo, float3(0.0), metalness);
    float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), albedo, metalness);
    
    float3 diffuse = effectiveAlbedo * irradiance;
    float3 specular = LD * (reflectance * DFG.r + DFG.g);
    
    
    float3 ibl_color;
    if (use_emission_as_selfIllumination) { 
        
        float selfIlluminationAmbientOcclusion = saturate(mix(1., ambientOcclusion, surface.selfIlluminationOcclusion));
        ibl_color = selfIlluminationAmbientOcclusion * diffuse + ambientOcclusion * specular;
    } else {
        ibl_color = ambientOcclusion * (diffuse + specular);
    }
    
    float4 color;
    color.rgb = (lighting.ambient * surface.ao + lighting.diffuse) * surface.albedo.rgb + lighting.specular + ibl_color;
    
    if (use_emission && !use_emission_as_selfIllumination)
        color.rgb += surface.emission.rgb;
    
    return color;
inline float4 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    float4 color = {0.,0.,0., surface.diffuse.a};
    
    float3 D = lighting.diffuse;
    if (use_ambient_lighting)
        D += lighting.ambient * surface.ambientOcclusion;
    if (use_emission_as_selfIllumination)
        D += surface.emission.rgb;
    
    color.rgb = surface.diffuse.rgb * D;
    if (use_specular || use_reflective) {
        float3 S = (use_specular) ? lighting.specular : float3(0.);
        if (use_reflective)
            S += surface.reflective.rgb * surface.ambientOcclusion;
        if (use_specular)
            S *= surface.specular.rgb;
        color.rgb += S;
    }
    
    if (use_ambient && !use_ambient_as_ambientOcclusion)
        color.rgb += surface.ambient.rgb * lighting.ambient;
    if (use_emission && !use_emission_as_selfIllumination)
        color.rgb += surface.emission.rgb;
    if (use_multiply)
        color.rgb *= surface.multiply.rgb;
    if (use_modulate_lighting)
        color.rgb *= lighting.modulate;
    return color;
struct scn_patch_t {
    patch_control_point<scn_vertex_t> controlPoints;
static void standard_initalize_surface(thread SCNShaderSurface&  surface,
                                       thread SCNShaderGeometry& geometry,
                                       thread scn_std_node&      in_node)
    
    surface.position = (in_node.modelViewTransform * geometry.position).xyz;
    
    if (use_io_normal)
        surface.normal = normalize(scn::mat3(in_node.normalTransform) * geometry.normal);
    
    if (need_tangent) {
        surface.tangent = normalize(scn::mat3(in_node.normalTransform) * geometry.tangent.xyz);
        
        surface.bitangent = geometry.tangent.w * cross(surface.tangent, surface.normal);
    }
    if (use_io_view)
        surface.view = normalize(-surface.position);
static void standard_initalize_geometry(thread scn_vertex_t&      in,
                                        thread SCNShaderGeometry& geometry)
    geometry.position = float4(in.position, 1.f);
    
    if (need_normal)
        geometry.normal = in.normal;
    
    if (need_tangent)
        geometry.tangent = in.tangent;
    
    if (need_texcoord0)
        geometry.texcoords[0] = in.texcoord0;
    if (need_texcoord1)
        geometry.texcoords[1] = in.texcoord1;
    if (need_texcoord2)
        geometry.texcoords[2] = in.texcoord2;
    if (need_texcoord3)
        geometry.texcoords[3] = in.texcoord3;
    if (need_texcoord4)
        geometry.texcoords[4] = in.texcoord4;
    if (need_texcoord5)
        geometry.texcoords[5] = in.texcoord5;
    if (need_texcoord6)
        geometry.texcoords[6] = in.texcoord6;
    if (need_texcoord7)
        geometry.texcoords[7] = in.texcoord7;
    
    geometry.color = (need_vertex_color) ? in.color : float4(1.f);
static void standard_initalize_geometry_post_tessellation(thread scn_patch_t&       in,
                                                          thread SCNShaderGeometry& geometry,
                                                          float3                    patchCoord)
    geometry.position = float4(scn::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.0);
    
    if (need_normal)
        geometry.normal = normalize(scn::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));
    
    if (need_tangent)
        geometry.tangent = normalize(scn::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));
    
    if (need_texcoord0)
        geometry.texcoords[0] = scn::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);
    if (need_texcoord1)
        geometry.texcoords[1] = scn::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);
    if (need_texcoord2)
        geometry.texcoords[2] = scn::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);
    if (need_texcoord3)
        geometry.texcoords[3] = scn::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);
    if (need_texcoord4)
        geometry.texcoords[4] = scn::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);
    if (need_texcoord5)
        geometry.texcoords[5] = scn::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);
    if (need_texcoord6)
        geometry.texcoords[6] = scn::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);
    if (need_texcoord7)
        geometry.texcoords[7] = scn::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);
    
    geometry.color = (need_vertex_color) ? scn::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord) : float4(1.f);
static void standard_apply_skinning(float4                    skinningWeights,
                                    uint4                     skinningJoints,
                                    constant float4*          skinningJointMatrices,
                                    thread SCNShaderGeometry& geometry)
    float3 pos = 0.f;
    float3 nrm = 0.f;
    float3 tgt = 0.f;
    for (int i = 0; i < max_bone_count; ++i) {
        float weight = (max_bone_count > 1) ? skinningWeights[i] : 1.f;
        if (weight <= 0.f)
            continue;
        
        int idx = int(skinningJoints[i]) * 3;
        float4x4 jointMatrix = float4x4(skinningJointMatrices[idx],
                                        skinningJointMatrices[idx+1],
                                        skinningJointMatrices[idx+2],
                                        float4(0.f, 0.f, 0.f, 1.f));
        
        pos += (geometry.position * jointMatrix).xyz * weight;
        if (need_normal)
            nrm += geometry.normal * scn::mat3(jointMatrix) * weight;
        if (need_tangent)
            tgt += geometry.tangent.xyz * scn::mat3(jointMatrix) * weight;
    }
    
    geometry.position.xyz = pos;
    
    if (need_normal)
        geometry.normal = nrm;
    
    if (need_tangent)
        geometry.tangent.xyz = tgt;
static void standard_configure_out(constant commonprofile_uniforms& commonprofile,
                                   thread SCNShaderSurface&         surface,
                                   thread SCNShaderGeometry&        geometry,
                                   thread commonprofile_io&         out)
    if (use_io_position)
        out.position = surface.position;
    
    if (use_io_normal)
        out.normal = surface.normal;
    
    if (need_tangent) {
        out.tangent = surface.tangent;
        out.bitangent = surface.bitangent;
    }
    
    if (use_io_vertex_color)
        out.vertexColor = geometry.color;
    
    float2 uvOut[kSCNTexcoordCount];
    
    if (is_function_constant_defined(diffuse_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ diffuse_channel ];
        if (is_function_constant_defined(diffuse_transform_index))
            uv = (commonprofile.textureTransforms[diffuse_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ diffuse_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(normal_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ normal_channel ];
        if (is_function_constant_defined(normal_transform_index))
            uv = (commonprofile.textureTransforms[normal_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ normal_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(transparent_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ transparent_channel ];
        if (is_function_constant_defined(transparent_transform_index))
            uv = (commonprofile.textureTransforms[transparent_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ transparent_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(emission_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ emission_channel ];
        if (is_function_constant_defined(emission_transform_index))
            uv = (commonprofile.textureTransforms[emission_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ emission_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(ambient_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ ambient_channel ];
        if (is_function_constant_defined(ambient_transform_index))
            uv = (commonprofile.textureTransforms[ambient_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ ambient_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(multiply_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ multiply_channel ];
        if (is_function_constant_defined(multiply_transform_index))
            uv = (commonprofile.textureTransforms[multiply_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ multiply_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(specular_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ specular_channel ];
        if (is_function_constant_defined(specular_transform_index))
            uv = (commonprofile.textureTransforms[specular_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ specular_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(roughness_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ roughness_channel ];
        if (is_function_constant_defined(roughness_transform_index))
            uv = (commonprofile.textureTransforms[roughness_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ roughness_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(metalness_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ metalness_channel ];
        if (is_function_constant_defined(metalness_transform_index))
            uv = (commonprofile.textureTransforms[metalness_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ metalness_texcoord_io_index ] = uv;
    }
    
    switch (io_texcoord_count - 1) {
        case 7 : out.texcoord7 = uvOut[7];
        case 6 : out.texcoord6 = uvOut[6];
        case 5 : out.texcoord5 = uvOut[5];
        case 4 : out.texcoord4 = uvOut[4];
        case 3 : out.texcoord3 = uvOut[3];
        case 2 : out.texcoord2 = uvOut[2];
        case 1 : out.texcoord1 = uvOut[1];
        case 0 : out.texcoord0 = uvOut[0];
    }
vertex commonprofile_io standard_vert(scn_vertex_t                      in                        [[ stage_in ]],
                                      constant SCNSceneBuffer&          scn_frame                 [[ buffer(0) ]],
                                      constant scn_std_node&            scn_node                  [[ buffer(1), function_constant(use_no_instancing) ]],
                                      
                                      device scn_std_node*              scn_nodeInstances         [[ buffer(1), function_constant(use_instancing) ]],
                                      device SCNLightData*              scn_lights                [[ buffer(2), function_constant(use_per_vertex_lighting) ]],
                                      constant commonprofile_uniforms&  scn_commonprofile         [[ buffer(3) ]],
                                      constant float4*                  scn_skinningJointMatrices [[ buffer(4), function_constant(use_skinning) ]], 
                                      uint                              instanceID                [[ instance_id, function_constant(use_instancing) ]]
                                      
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
                                      __VertexExtraArguments__
#endif
                                      )
    scn_std_node in_node;
    if (use_instancing) {
        in_node = scn_nodeInstances[instanceID];
    } else {
        in_node = scn_node;
    }
    SCNShaderGeometry _geometry;
    standard_initalize_geometry(in, _geometry);
    if (use_skinning) {
        standard_apply_skinning(in.skinningWeights, in.skinningJoints, scn_skinningJointMatrices, _geometry);
    }
    
#ifdef USE_GEOMETRY_MODIFIER
__DoGeometryModifier__
#endif
    
    
    SCNShaderSurface _surface;
    standard_initalize_surface(_surface, _geometry, in_node);
    commonprofile_io out;
    
    
    if (use_per_vertex_lighting) {
        SCNShaderLightingContribution _lightingContribution;
        _lightingContribution.diffuse = 0.;
        _lightingContribution.specular = 0.;
        _surface.shininess = scn_commonprofile.materialShininess;
        
        
        out.diffuse = _lightingContribution.diffuse;
        if (use_specular)
            out.specular = _lightingContribution.specular;
    }
    standard_configure_out(scn_commonprofile, _surface, _geometry, out);
    
    
    
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.f);
    
    if (use_point_rendering) 
        out.fragmentSize = 1.f;
    return out;
[[ patch(triangle, 3) ]]
vertex commonprofile_io standard_post_tessellation_vert(scn_patch_t                       in                        [[ stage_in ]],
                                                        float3                            patchCoord                [[ position_in_patch ]],
                                                        constant SCNSceneBuffer&          scn_frame                 [[ buffer(0) ]],
                                                        constant scn_std_node&            scn_node                  [[ buffer(1), function_constant(use_no_instancing) ]],
                                                        
                                                        device scn_std_node*              scn_nodeInstances         [[ buffer(1), function_constant(use_instancing) ]],
                                                        device SCNLightData*              scn_lights                [[ buffer(2), function_constant(use_per_vertex_lighting) ]],
                                                        constant commonprofile_uniforms&  scn_commonprofile         [[ buffer(3) ]],
                                                        constant float4*                  scn_skinningJointMatrices [[ buffer(4), function_constant(use_skinning) ]], 
                                                        
                                                        uint                              instanceID                [[ instance_id, function_constant(use_instancing) ]]
                                                        
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
                                      __VertexExtraArgumentsPostTessellation__
#endif
                                      )
    scn_std_node in_node;
    if (use_instancing) {
        in_node = scn_nodeInstances[instanceID];
    } else {
        in_node = scn_node;
    }
    
    SCNShaderGeometry _geometry;
    standard_initalize_geometry_post_tessellation(in, _geometry, patchCoord);
    
    if (use_skinning) {
        
    }
    
#ifdef USE_GEOMETRY_MODIFIER
    
    __DoGeometryModifierPostTessellation__
    
#endif
    
    
    SCNShaderSurface _surface;
    standard_initalize_surface(_surface, _geometry, in_node);
    
    commonprofile_io out;
    
    
    if (use_per_vertex_lighting) {
        SCNShaderLightingContribution _lightingContribution;
        _lightingContribution.diffuse = 0.;
        _lightingContribution.specular = 0.;
        _surface.shininess = scn_commonprofile.materialShininess;
        
        
        
        
        out.diffuse = _lightingContribution.diffuse;
        if (use_specular)
            out.specular = _lightingContribution.specular;
    }
    
    standard_configure_out(scn_commonprofile, _surface, _geometry, out);
    
    
    
    
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.f);
    
    if (use_point_rendering) 
        out.fragmentSize = 1.f;
    return out;
struct SCNOutput
    float4 color;
fragment half4 standard_frag(commonprofile_io in [[stage_in]],
                             constant commonprofile_uniforms& scn_commonprofile [[buffer(0)]],
                             constant SCNSceneBuffer& scn_frame [[buffer(1)]]
                             
                             , device SCNLightData* scn_lights                     [[ buffer(2),  function_constant(use_per_pixel_lighting) ]]
                             , constant scn_std_node& scn_node                     [[ buffer(3), function_constant(use_no_instancing) ]]
                             , device scn_std_node* scn_nodeInstances              [[ buffer(3), function_constant(use_instancing) ]]
                             , constant float4* u_shadowKernel                     [[ buffer(4) ]] 
                             , constant sh3_coefficients& scn_shCoefficients       [[ buffer(5), function_constant(use_probes_lighting) ]]
                             , texture2d<float> u_emissionTexture                  [[ texture(0), function_constant(use_emission_map)]]
                             , sampler          u_emissionTextureSampler           [[ sampler(0), function_constant(use_emission_map)]]
                             , texture2d<float> u_ambientTexture                   [[ texture(1), function_constant(use_ambient_map)]]
                             , sampler          u_ambientTextureSampler            [[ sampler(1), function_constant(use_ambient_map)]]
                             , texture2d<float> u_diffuseTexture                   [[ texture(2), function_constant(use_diffuse_map)]]
                             , sampler          u_diffuseTextureSampler            [[ sampler(2), function_constant(use_diffuse_map)]]
                             , texture2d<float> u_specularTexture                  [[ texture(3), function_constant(use_specular_map)]]
                             , sampler          u_specularTextureSampler           [[ sampler(3), function_constant(use_specular_map)]]
                             , texture2d<float> u_reflectiveTexture                [[ texture(4), function_constant(use_reflective_map)]]
                             , sampler          u_reflectiveTextureSampler         [[ sampler(4), function_constant(use_reflective_map)]]
                             , texturecube<float> u_reflectiveCubeTexture          [[ texture(4), function_constant(use_reflectivecube_map)]]
                             , sampler            u_reflectiveCubeTextureSampler   [[ sampler(4), function_constant(use_reflectivecube_map)]]
                             , texture2d<float> u_transparentTexture               [[ texture(5), function_constant(use_transparent_map)]]
                             , sampler          u_transparentTextureSampler        [[ sampler(5), function_constant(use_transparent_map)]]
                             , texture2d<float> u_multiplyTexture                  [[ texture(6), function_constant(use_multiply_map)]]
                             , sampler          u_multiplyTextureSampler           [[ sampler(6), function_constant(use_multiply_map)]]
                             , texture2d<float> u_normalTexture                    [[ texture(7), function_constant(use_normal_map)]]
                             , sampler          u_normalTextureSampler             [[ sampler(7), function_constant(use_normal_map)]]
                             , texture2d<float> u_metalnessTexture                 [[ texture(3), function_constant(use_metalness_map) ]]
                             , sampler          u_metalnessTextureSampler          [[ sampler(3), function_constant(use_metalness_map) ]]
                             , texture2d<float> u_roughnessTexture                 [[ texture(4), function_constant(use_roughness_map) ]]
                             , sampler          u_roughnessTextureSampler          [[ sampler(4), function_constant(use_roughness_map) ]]
                             , texturecube<float> u_irradianceTexture              [[ texture(8), function_constant(use_pbr) ]]
                             
                             , texturecube<float> u_radianceTexture                [[ texture(9), function_constant(use_pbr) ]]
                             , texture2d<float>   u_specularDFGTexture             [[ texture(10), function_constant(use_pbr) ]]
                             , texture2d<float> u_ssaoTexture                      [[ texture(11), function_constant(use_ssao) ]]
                             
                             , depth2d<float> u_shadowTexture0                     [[ texture(12), function_constant(use_shadow0) ]]
                             , depth2d<float> u_shadowTexture1                     [[ texture(13), function_constant(use_shadow1) ]]
                             , depth2d<float> u_shadowTexture2                     [[ texture(14), function_constant(use_shadow2) ]]
                             , depth2d<float> u_shadowTexture3                     [[ texture(15), function_constant(use_shadow3) ]]
                             
                             
                             , texture2d<float> u_goboTexture0                     [[ texture(16), function_constant(use_gobo0) ]]
                             , texture2d<float> u_goboTexture1                     [[ texture(17), function_constant(use_gobo1) ]]
                             , texture2d<float> u_goboTexture2                     [[ texture(18), function_constant(use_gobo2) ]]
                             , texture2d<float> u_goboTexture3                     [[ texture(19), function_constant(use_gobo3) ]]
                             
                             
                             
                             
                             
                             , texture2d<float> u_iesTexture0                      [[ texture(16), function_constant(use_ies0) ]]
                             , texture2d<float> u_iesTexture1                      [[ texture(17), function_constant(use_ies1) ]]
                             , texture2d<float> u_iesTexture2                      [[ texture(18), function_constant(use_ies2) ]]
                             , texture2d<float> u_iesTexture3                      [[ texture(19), function_constant(use_ies3) ]]
                             
                             , texturecube<float> u_iesCubeTexture0                [[ texture(16), function_constant(use_iesCube0) ]]
                             , texturecube<float> u_iesCubeTexture1                [[ texture(17), function_constant(use_iesCube1) ]]
                             , texturecube<float> u_iesCubeTexture2                [[ texture(18), function_constant(use_iesCube2) ]]
                             , texturecube<float> u_iesCubeTexture3                [[ texture(19), function_constant(use_iesCube3) ]]
                             
                             , bool isFrontFacing                                  [[ front_facing, function_constant(use_double_sided) ]]
#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS
__FragmentExtraArguments__
#endif
                             )
    
    
    scn_std_node in_node;
    if (use_instancing) {
        
        in_node = scn_nodeInstances[0];
    } else {
        in_node = scn_node;
    }
    SCNShaderSurface _surface;
    float2 uv[kSCNTexcoordCount];
    switch (io_texcoord_count - 1) {
        case 7 : uv[7] = in.texcoord7;
        case 6 : uv[6] = in.texcoord6;
        case 5 : uv[5] = in.texcoord5;
        case 4 : uv[4] = in.texcoord4;
        case 3 : uv[3] = in.texcoord3;
        case 2 : uv[2] = in.texcoord2;
        case 1 : uv[1] = in.texcoord1;
        case 0 : uv[0] = in.texcoord0;
    }
    if (is_function_constant_defined(diffuse_texcoord_io_index))
        _surface.diffuseTexcoord = uv[diffuse_texcoord_io_index];
    
    if (is_function_constant_defined(normal_texcoord_io_index))
        _surface.normalTexcoord = uv[normal_texcoord_io_index];
    
    if (is_function_constant_defined(transparent_texcoord_io_index))
        _surface.transparentTexcoord = uv[transparent_texcoord_io_index];
    
    if (is_function_constant_defined(emission_texcoord_io_index))
        _surface.emissionTexcoord = uv[emission_texcoord_io_index];
    
    if (is_function_constant_defined(ambient_texcoord_io_index))
        _surface.ambientTexcoord = uv[ambient_texcoord_io_index];
    
    if (is_function_constant_defined(multiply_texcoord_io_index))
        _surface.multiplyTexcoord = uv[multiply_texcoord_io_index];
    
    if (is_function_constant_defined(specular_texcoord_io_index))
        _surface.specularTexcoord = uv[specular_texcoord_io_index];
    
    if (is_function_constant_defined(roughness_texcoord_io_index))
        _surface.roughnessTexcoord = uv[roughness_texcoord_io_index];
    if (is_function_constant_defined(metalness_texcoord_io_index))
        _surface.metalnessTexcoord = uv[metalness_texcoord_io_index];
    _surface.ambientOcclusion = 1.f; 
    if (use_ambient_map) {
        float4 c = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);
        if (is_function_constant_defined(ambient_texture_component)) {
            c = c[ambient_texture_component];
        }
        
        if (use_ambient_as_ambientOcclusion) {
            _surface.ambientOcclusion = c.r;
            if (use_ambient_intensity)
                _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, scn_commonprofile.ambientIntensity));
        } else {
            _surface.ambient = c;
            if (use_ambient_intensity)
                _surface.ambient *= scn_commonprofile.ambientIntensity;
        }
    } else {
        _surface.ambient = scn_commonprofile.ambientColor;
    }
    if (use_ambient && use_io_vertex_color)
        _surface.ambient *= in.vertexColor;
    if (use_ssao)
        _surface.ambientOcclusion *= u_ssaoTexture.sample( linearSampler, in.fragmentPosition.xy * scn_frame.inverseResolution.xy ).x;
    
    if (use_diffuse_map) {
        _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);
        if (is_function_constant_defined(diffuse_texture_component))
            _surface.diffuse = _surface.diffuse[diffuse_texture_component];
        if (use_diffuse_intensity)
            _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;
    } else {
        _surface.diffuse = scn_commonprofile.diffuseColor;
    }
    if (use_diffuse && use_io_vertex_color) {
        _surface.diffuse *= in.vertexColor;
    }
    
    if (use_specular_map) {
        _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);
        if (is_function_constant_defined(specular_texture_component))
            _surface.specular = _surface.specular[specular_texture_component];
        if (use_specular_intensity)
            _surface.specular *= scn_commonprofile.specularIntensity;
    } else {
        _surface.specular = scn_commonprofile.specularColor;
    }
    if (use_emission_map) {
        _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);
        if (is_function_constant_defined(emission_texture_component))
            _surface.emission = float4(_surface.emission[emission_texture_component]);
        if (use_emission_intensity)
            _surface.emission *= scn_commonprofile.emissionIntensity;
    } else {
        _surface.emission = scn_commonprofile.emissionColor;
    }
    if (use_multiply_map) {
        _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);
        if (is_function_constant_defined(multiply_texture_component))
            _surface.multiply = float4(_surface.multiply[multiply_texture_component]);
        if (use_multiply_intensity)
            _surface.multiply = mix(float4(1.f), _surface.multiply, scn_commonprofile.multiplyIntensity);
    } else {
        _surface.multiply = scn_commonprofile.multiplyColor;
    }
    
    if (use_transparent_map) {
        _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);
        if (is_function_constant_defined(transparent_texture_component))
            _surface.transparent = float4(_surface.transparent[transparent_texture_component]);
        if (use_transparent_intensity)
            _surface.transparent *= scn_commonprofile.transparentIntensity;
    } else {
        _surface.transparent = scn_commonprofile.transparentColor;
    }
    if (use_metalness_map) {
        float4 c = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord);
        if (is_function_constant_defined(metalness_texture_component))
            _surface.metalness = c[metalness_texture_component];
        else 
            _surface.metalness = c.r;
        if (use_metalness_intensity)
            _surface.metalness *= scn_commonprofile.metalnessIntensity;
    } else {
        _surface.metalness = scn_commonprofile.metalness;
    }
    
    if (use_roughness_map) {
        float4 c = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;
        if (is_function_constant_defined(roughness_texture_component))
            _surface.roughness = c[roughness_texture_component];
        else 
            _surface.roughness = c.r;
        if (use_roughness_intensity)
            _surface.roughness *= scn_commonprofile.roughnessIntensity;
    } else {
        _surface.roughness = scn_commonprofile.roughness;
    }
    
    
    if (use_io_normal) {
        if (use_double_sided)
            _surface.geometryNormal = normalize(in.normal.xyz) * (in.normal.z >= 0.f ? 1.f : -1.f );
        else
            _surface.geometryNormal = normalize(in.normal.xyz);
        _surface.normal = _surface.geometryNormal;
    }
    if (need_tangent) {
        _surface.tangent = in.tangent;
        _surface.bitangent = in.bitangent;
    }
    if (use_io_position)
        _surface.position = in.position;
    if (use_io_view)
        _surface.view = normalize(-in.position);
    if (use_normal_map) {
        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);
        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;
        if (is_function_constant_defined(normal_texture_component)) { 
            _surface._normalTS.xy = _surface._normalTS.xy * 2.f - 1.f;
            _surface._normalTS.z = sqrt(1 - length_squared(_surface._normalTS.xy));
        } else {
            _surface._normalTS = _surface._normalTS * 2.f - 1.f;
        }
        if (use_normal_intensity)
            _surface._normalTS = mix(float3(0.f, 0.f, 1.f), _surface._normalTS, scn_commonprofile.normalIntensity);
        
        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS);
    } else {
        _surface._normalTS = float3(0.f);
    }
    
    if (use_reflective_map) {
        
        float3 refl = reflect( -_surface.view, _surface.normal );
        float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + scn::sq(refl.z + 1.f));
        _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);
        if (is_function_constant_defined(reflective_texture_component))
            _surface.reflective = _surface.reflective[reflective_texture_component];
        
        if (use_reflective_intensity)
            _surface.reflective *= scn_commonprofile.reflectiveIntensity;
    
    } else if (use_reflectivecube_map) {
    
        float3 refl = reflect( _surface.position, _surface.normal );
        _surface.reflective = u_reflectiveCubeTexture.sample(u_reflectiveCubeTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); 
        if (is_function_constant_defined(reflective_texture_component))
            _surface.reflective = _surface.reflective[reflective_texture_component];
        
        if (use_reflective_intensity)
            _surface.reflective *= scn_commonprofile.reflectiveIntensity;
    
    } else {
        _surface.reflective = scn_commonprofile.reflectiveColor;
    }
    
    if (use_fresnel) {
        _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);
        _surface.reflective *= _surface.fresnel;
    }
    _surface.shininess = scn_commonprofile.materialShininess;
    
#ifdef USE_SURFACE_MODIFIER
__DoSurfaceModifier__
#endif
    SCNShaderLightingContribution _lightingContribution = {0};
    if (use_ambient_lighting)
        _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;
    
    if (use_lighting) {
        if (use_per_pixel_lighting) {
            _lightingContribution.diffuse = float3(0.f);
            if (use_modulate_lighting)
                _lightingContribution.modulate = float3(1.f);
            if (use_specular)
                _lightingContribution.specular = float3(0.f);
            
            if (is_function_constant_defined(use_light0)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light0;
                params.lightData = scn_lights[ in_node.lightIndices[0] ];
                params.attenuation = float3(1.f);
                if (use_shadow0) scn_do_shadow(params, u_shadowTexture0, u_shadowKernel);
                if (use_gobo0)   scn_do_gobo(params, u_goboTexture0);
                if (use_ies0)    scn_do_ies(params, u_iesTexture0, linearSampler );
                if (use_iesCube0)    scn_do_ies(params, u_iesCubeTexture0, linearSampler );
                scn_do_light(params, _lightingContribution);
            }
            if (is_function_constant_defined(use_light1)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light1;
                params.lightData = scn_lights[ in_node.lightIndices[1] ];
                params.attenuation = float3(1.f);
                if (use_shadow1) scn_do_shadow(params, u_shadowTexture1, u_shadowKernel);
                if (use_gobo1)   scn_do_gobo(params, u_goboTexture1);
                if (use_ies1)    scn_do_ies(params, u_iesTexture1, linearSampler );
                if (use_iesCube1)    scn_do_ies(params, u_iesCubeTexture1, linearSampler );
                scn_do_light(params, _lightingContribution);
            }
            if (is_function_constant_defined(use_light2)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light2;
                params.lightData = scn_lights[ in_node.lightIndices[2] ];
                params.attenuation = float3(1.f);
                if (use_shadow2) scn_do_shadow(params, u_shadowTexture2, u_shadowKernel);
                if (use_gobo2)   scn_do_gobo(params, u_goboTexture2);
                if (use_ies2)    scn_do_ies(params, u_iesTexture2, linearSampler );
                if (use_iesCube2)    scn_do_ies(params, u_iesCubeTexture2, linearSampler );
                scn_do_light(params, _lightingContribution);
            }
            
            if (is_function_constant_defined(use_light3)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light3;
                params.lightData = scn_lights[ in_node.lightIndices[3] ];
                params.attenuation = float3(1.f);
                if (use_shadow3) scn_do_shadow(params, u_shadowTexture3, u_shadowKernel);
                if (use_gobo3)   scn_do_gobo(params, u_goboTexture3);
                if (use_ies3)    scn_do_ies(params, u_iesTexture3, linearSampler );
                if (use_iesCube3)    scn_do_ies(params, u_iesCubeTexture3, linearSampler );
                scn_do_light(params, _lightingContribution);
            }
            
        } else { 
            _lightingContribution.diffuse = in.diffuse;
            if (use_specular)
                _lightingContribution.specular = in.specular;
        }
        if (avoid_overlighting) {
            _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);
            if (use_specular)
                _lightingContribution.specular = saturate(_lightingContribution.specular);
        }
    } else { 
        _lightingContribution.diffuse = float3(1.f);
    }
    
    
    SCNOutput _output;
    if (use_pbr) {
        SCNPBRSurface pbr_surface = SCNShaderSurfaceToSCNPBRSurface(_surface);
        pbr_surface.selfIlluminationOcclusion = scn_commonprofile.selfIlluminationOcclusion;
        if (use_probes_lighting) {
            _output.color = scn_pbr_combine_probes(pbr_surface, _lightingContribution, u_specularDFGTexture, u_radianceTexture, scn_shCoefficients, scn_frame);
        } else {
            _output.color = scn_pbr_combine_cubemap(pbr_surface, _lightingContribution, u_specularDFGTexture, u_radianceTexture, u_irradianceTexture, scn_frame);
        }
        _output.color.a = _surface.diffuse.a;
    } else {
        _output.color = illuminate(_surface, _lightingContribution);
    }
    
    if (use_fog) {
        float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);
        _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);
    }
    if (!diffuse_premultiplied)
        _output.color.rgb *= _surface.diffuse.a;
    float nodeOpacity = use_node_opacity ? in_node.nodeOpacity : 1.f;
    if (use_transparent) {
        if (use_transparency)
            _surface.transparent *= scn_commonprofile.transparency;
        
        if (use_transparency_rgbzero) {
            
            _surface.transparent.a = (_surface.transparent.r * 0.212671f) + (_surface.transparent.g * 0.715160f) + (_surface.transparent.b * 0.072169f);
            _output.color *= nodeOpacity * (float4(1.f) - _surface.transparent);
        } else { 
            _output.color *= (nodeOpacity * _surface.transparent.a);
        }
    } else {
        if (use_transparency) { 
            _output.color *= (nodeOpacity * scn_commonprofile.transparency);
        }
    }
    
#ifdef USE_FRAGMENT_MODIFIER
__DoFragmentModifier__
#endif
    
    
    if (use_discard && _output.color.a == 0.) 
        discard_fragment();
    return half4(_output.color);
#ifdef USE_PER_VERTEX_LIGHTING
varying vec3 v_diffuse;
#ifdef USE_SPECULAR
varying vec3 v_specular;
#endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
varying vec3 v_position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2)
varying vec3 v_normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
varying vec3 v_tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
varying vec3 v_bitangent;
#endif
#ifdef USE_AMBIENT_LIGHTING
uniform vec4 u_ambientLightColor;
#endif
#ifdef USE_DIFFUSE_MAP
uniform sampler2D u_diffuseTexture;
#ifdef USE_DIFFUSE_INTENSITY
uniform float u_diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
uniform vec4 u_diffuseColor;
#endif
#ifdef USE_NORMAL_MAP
uniform sampler2D u_normalTexture;
#ifdef USE_NORMAL_INTENSITY
uniform float u_normalIntensity;
#endif
#endif
#ifdef USE_SHININESS
uniform float u_materialShininess;
#endif
#ifdef USE_SPECULAR
#ifdef USE_SPECULAR_MAP
uniform sampler2D u_specularTexture;
#ifdef USE_SPECULAR_INTENSITY
uniform float u_specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
uniform vec4 u_specularColor;
#endif
#endif 
#ifdef USE_AMBIENT_MAP
uniform sampler2D u_ambientTexture;
#ifdef USE_AMBIENT_INTENSITY
uniform float u_ambientIntensity;
#endif
#elif defined(USE_AMBIENT_COLOR)
uniform vec4 u_ambientColor;
#endif
#ifdef USE_REFLECTIVE_MAP
uniform sampler2D u_reflectiveTexture;
#elif defined(USE_REFLECTIVE_COLOR)
uniform vec4 u_reflectiveColor;
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
uniform samplerCube u_reflectiveTexture;
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
uniform mat4 u_viewToCubeWorld;
#endif
#ifdef USE_REFLECTIVE_INTENSITY
uniform float u_reflectiveIntensity;
#endif
#ifdef USE_FRESNEL
uniform vec3 u_fresnel; 
#endif
#ifdef USE_EMISSION_MAP
uniform sampler2D u_emissionTexture;
#ifdef USE_EMISSION_INTENSITY
uniform float u_emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
uniform vec4 u_emissionColor;
#endif
#ifdef USE_MULTIPLY_MAP
uniform sampler2D u_multiplyTexture;
#ifdef USE_MULTIPLY_INTENSITY
uniform float u_multiplyIntensity;
#endif
#elif defined(USE_MULTIPLY_COLOR)
uniform vec4 u_multiplyColor;
#endif
#ifdef USE_TRANSPARENT_MAP
uniform sampler2D u_transparentTexture;
#ifdef USE_TRANSPARENT_INTENSITY
uniform float u_transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
uniform vec4 u_transparentColor;
#endif
#ifdef USE_VERTEX_COLOR
varying vec4 v_vertexColor;
#endif
#ifdef USE_NODE_OPACITY 
uniform float u_nodeOpacity;
#endif
#ifdef USE_TRANSPARENCY 
uniform float u_transparency;
#endif
#ifdef USE_DOUBLE_SIDED
uniform float u_orientationPreserved;
#endif
#ifdef USE_TIME
uniform float u_time;
#endif
#ifdef USE_FOG
uniform vec4 u_fogColor;
uniform vec3 u_fogParameters; 
#endif
float saturate(float x) {
    return clamp(x, 0., 1.);
vec2 saturate(vec2 x) {
    return clamp(x, vec2(0.), vec2(1.));
vec3 saturate(vec3 x) {
    return clamp(x, vec3(0.), vec3(1.));
vec4 saturate(vec4 x) {
    return clamp(x, vec4(0.), vec4(1.));
vec4 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    vec4 color = vec4(0.,0.,0., surface.diffuse.a);
    
    vec3 D = lighting.diffuse;
#ifdef USE_AMBIENT_LIGHTING
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    D += lighting.ambient * surface.ambientOcclusion;
#elif defined(LOCK_AMBIENT_WITH_DIFFUSE)
    D += lighting.ambient;
#endif
#endif 
#ifdef USE_EMISSION_AS_SELFILLUMINATION
    D += surface.emission.rgb;
#endif
    
    
    
    color.rgb = surface.diffuse.rgb * D;
#if 1 
#ifdef USE_SPECULAR
    vec3 S = lighting.specular;
#elif defined(USE_REFLECTIVE)
    vec3 S = vec3(0.);
#endif
#ifdef USE_REFLECTIVE
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    S += surface.reflective.rgb * surface.ambientOcclusion;
#else
    S += surface.reflective.rgb;
#endif
#endif
#ifdef USE_SPECULAR
    S *= surface.specular.rgb;
#endif
#if defined(USE_SPECULAR) || defined(USE_REFLECTIVE)
    color.rgb += S;
#endif
#else
#ifdef USE_SPECULAR
    color.rgb += surface.specular.rgb * lighting.specular;
#endif
#ifdef USE_REFLECTIVE
    color.rgb += surface.reflective.rgb * (lighting.diffuse + lighting.ambient);
#endif
#endif 
#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)
    color.rgb += surface.ambient.rgb * lighting.ambient;
#endif
#if defined(USE_EMISSION) && !defined(USE_EMISSION_AS_SELFILLUMINATION)
    color.rgb += surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
    color.rgb *= surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
    color.rgb *= lighting.modulate;
#endif
    return color;
struct SCNOutput
    vec4 color;
} _output;
void main(void)
#ifdef USE_TEXCOORD
    __DoTexcoord__
#endif
    
    _surface.ambientOcclusion = 1.0;
    
    
#ifdef USE_AMBIENT_MAP
    _surface.ambient = texture2D(u_ambientTexture, _surface.ambientTexcoord);
#ifdef USE_AMBIENT_INTENSITY
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    _surface.ambientOcclusion = mix(1., _surface.ambient.r, u_ambientIntensity);
#else
    _surface.ambient *= u_ambientIntensity;
#endif
#endif
#elif defined(USE_AMBIENT_COLOR)
    _surface.ambient = u_ambientColor;
#elif defined(USE_AMBIENT)
    _surface.ambient = vec4(0.);
#endif
#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)
    _surface.ambient *= v_vertexColor;
#endif
    
    
#ifdef USE_DIFFUSE_MAP
    _surface.diffuse = texture2D(u_diffuseTexture, _surface.diffuseTexcoord);
#ifdef USE_DIFFUSE_INTENSITY
    _surface.diffuse.rgb *= u_diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
    _surface.diffuse = u_diffuseColor;
#elif defined(USE_DIFFUSE)
    _surface.diffuse = vec4(0.,0.,0.,1.);
#endif
#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)
    _surface.diffuse *= v_vertexColor;
#endif
    
    
#ifdef USE_SPECULAR_MAP
    _surface.specular = texture2D(u_specularTexture, _surface.specularTexcoord);
#ifdef USE_SPECULAR_INTENSITY
    _surface.specular *= u_specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
    _surface.specular = u_specularColor;
#elif defined(USE_SPECULAR)
    _surface.specular = vec4(0.);
#endif
    
    
#ifdef USE_EMISSION_MAP
    _surface.emission = texture2D(u_emissionTexture, _surface.emissionTexcoord);
#ifdef USE_EMISSION_INTENSITY
    _surface.emission *= u_emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
    _surface.emission = u_emissionColor;
#elif defined(USE_EMISSION)
    _surface.emission = vec4(0.);
#endif
    
    
#ifdef USE_MULTIPLY_MAP
    _surface.multiply = texture2D(u_multiplyTexture, _surface.multiplyTexcoord);
#ifdef USE_MULTIPLY_INTENSITY
    _surface.multiply = mix(vec4(1.), _surface.multiply, u_multiplyIntensity);
#endif
#elif defined(USE_MULTIPLY_COLOR)
    _surface.multiply = u_multiplyColor;
#elif defined(USE_MULTIPLY)
    _surface.multiply = vec4(1.);
#endif
    
    
#ifdef USE_TRANSPARENT_MAP
    _surface.transparent = texture2D(u_transparentTexture, _surface.transparentTexcoord);
#ifdef USE_TRANSPARENT_INTENSITY
    _surface.transparent *= u_transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
    _surface.transparent = u_transparentColor;
#elif defined(USE_TRANSPARENT)
    _surface.transparent = vec4(1.);
#endif
    
    
#if (defined USE_NORMAL) && (USE_NORMAL == 2)
#ifdef USE_DOUBLE_SIDED
    _surface.normal = normalize(v_normal.xyz) * u_orientationPreserved * ((float(gl_FrontFacing) * 2.0) - 1.0);
#else
    _surface.normal = normalize(v_normal.xyz);
#endif
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    _surface.tangent = v_tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    _surface.bitangent = v_bitangent;
#endif
#if (defined USE_POSITION) && (USE_POSITION == 2)
    _surface.position = v_position;
#endif
#if (defined USE_VIEW) && (USE_VIEW == 2)
    _surface.view = normalize(-v_position);
#endif
#ifdef USE_NORMAL_MAP
    mat3 ts2vs = mat3(_surface.tangent, _surface.bitangent, _surface.normal);
    _surface._normalTS = texture2D(u_normalTexture, _surface.normalTexcoord).rgb * 2. - 1.;
    
#ifdef USE_NORMAL_INTENSITY
    _surface._normalTS = mix(vec3(0., 0., 1.), _surface._normalTS, u_normalIntensity);
#endif
    
    _surface.normal.rgb = normalize(ts2vs * _surface._normalTS);
#else
    _surface._normalTS = vec3(0., 0., 0.);
#endif
    
    
#ifdef USE_REFLECTIVE_MAP
    vec3 refl = reflect( -_surface.view, _surface.normal );
    float m = 2.0 * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.0)*(refl.z+1.0));
    _surface.reflective = texture2D(u_reflectiveTexture,vec2(vec2(refl.x,-refl.y) / m) + 0.5) ;
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= u_reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_CUBEMAP)
    vec3 refl = reflect( _surface.position, _surface.normal );
    _surface.reflective = textureCube(u_reflectiveTexture, mat3(u_viewToCubeWorld) * refl); 
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= u_reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_COLOR)
    _surface.reflective = u_reflectiveColor;
#elif defined(USE_REFLECTIVE)
    _surface.reflective = vec4(0.);
#endif
#ifdef USE_FRESNEL
    _surface.fresnel = u_fresnel.x + u_fresnel.y * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), u_fresnel.z);
    _surface.reflective *= _surface.fresnel;
#endif
#ifdef USE_SHININESS
    _surface.shininess = u_materialShininess;
#endif
    
    
    
    
#ifdef USE_SURFACE_MODIFIER
__DoSurfaceModifier__
#endif
    
    
    
#ifdef USE_AMBIENT_LIGHTING
    _lightingContribution.ambient = u_ambientLightColor.rgb;
#elif defined(USE_AMBIENT)
    _lightingContribution.ambient = vec3(0.);
#endif
    
#ifdef USE_LIGHTING
#ifdef USE_PER_PIXEL_LIGHTING
    _lightingContribution.diffuse = vec3(0.);
#ifdef USE_MODULATE
    _lightingContribution.modulate = vec3(1.);
#endif
#ifdef USE_SPECULAR
    _lightingContribution.specular = vec3(0.);
#endif
    
    __DoLighting__
    
#else 
    _lightingContribution.diffuse = v_diffuse;
#ifdef USE_SPECULAR
    _lightingContribution.specular = v_specular;
#endif
#endif
    
    
#ifdef AVOID_OVERLIGHTING
    _lightingContribution.diffuse = clamp(_lightingContribution.diffuse, vec3(0.), vec3(1.));
#ifdef USE_SPECULAR
    _lightingContribution.specular = clamp(_lightingContribution.specular, vec3(0.), vec3(1.));
#endif 
#endif 
#else 
    _lightingContribution.diffuse = vec3(1.);
#endif 
    
    
    _output.color = illuminate(_surface, _lightingContribution);
    
#ifdef USE_FOG
    float fogFactor = pow(clamp(length(_surface.position.xyz) * u_fogParameters.x + u_fogParameters.y, 0., u_fogColor.a), u_fogParameters.z);
    _output.color.rgb = mix(_output.color.rgb, u_fogColor.rgb * _output.color.a, fogFactor);
#endif
    
#ifndef DIFFUSE_PREMULTIPLIED
    _output.color.rgb *= _surface.diffuse.a;
#endif
    
#ifdef USE_TRANSPARENT 
    
#ifdef USE_TRANSPARENCY
    _surface.transparent *= u_transparency;
#endif
    
#ifdef USE_TRANSPARENCY_RGBZERO
#ifdef USE_NODE_OPACITY
    _output.color *= u_nodeOpacity;
#endif
    
    _surface.transparent.a = (_surface.transparent.r * 0.212671) + (_surface.transparent.g * 0.715160) + (_surface.transparent.b * 0.072169);
    _output.color *= (vec4(1.) - _surface.transparent);
#else 
    _output.color *= _surface.transparent.a;
#endif
#else
#ifdef USE_TRANSPARENCY 
    _output.color *= u_transparency;
#endif
#endif
    
#ifdef USE_FRAGMENT_MODIFIER
__DoFragmentModifier__
#endif
    
#ifdef USE_DISCARD
    if (_output.color.a == 0.) 
        discard;
#endif
    
    gl_FragColor = _output.color;
uniform sampler2D colorBuffer;
uniform sampler2D outlineColorBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    float alpha = 0.;
    for(int i=-1; i<2; i++)
    for(int j=-1; j<2; j++)
    {
        alpha += texture2D(outlineColorBuffer, uv+vec2(i,j)*u_inverseResolution).r;
    }
    alpha /= 9.;
    
    
    gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(1.,.6,.2,1.), vec4(min(alpha*2.,1.)) );
uniform sampler2D textureSampler0;
uniform sampler2D textureSampler1;
uniform float factor;
varying vec2 TexCoord;
void main (void)
    vec4 newFragment = texture2D(textureSampler0,TexCoord);
    vec4 oldColor = texture2D(textureSampler1,TexCoord);
    
    gl_FragColor = (factor-1.0)*(oldColor/factor) + newFragment/factor;
#ifdef USE_PCF
#ifdef GL_EXT_shadow_samplers 
#extension GL_EXT_shadow_samplers : require
#endif
#endif
#if MAX_SAMPLE > 1
uniform vec4 u_kernel[MAX_SAMPLE];
#endif
uniform vec4 shadowColor;
uniform sampler2D colorSampler;
uniform sampler2D depthSampler;
#ifdef USE_PCF
#ifdef GL_EXT_shadow_samplers 
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) shadow2DProjEXT( tex, coord )
#elif __VERSION__ <= 120 
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) shadow2DProj( tex, coord ).x
#else 
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) textureProj( tex, coord )
#endif
#else 
    uniform sampler2D lightDepthSampler;
    #define __shadow2DProj(tex, coord) clamp(coord.z - texture2DProj(tex, coord).x * coord.w, 0.0, 1.0);
#endif
uniform mat4  camera_MVP_i;
uniform mat4  light_MVP;
uniform vec3  u_lightPos;
uniform vec3  u_lightDir;
uniform vec3  u_lightSpotAtt;
uniform float shadowRadius;
#ifndef TARGET_OS_IPHONE
    #ifdef SPOT_SHADOW
        #define USE_SPOT_ATTENUATION 1
    #else
        #define USE_SPOT_ATTENUATION 0
    #endif
#else
    #define USE_SPOT_ATTENUATION 0
#endif
varying vec2 TexCoord;
vec3 unprojectPoint(vec3 screenPos)
vec4 pTmp;
    pTmp.xyz = (2.0 * screenPos.xyz) - 1.0;
pTmp.w = 1.0;
pTmp = camera_MVP_i * pTmp;
    pTmp /= pTmp.w;
return vec3(pTmp);
void main (void)
    
    vec4 color = texture2D(colorSampler, TexCoord);
    
float depthValue = texture2D(depthSampler, TexCoord).x;
vec3 worldPos = unprojectPoint(vec3(TexCoord, depthValue));
vec4 lightScreen =  light_MVP * vec4(worldPos, 1.0);
    
    
#if USE_SPOT_ATTENUATION
    vec3 lightToFragment = normalize(u_lightPos - worldPos);
    
    
    float att;
    if (u_lightSpotAtt.z == 0.0)
        att = step(u_lightSpotAtt.x, dot(lightToFragment, u_lightDir) + 0.00004);
    else
        att = pow(clamp(dot(lightToFragment, u_lightDir) * u_lightSpotAtt.x + u_lightSpotAtt.y, 0.0, 1.0), u_lightSpotAtt.z);
    
    if (att == 0.) {
        gl_FragColor = color.rgba;
        return;
    }
#endif 
    
    
#if MAX_SAMPLE == 1
    float shadow = __shadow2DProj(lightDepthSampler, lightScreen);
#else
    
    float filteringSizeFactor = shadowRadius * lightScreen.w;
    
    
    float totalAccum = 0.0;
    for(int i=0; i<MAX_SAMPLE; i++){
        totalAccum += __shadow2DProj(lightDepthSampler, lightScreen + (u_kernel[i] * filteringSizeFactor));
    }
    
    float shadow = totalAccum / float(MAX_SAMPLE);
#endif
    
#if !USE_SPOT_ATTENUATION
    shadow *= step(0., lightScreen.w);
#endif
    
    
    
    shadow *= shadowColor.a;
#if USE_SPOT_ATTENUATION
    shadow = shadow * att;
#endif
    
    
    gl_FragColor = mix(color.rgba, vec4(shadowColor.rgb, 1.0),  shadow);
#import <metal_stdlib>
using namespace metal;
static int OsdGetPatchNumControlVertices(int patchType) {
    switch(patchType) {
        case 3: return 4;
        case 6: return 16;
        case 9: return 20;
        default: return 0;
    }
#if OSD_IS_ADAPTIVE
#if USE_STAGE_IN
#if OSD_PATCH_REGULAR
struct ControlPoint
    
    float3 P [[attribute(0)]];
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    float3 P1 [[attribute(1)]];
    float3 P2 [[attribute(2)]];
#if !USE_PTVS_SHARPNESS
    float2 vSegments [[attribute(3)]];
#endif 
#endif 
struct PatchInput
    patch_control_point<ControlPoint> cv;
#if !USE_PTVS_FACTORS
    float4 tessOuterLo [[attribute(5)]];
    float4 tessOuterHi [[attribute(6)]];
#endif 
    int3 patchParam [[attribute(10)]];
#elif OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
struct ControlPoint
    
    float3 P [[attribute(0)]];
    float3 Ep [[attribute(1)]];
    float3 Em [[attribute(2)]];
    float3 Fp [[attribute(3)]];
    float3 Fm [[attribute(4)]];
struct PatchInput
    patch_control_point<ControlPoint> cv;
    int3 patchParam [[attribute(10)]];
#elif OSD_PATCH_GREGORY_BASIS
struct ControlPoint
    float3 position [[attribute(0)]];
struct PatchInput
    patch_control_point<ControlPoint> cv;
    int3 patchParam [[attribute(10)]];
#endif
#endif 
#endif 
#if defined(OSD_FVAR_WIDTH)
static void OsdInterpolateFaceVarings(thread SCNShaderGeometry&          geometry
                                      , float2                           uv
                                      , int                              patchIndex
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
                                      , constant uint32_t&               osdFaceVaryingChannelCount
                                      , device OsdFVarChannelDesc const* osdFaceVaryingChannelDescriptors
                                      , constant uint32_t&               osdFaceVaryingPatchArrayIndex
                                      , device void const*               osdFaceVaryingChannelsPackedData
#else 
                                      , device int const*                osdFaceVaryingIndices
                                      , device float const*              osdFaceVaryingData
#if OSD_IS_ADAPTIVE
                                      , device packed_int3 const*        osdFaceVaryingPatchParams
                                      , constant packed_int4&            osdFaceVaryingPatchArray
#endif
#endif 
                                      )
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[0] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[1] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[2] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[3] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[4] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[5] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[6] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[7] = float2(0.0);
#endif
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.color = float4(0.0);
#endif
    
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
    for (uint32_t channel = 0; channel < osdFaceVaryingChannelCount; ++channel) {
        OsdFVarChannelDesc channelDescriptor = osdFaceVaryingChannelDescriptors[channel];
        
        int4 osdFaceVaryingPatchArray = ((device packed_int4 *)((device uint8_t *)osdFaceVaryingChannelsPackedData + channelDescriptor.patchArraysBufferOffset))[osdFaceVaryingPatchArrayIndex];
        int indexBase = osdFaceVaryingPatchArray.z;
        
        device int const *osdFaceVaryingIndices = (device int *)((device uint8_t *)osdFaceVaryingChannelsPackedData + channelDescriptor.indicesBufferOffset) + indexBase * 3;
        device float const *osdFaceVaryingData = (device float *)((device uint8_t *)osdFaceVaryingChannelsPackedData + channelDescriptor.dataBufferOffset);
        
#if OSD_IS_ADAPTIVE
        int primitiveIdBase = osdFaceVaryingPatchArray.w;
        device packed_int3 const *osdFaceVaryingPatchParams = (device packed_int3 *)((device uint8_t *)osdFaceVaryingChannelsPackedData + channelDescriptor.patchParamsBufferOffset) + primitiveIdBase;
        
        int3 fvarPatchParam = osdFaceVaryingPatchParams[patchIndex];
        bool isRegular = OsdGetPatchIsRegular(fvarPatchParam);
        
        int4 patchArray = osdFaceVaryingPatchArray;
        int patchStride = OsdGetPatchNumControlVertices(patchArray.x);
        int patchType = select(patchArray.x, int(6), isRegular);
        int patchCVs = OsdGetPatchNumControlVertices(patchType);
        
        float wP[20], wDs[20], wDt[20], wDss[20], wDst[20], wDtt[20];
        
        if (patchType == 3) {
            OsdGetBilinearPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
        } else if (patchType == 6) {
            int boundaryMask = OsdGetPatchBoundaryMask(fvarPatchParam);
            OsdGetBSplinePatchWeights(uv.x, uv.y, 1.0f, boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);
        } else if (patchType == 9) {
            OsdGetGregoryPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
        }
#else
        float wP[4], wDs[4], wDt[4], wDss[4], wDst[4], wDtt[4];
        int patchCVs = 4;
        int patchStride = patchCVs;
        OsdGetBilinearPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
#endif
        
        for (int i = 0; i < patchCVs; ++i) {
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.colorPrimvar.isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.colorPrimvar.offset;
                geometry.color += wP[i] * float4(osdFaceVaryingData[index], osdFaceVaryingData[index+1], osdFaceVaryingData[index+2], osdFaceVaryingData[index+3]);
            }
#endif
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[0].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[0].offset;
                geometry.texcoords[0] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[1].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[1].offset;
                geometry.texcoords[1] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[2].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[2].offset;
                geometry.texcoords[2] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[3].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[3].offset;
                geometry.texcoords[3] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[4].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[4].offset;
                geometry.texcoords[4] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[5].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[5].offset;
                geometry.texcoords[5] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[6].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[6].offset;
                geometry.texcoords[6] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[7].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[7].offset;
                geometry.texcoords[7] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
        }
    }
    
#else 
    
#if OSD_IS_ADAPTIVE
    int3 fvarPatchParam = osdFaceVaryingPatchParams[patchIndex];
    bool isRegular = OsdGetPatchIsRegular(fvarPatchParam);
    
    int4 patchArray = osdFaceVaryingPatchArray;
    int patchStride = OsdGetPatchNumControlVertices(patchArray.x);
    int patchType = select(patchArray.x, int(6), isRegular);
    int patchCVs = OsdGetPatchNumControlVertices(patchType);
    
    float wP[20], wDs[20], wDt[20], wDss[20], wDst[20], wDtt[20];
    
    if (patchType == 3) {
        OsdGetBilinearPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if (patchType == 6) {
        int boundaryMask = OsdGetPatchBoundaryMask(fvarPatchParam);
        OsdGetBSplinePatchWeights(uv.x, uv.y, 1.0f, boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if (patchType == 9) {
        OsdGetGregoryPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
    }
#else
    float wP[4], wDs[4], wDt[4], wDss[4], wDst[4], wDtt[4];
    int patchCVs = 4;
    int patchStride = patchCVs;
    OsdGetBilinearPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
#endif
    
    for (int i = 0; i < patchCVs; ++i) {
        int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * OSD_FVAR_WIDTH + 0 ;
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.color += wP[i] * float4(osdFaceVaryingData[index], osdFaceVaryingData[index+1], osdFaceVaryingData[index+2], osdFaceVaryingData[index+3]);
        index += 4;
#endif
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[0] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[1] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[2] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[3] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[4] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[5] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[6] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[7] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
    }
#endif 
#endif 
uniform sampler2D sceneColor;
uniform sampler2D authoringColor;
varying vec2 uv;
void main()
    vec4 scene = texture2D(sceneColor, uv);
    vec4 authoring = texture2D(authoringColor, uv);
    
    gl_FragColor = mix(scene, authoring, authoring.a);
attribute vec3 a_position;
uniform mat4 u_mvp;
uniform float u_zfar;
varying vec3 TexCoord;
void main()
gl_Position = (u_mvp * vec4(a_position * u_zfar, 1.)).xyww;
TexCoord = vec3(a_position.x, a_position.y, -a_position.z);
attribute vec3 a_position;
uniform mat4 u_m;
varying vec2 TexCoord;
void main(void)
gl_Position = u_m * vec4(a_position, 1.0);
TexCoord = (gl_Position.xy + 1.0) * 0.5;
  "sequence" : [
                "SceneKit_renderCINodeTree",
                "SceneKit_ApplyCIFilter",
                "SceneKit_renderCIQuad"
                ],
  "targets" : {
    "SceneKit-CI-nodetree-depth" : {
      "type" : "depth"
    },
    "SceneKit-CI-nodetree-color" : {
      "type" : "color",
      "format" : "rgba",
    },
    "SceneKit-CI-effect-color" : {
      "type" : "color",
      "format" : "rgba",
      "usage" : ["shaderWrite", "shaderRead"]
    }
  },
  "symbols" : {
    "C3D-CIFilter_middleZ" : {
      "type" : "float"
    },
    "C3D-CIFilter_extent" : {
      "type" : "vec4"
    }
  },
  "passes" : {
    "SceneKit_renderCIQuad" : {
      "inputs" : {
        "u_color" : {
          "target" : "SceneKit-CI-effect-color",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_middleZ" : "C3D-CIFilter_middleZ",
        "u_extent" : "C3D-CIFilter_extent",
        "u_depth" : {
          "target" : "SceneKit-CI-nodetree-depth",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        }
      },
      "hasConstantAlpha" : false,
      "colorStates" : {
        "clear" : false
      },
      "depthStates" : {
        "clear" : false
      },
      "cullMode" : "none",
      "metalVertexShader" : "scn_filterCompositeVert",
      "metalFragmentShader" : "scn_filterCompositeFrag",
      "draw" : "none",
      "clientProgram" : false,
      "blendStates" : {
        "enable" : true,
        "colorDst" : "oneMinusSrcAlpha",
        "colorSrc" : "one"
      }
    },
    "SceneKit_ApplyCIFilter" : {
      "outputs" : {
        "color" : "SceneKit-CI-effect-color"
      },
      "inputs" : {
        "myInput1" : "SceneKit-CI-nodetree-color"
      },
      "draw" : "CUSTOM"
    },
    "SceneKit_renderCINodeTree" : {
      "draw" : "DRAW_NODE",
      "node" : "self",
      "ignoreFloors" : true,
      "outputs" : {
        "depth" : "SceneKit-CI-nodetree-depth",
        "color" : "SceneKit-CI-nodetree-color"
      },
      "colorStates" : {
        "clear" : true
      },
      "depthStates" : {
        "clear" : true
      },
      
    }
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
struct SCNShaderGeometry
vec4 position;
vec3 normal;
vec4 tangent;
vec4 color;
vec2 texcoords[8]; 
} _geometry;
  uniform vec3 u_floorNormal;
  uniform vec4 u_floorTangent;
  uniform vec3 u_floorCenter;
  uniform vec2 u_floorExtent;
#pragma body
  vec3 floorBitangent =  normalize(cross(u_floorTangent.xyz, u_floorNormal));
  _geometry.position.xyz = u_floorCenter.xyz + u_floorExtent.x * (_geometry.position.x * u_floorTangent.xyz) + u_floorExtent.y * (_geometry.position.y * floorBitangent);
  _geometry.normal = u_floorNormal;
  _geometry.tangent = u_floorTangent;
  vec2 tc;
  if (u_floorNormal.y != 0.)
    tc = _geometry.position.xz * 0.01;
  else if (u_floorNormal.z != 0.)
    tc = _geometry.position.xy * 0.01;
  else
    tc = _geometry.position.yz * 0.01;
  for (int i = 0; i < kSCNTexcoordCount; ++i)
    _geometry.texcoords[i] = tc;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_downSample4x</string>
<string>SceneKit_DOF_generateNearCoc</string>
<string>SceneKit_DOF_blurCoc_H</string>
<string>SceneKit_DOF_blurCoc_V</string>
<string>SceneKit_blurColor4x_H</string>
<string>SceneKit_blurColor4x_V</string>
<string>SceneKit_DOF_computeNearCoc</string>
<string>SceneKit_DOF_smallBlur</string>
<string>SceneKit_DOF_resolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_downSample4x</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-color-downSample4x</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>depthSampler</key>
<string>DEPTH</string>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-downSample4x</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>DownSample4x_vert</string>
<key>metalFragmentShader</key>
<string>DownSample4x_frag</string>
</dict>
<key>SceneKit_DOF_generateNearCoc</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-color-nearCoc</string>
</dict>
<key>inputs</key>
<dict>
<key>downSampler</key>
<dict>
<key>target</key>
<string>SceneKit-color-downSample4x</string>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
</dict>
<key>depthSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>DEPTH</string>
</dict>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-generateNearCoc</string>
<key>metalVertexShader</key>
<string>GenerateNearCoc_vert</string>
<key>clientProgram</key>
<false/>
<key>metalFragmentShader</key>
<string>GenerateNearCoc_frag</string>
</dict>
<key>SceneKit_DOF_blurCoc_H</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_blurCoc_H_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusH</string>
<key>textureSampler0</key>
<string>SceneKit-color-nearCoc</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_DOF_blurCoc_V</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_blurCoc_V_output</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit_DOF_blurCoc_H_output</string>
<key>radius</key>
<string>C3D-blur-radiusV</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_blurColor4x_H</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_blurColor4x_H_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusH</string>
<key>textureSampler0</key>
<string>SceneKit-color-downSample4x</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_blurColor4x_V</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_blurColor4x_V_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusV</string>
<key>textureSampler0</key>
<string>SceneKit_blurColor4x_H_output</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_DOF_computeNearCoc</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_computeNearCoc-output</string>
</dict>
<key>inputs</key>
<dict>
<key>downSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>SceneKit-color-nearCoc</string>
</dict>
<key>blurSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>SceneKit_DOF_blurCoc_V_output</string>
</dict>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-ComputeNearCoc</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>ComputeNearCoc_vert</string>
<key>metalFragmentShader</key>
<string>ComputeNearCoc_frag</string>
</dict>
<key>SceneKit_DOF_smallBlur</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_smallBlur-ouput</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<dict>
<key>target</key>
<string>SceneKit_DOF_computeNearCoc-output</string>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
</dict>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-Blur5x5</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>Blur5x5_vert</string>
<key>metalFragmentShader</key>
<string>Blur5x5_frag</string>
</dict>
<key>SceneKit_DOF_resolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>depthSampler</key>
<string>DEPTH</string>
<key>smallBlurSampler</key>
<string>SceneKit_DOF_smallBlur-ouput</string>
<key>largeBlurSampler</key>
<string>SceneKit_blurColor4x_V_output</string>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
<key>dofLerpScale</key>
<string>C3D-dof-lerpScale</string>
<key>dofLerpBias</key>
<string>C3D-dof-lerpBias</string>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-Resolve</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>ResolveDOF_vert</string>
<key>metalFragmentShader</key>
<string>ResolveDOF_frag</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-color-downSample4x</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit-color-nearCoc</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_blurCoc_H_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_blurCoc_V_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_blurColor4x_H_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_blurColor4x_V_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_computeNearCoc-output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_smallBlur-ouput</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-dof-cocScaleBias</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>C3D-dof-invertPixelSize</key>
<dict>
<key>type</key>
<string>vec2</string>
</dict>
<key>C3D-dof-lerpScale</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>C3D-dof-lerpBias</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>C3D-blur-radiusV</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-blur-radiusH</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-blur-offsets</key>
<dict>
<key>type</key>
<string>vec2[31]</string>
</dict>
<key>C3D-blur-weights</key>
<dict>
<key>type</key>
<string>float[31]</string>
</dict>
<key>C3D-blur-samples</key>
<dict>
<key>type</key>
<string>int</string>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_renderMirroredScene</string>
<string>SceneKit_renderFloor</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderMirroredScene</key>
<dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>SceneKit-Floor-depth</string>
<key>color</key>
<string>SceneKit-Floor-color</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>SceneKit_renderFloor</key>
<dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>inputs</key>
<dict>
<key>u_floorReflectionDepth</key>
<string>SceneKit-Floor-depth</string>
<key>u_floorReflectionColor</key>
<string>SceneKit-Floor-color</string>
<key>u_floorNormal</key>
<string>u_floorNormal</string>
<key>u_floorTangent</key>
<string>u_floorTangent</string>
<key>u_floorCenter</key>
<string>u_floorCenter</string>
<key>u_floorExtent</key>
<string>u_floorExtent</string>
<key>u_floorReflectivity</key>
<string>u_floorReflectivity</string>
<key>u_floor_viewport</key>
<string>u_floor_viewport</string>
<key>u_floorMVP_i</key>
<string>u_floorMVP_i</string>
<key>u_floorPlane</key>
<string>u_floorPlane</string>
<key>u_floorFalloff</key>
<string>u_floorFalloff</string>
<key>u_floorFalloffStart</key>
<string>u_floorFalloffStart</string>
</dict>
<key>draw</key>
<string>DRAW_GEOMETRY</string>
<key>installViewport</key>
<false/>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>u_floorNormal</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>u_floorTangent</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>u_floorCenter</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>u_floorExtent</key>
<dict>
<key>type</key>
<string>vec2</string>
</dict>
<key>u_floor_viewport</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>u_floorReflectivity</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>u_floorMVP_i</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
<key>u_floorPlane</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>u_floorFalloff</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>u_floorFalloffStart</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-Floor-depth</key>
<dict>
<key>type</key>
<string>depth</string>
</dict>
<key>SceneKit-Floor-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba</string>
</dict>
</dict>
</dict>
</plist>
uniform sampler2D downSampler;
uniform sampler2D depthSampler;
uniform vec3 CocScaleBias;
varying vec2 v_texCoord;
void main (void)
    vec4 down = texture2D( downSampler, v_texCoord);
    float depth = texture2D( depthSampler, v_texCoord).r;
    float coc = step(0., (depth * CocScaleBias.x + CocScaleBias.y)); 
gl_FragColor = vec4(down.rgb, coc * down.a);
    
    
#extension GL_ARB_shader_texture_lod : enable
uniform sampler2D textureSampler0;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2DLod(textureSampler0,TexCoord, 0.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 1.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 2.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 3.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 4.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 5.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 6.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 7.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 8.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 9.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 10.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 11.0);    
    gl_FragColor /= 12.0;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_copy</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_copy</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-Copy</string>
<key>clientProgram</key>
<false/>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
</dict>
</dict>
</plist>
struct SCNShaderLightingContribution
vec3 ambient;
vec3 diffuse;
vec3 specular;
} _lightingContribution;
#ifdef USE_SKINNING
uniform vec4 u_skinningJointMatrices[60];
attribute vec4 a_skinningWeights;
attribute vec4 a_skinningJoints;
#endif
attribute vec4 a_position;
#ifdef USE_NORMAL
attribute vec3 a_normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
attribute vec4 a_tangent;
#endif
#ifdef NEED_IN_TEXCOORD0
attribute vec2 a_texCoord0;
#endif
#ifdef NEED_IN_TEXCOORD1
attribute vec2 a_texCoord1;
#endif
#ifdef NEED_IN_TEXCOORD2
attribute vec2 a_texCoord2;
#endif
#ifdef NEED_IN_TEXCOORD3
attribute vec2 a_texCoord3;
#endif
#ifdef NEED_IN_TEXCOORD4
attribute vec2 a_texCoord4;
#endif
#ifdef NEED_IN_TEXCOORD5
attribute vec2 a_texCoord5;
#endif
#ifdef NEED_IN_TEXCOORD6
attribute vec2 a_texCoord6;
#endif
#ifdef NEED_IN_TEXCOORD7
attribute vec2 a_texCoord7;
#endif
#ifdef USE_VERTEX_COLOR
attribute vec4 a_color;
varying vec4 v_vertexColor;
#endif
#ifdef USE_PER_VERTEX_LIGHTING
varying vec3 v_diffuse;
#ifdef USE_SPECULAR
varying vec3 v_specular;
#endif
#endif
#if defined(USE_POSITION) || defined(USE_VIEW)
varying vec3 v_position;
#endif
#ifdef USE_NORMAL
varying vec3 v_normal;
#endif
#ifdef USE_TANGENT
varying vec3 v_tangent;
#endif
#ifdef USE_BITANGENT
varying vec3 v_bitangent;
#endif
#if defined(USE_SPECULAR) && defined(USE_PER_VERTEX_LIGHTING)
uniform float u_materialShininess;
#endif
void main(void)
  _geometry.position = a_position;
  #ifdef USE_NORMAL
  _geometry.normal = a_normal;
  #endif
  #if defined(USE_TANGENT) || defined(USE_BITANGENT)
  _geometry.tangent = a_tangent;
  #endif
  #ifdef NEED_IN_TEXCOORD0
  _geometry.texcoords[0] = a_texCoord0;
  #endif
  #ifdef NEED_IN_TEXCOORD1
  _geometry.texcoords[1] = a_texCoord1;
  #endif
  #ifdef NEED_IN_TEXCOORD2
  _geometry.texcoords[2] = a_texCoord2;
  #endif
  #ifdef NEED_IN_TEXCOORD3
  _geometry.texcoords[3] = a_texCoord3;
  #endif
  #ifdef NEED_IN_TEXCOORD4
  _geometry.texcoords[4] = a_texCoord4;
  #endif
  #ifdef NEED_IN_TEXCOORD5
  _geometry.texcoords[5] = a_texCoord5;
  #endif
  #ifdef NEED_IN_TEXCOORD6
  _geometry.texcoords[6] = a_texCoord6;
  #endif
  #ifdef NEED_IN_TEXCOORD7
  _geometry.texcoords[7] = a_texCoord7;
  #endif
#ifdef USE_VERTEX_COLOR
  _geometry.color = a_color;
#endif
  #ifdef USE_SKINNING
    vec3 pos = vec3(0.);
    #ifdef USE_NORMAL
    vec3 nrm = vec3(0.);
    #endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    vec3 tgt = vec3(0.);
    #endif
    for (int i = 0; i < MAX_BONE_INFLUENCES; ++i) {
#if MAX_BONE_INFLUENCES == 1
        float weight = 1.0;
#else
        float weight = a_skinningWeights[i];
        
#endif
      int idx = int(a_skinningJoints[i]) * 3;
      mat4 jointMatrix = mat4(u_skinningJointMatrices[idx], u_skinningJointMatrices[idx+1], u_skinningJointMatrices[idx+2], vec4(0., 0., 0., 1.));
            pos += (_geometry.position * jointMatrix).xyz * weight;
      #ifdef USE_NORMAL
            nrm += _geometry.normal * mat3(jointMatrix) * weight;
      #endif
      #if defined(USE_TANGENT) || defined(USE_BITANGENT)
            tgt += _geometry.tangent.xyz * mat3(jointMatrix) * weight;
      #endif
    }
    
    _geometry.position.xyz = pos;
    #ifdef USE_NORMAL
    _geometry.normal = nrm;
    #endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent.xyz = tgt;
    #endif
  #endif
  #ifdef USE_GEOMETRY_MODIFIER
__DoGeometryModifier__
  #endif
  #ifdef USE_POSITION
  _surface.position = (u_modelViewTransform * _geometry.position).xyz;
  #endif
  #ifdef USE_NORMAL
  _surface.normal = normalize(mat3(u_normalTransform) * _geometry.normal);
  #endif
  #if defined(USE_TANGENT) || defined(USE_BITANGENT)
  _surface.tangent = normalize(mat3(u_normalTransform) * _geometry.tangent.xyz);
  _surface.bitangent =  cross(_surface.tangent, _surface.normal); 
    
  #endif
  #ifdef USE_VIEW
    _surface.view = normalize(-_surface.position);
  #endif
  #ifdef USE_PER_VERTEX_LIGHTING
  _lightingContribution.diffuse = vec3(0.);
  #ifdef USE_SPECULAR
  _lightingContribution.specular = vec3(0.);
  _surface.shininess = u_materialShininess;
  #endif
__DoLighting__
  v_diffuse = _lightingContribution.diffuse;
  #ifdef USE_SPECULAR
  v_specular = _lightingContribution.specular;
  #endif
  #endif
  #if defined(USE_POSITION) && (USE_POSITION == 2)
  v_position = _surface.position;
  #endif
  #if defined(USE_NORMAL) && (USE_NORMAL == 2)
  v_normal = _surface.normal;
  #endif
  #if defined(USE_TANGENT) && (USE_TANGENT == 2)
  v_tangent = _surface.tangent;
  #endif
  #if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
  v_bitangent = _surface.bitangent;
  #endif
  #ifdef USE_VERTEX_COLOR
  v_vertexColor = _geometry.color;
  #endif
#ifdef USE_TEXCOORD
__DoTexcoord__
#endif
    
  #if defined(SEPARATE_PROJECTION) && SEPARATE_PROJECTION
  gl_Position = u_projectionTransform * vec4(_surface.position, 1.);
  #else
  gl_Position = u_modelViewProjectionTransform * _geometry.position;
  #endif
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
attribute vec4 a_color;
varying vec4 v_vertexColor;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
    v_vertexColor = a_color;
struct scn_floor_t {
    float3 u_floorNormal;
    float4 u_floorTangent;
    float3 u_floorCenter;
    float2 u_floorExtent;
#pragma arguments
    scn_floor_t scn_fg
#pragma body
    float3 u_floorNormal = scn_fg.u_floorNormal;
    float4 u_floorTangent = scn_fg.u_floorTangent;
    float3 u_floorCenter = scn_fg.u_floorCenter;
    float2 u_floorExtent = scn_fg.u_floorExtent;
    float3 floorBitangent =  normalize(cross(u_floorTangent.xyz, u_floorNormal));
    _geometry.position.xyz = u_floorCenter.xyz + u_floorExtent.x * (_geometry.position.x * u_floorTangent.xyz) + u_floorExtent.y * (_geometry.position.y * floorBitangent);
    _geometry.normal = u_floorNormal;
    _geometry.tangent = u_floorTangent;
    
    float2 tc;
    if (u_floorNormal.y != 0.)
        tc = _geometry.position.xz * 0.01;
    else if (u_floorNormal.z != 0.)
        tc = _geometry.position.xy * 0.01;
    else
        tc = _geometry.position.yz * 0.01;
    for (int i = 0; i < kSCNTexcoordCount; ++i)
        _geometry.texcoords[i] = tc;
uniform sampler2D textureSampler0;
uniform float factor;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2D(textureSampler0,TexCoord) * factor;
uniform samplerCube textureSampler0;
varying vec3 TexCoord;
#if __VERSION__ > 120 
#define textureCube(tex,coord) texture( tex, coord )
#endif
void main (void)
    
gl_FragColor = textureCube(textureSampler0,TexCoord);
uniform sampler2D colorSampler;
uniform sampler2D smallBlurSampler;
uniform sampler2D largeBlurSampler;
uniform sampler2D depthSampler;
uniform vec2 u_inversePixelSize;
uniform vec4 dofLerpScale;
uniform vec4 dofLerpBias;
uniform vec3 CocScaleBias;
varying vec2 v_texCoord;
float saturate(float val)
    return clamp(val, 0., 1.);
vec4 saturate(vec4 val)
    return clamp(val, vec4(0.), vec4(1.));
vec4 tex2Doffset(sampler2D s, vec2 tc, vec2 offset )
  return texture2D( s, tc + offset * u_inversePixelSize );
vec3 GetSmallBlurSample( vec3 unblur, vec2 tc )
    
    
    
    vec3 sum = tex2Doffset( colorSampler, tc, vec2(+0.5, -1.5) ).rgb;
    sum += tex2Doffset( colorSampler, tc, vec2(-1.5, -0.5) ).rgb;
    sum += tex2Doffset( colorSampler, tc, vec2(-0.5, +1.5) ).rgb;
    sum += tex2Doffset( colorSampler, tc, vec2(+1.5, +0.5) ).rgb;
    return (4.0 * sum + unblur) / 17.;
vec4 InterpolateDof( vec3 unblur, vec3 small, vec3 med, vec3 large, float t )
    
    
    
    
    
    
    
    
    vec4 weights = saturate( t * dofLerpScale + dofLerpBias );
    weights.yz = min( weights.yz, 1. - weights.xy );
    
    
    
    
    vec3 color = weights.x * unblur + weights.y * small + weights.z * med + weights.w * large;
    return vec4(color, 1.);
    
    
    
    
#define DEBUG 0
void main (void)
    vec3 unblur = texture2D( colorSampler, v_texCoord ).rgb;
    vec3 small 
= GetSmallBlurSample(unblur, v_texCoord );
    vec4 med 
= texture2D( smallBlurSampler, v_texCoord );
    vec3 large 
= texture2D( largeBlurSampler, v_texCoord ).rgb;
    float nearCoc = med.a;
    float depth = texture2D( depthSampler, v_texCoord ).r;
    
    
    float farCoc = saturate( - (CocScaleBias.x * depth + CocScaleBias.y) );
    float coc;
    
    
    
    
    {
        
        coc = max( nearCoc, farCoc  );
    }
    gl_FragColor = InterpolateDof( unblur, small, med.rgb, large.rgb, coc );
#if DEBUG
    if (v_texCoord.x < 0.15) {
        gl_FragColor = vec4(unblur, 1.);
    } else if (v_texCoord.x < 0.3) {
        gl_FragColor = vec4(small, 1.);
    } else if (v_texCoord.x < 0.45) {
        gl_FragColor = med;
    } else if (v_texCoord.x < 0.6) {
        gl_FragColor = vec4(large, 1.);
        
    } else if (v_texCoord.x < 0.70) {
        gl_FragColor = vec4(nearCoc, nearCoc, nearCoc, 1.);
    } else if (v_texCoord.x < 0.8){
        gl_FragColor = vec4(farCoc, farCoc, farCoc, 1.);
    }
#endif
    
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>Outline-pickedObjects</string>
<string>Outline-outline</string>
<string>Outline-max</string>
</array>
<key>passes</key>
<dict>
<key>Outline-pickedObjects</key>
<dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>u_modelViewProjectionTransform</key>
<string>u_modelViewProjectionTransform-symbol</string>
<key>u_modelTransform</key>
<string>u_modelTransform-symbol</string>
</dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>pickedObjects-depth</string>
<key>color</key>
<string>pickedObjects-color</string>
</dict>
<key>draw</key>
<string>DRAW_NODES</string>
<key>samples</key>
<integer>1</integer>
<key>overridesCustomProgram</key>
<true/>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>&quot;0. 0. 0. 1.&quot;</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>Outline-outline</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>outline-color</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>pickedColorBuffer</key>
<string>pickedObjects-color</string>
<key>pickedDepthBuffer</key>
<string>pickedObjects-depth</string>
<key>colorBuffer</key>
<string>COLOR</string>
<key>depthBuffer</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-OutlineRetina</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outlineRetina_vert</string>
<key>metalFragmentShader</key>
<string>outlineRetina_frag</string>
</dict>
<key>Outline-max</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>outlineColorBuffer</key>
<string>outline-color</string>
<key>colorBuffer</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-OutlineMax</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outlineMax_vert</string>
<key>metalFragmentShader</key>
<string>outlineMax_frag</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>u_modelViewProjectionTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelViewProjectionTransform</string>
</dict>
<key>u_modelTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelTransform</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>outline-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>r8</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>pickedObjects-depth</key>
<dict>
<key>type</key>
<string>depth</string>
<key>format</key>
<string>depth24</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>pickedObjects-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>r8</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
uniform sampler2D colorSampler;
varying vec4 v_texCoord;
void main (void)
    
    vec4 color;
    color  = texture2D( colorSampler, v_texCoord.xz );
    color += texture2D( colorSampler, v_texCoord.yz );
    color += texture2D( colorSampler, v_texCoord.xw );
    color += texture2D( colorSampler, v_texCoord.yw );
    color *= 0.25;
    
gl_FragColor = vec4(color);
attribute vec4 a_position;
attribute vec4 a_texCoord0; 
attribute vec4 a_texCoord1; 
attribute vec4 a_color; 
uniform mat4 viewTransform; 
uniform mat4 u_projectionTransform;
varying vec2 v_uv0;
varying vec4 v_vertexColor;
void main()
    
    vec4 viewPos = viewTransform * vec4(a_position.xyz, 1);
    vec2 dir0 = normalize((viewTransform * vec4(normalize(a_texCoord1.xyz), 0)).xy);
    vec2 tangent = vec2(-dir0.y, dir0.x);
    
    viewPos.xy += tangent * a_texCoord0.y * a_texCoord1.w;
    v_vertexColor = a_color;
    v_uv0 = vec2(a_texCoord0.x, a_texCoord1.w * 0.5 + 0.5);
    
    gl_Position = u_projectionTransform * viewPos;
varying vec4 v_vertexColor;
varying vec2 v_texCoord;
uniform sampler2D u_sampler;
void main()
    vec4 mask = texture2D(u_sampler, v_texCoord);
    gl_FragColor = v_vertexColor * mask;
#extension GL_OES_standard_derivatives : enable
precision highp float; 
uniform vec4 u_color;
varying vec3 v_vertexCenter;
#if 0
vec3 smooth(vec3 edge0, vec3 edge1, vec3 x);
vec3 smooth(vec3 edge0, vec3 edge1, vec3 x)
    vec3 t = clamp((x - edge0)/(edge1 - edge0), vec3(0.), vec3(1));
    return t * t * (3. - 2. * t);
#endif
void main()
    vec3 d = fwidth(v_vertexCenter);
    vec3 a3 = smoothstep(vec3(0.0), d * 1.5, v_vertexCenter);
    
    float edge =  min(min(a3.x, a3.y), a3.z);
    if (edge >= 1.0)
        discard;
    gl_FragColor = u_color * (1.0 - edge) * 0.95;
attribute vec4 a_position;
uniform mat4 u_modelViewProjectionTransform;
void main(void)
gl_Position = u_modelViewProjectionTransform * a_position;
struct SCNShaderLight
vec4 intensity; 
vec3 direction; 
    
    
    float _att;
    vec3 dir; 
    float dist; 
void main()
    gl_FragColor = vec4(1.,0.,0.,1.);
uniform mat4 u_modelTransform;
#define MOD2 vec2(443.8975,397.2973)
float hash(vec2 p)
    p  = fract(p * MOD2);
    p += dot(p.xy, p.yx+19.19);
    return fract(p.x * p.y);
void main()
    float x = hash(u_modelTransform[3].xy);
gl_FragColor = vec4(vec3(x+1./255.),1.);
#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)
static inline void scn_smooth_geometry_pn_triangle(thread float3 &position, thread float3 &normal, float3 patchCoord, float3 P0, float3 P1, float3 P2, float3 N0, float3 N1, float3 N2)
    float u = patchCoord.y;
    float v = patchCoord.z;
    float w = patchCoord.x;
    
    float3 P0P1 = P1 - P0;
    float3 P1P2 = P2 - P1;
    float3 P2P0 = P0 - P2;
    
    float w12 = dot(P0P1, N0);
    float w23 = dot(P1P2, N1);
    float w31 = dot(P2P0, N2);
    
    float w21 = dot(-P0P1, N1);
    float w32 = dot(-P1P2, N2);
    float w13 = dot(-P2P0, N0);
    
    float inv3 = 1.f / 3.f;
    
    float3 b210 = (2.f * P0 + P1 - w12 * N0) * inv3;
    float3 b021 = (2.f * P1 + P2 - w23 * N1) * inv3;
    float3 b201 = (2.f * P0 + P2 - w13 * N0) * inv3;
    
    float3 b120 = (2.f * P1 + P0 - w21 * N1) * inv3;
    float3 b012 = (2.f * P2 + P1 - w32 * N2) * inv3;
    float3 b102 = (2.f * P2 + P0 - w31 * N2) * inv3;
    
    float3 E = (b210 + b120 + b021 + b012 + b201 + b102) / 6.f;
    float3 V = (P0 + P1 + P2) * inv3;
    float3 b111 = E + (E - V) / 2.f;
    
    position.xyz =
    P0 * (w * w * w) +
    P1 * (u * u * u) +
    P2 * (v * v * v) +
    b210 * (3.f * w * w * u) +
    b120 * (3.f * w * u * u) +
    b201 * (3.f * w * w * v) +
    b021 * (3.f * u * u * v) +
    b102 * (3.f * w * v * v) +
    b012 * (3.f * u * v * v) +
    b111 * (6.f * w * u * v);
    
    float3 v12 = 2.f * dot(P0P1, N0 + N1) / dot(P0P1, P0P1);
    float3 v23 = 2.f * dot(P1P2, N1 + N2) / dot(P1P2, P1P2);
    float3 v31 = 2.f * dot(P2P0, N2 + N0) / dot(P2P0, P2P0);
    
    float3 h110 = N0 + N1 - v12 * P0P1;
    float3 h011 = N1 + N2 - v23 * P1P2;
    float3 h101 = N2 + N0 - v31 * P2P0;
    
    float3 n010 = normalize(h110);
    float3 n011 = normalize(h011);
    float3 n001 = normalize(h101);
    
    normal = normalize(
    N0 * w * w +
    N1 * u * u +
    N2 * v * v +
    n010 * w * u +
    n011 * u * v +
    n001 * w * v);
#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)
static inline void scn_smooth_geometry_phong(thread float3 &position, thread float3 &normal, float3 patchCoord, float3 P0, float3 P1, float3 P2, float3 N0, float3 N1, float3 N2)
    float3 P = scn::barycentric_mix(P0, P1, P2, patchCoord);
    
    float3 proj0 = P - dot(P - P0, N0) * N0;
    float3 proj1 = P - dot(P - P1, N1) * N1;
    float3 proj2 = P - dot(P - P2, N2) * N2;
    
    float3 Pproj = scn::barycentric_mix(proj0, proj1, proj2, patchCoord);
    
    const float alpha = 0.75f;
    position = mix(P, Pproj, alpha);
    normal = normalize(scn::barycentric_mix(N0, N1, N2, patchCoord));
#endif 
#import <metal_stdlib>
using namespace metal;
struct sh2_coefficients
    float4 R;
    float4 G;
    float4 B;
struct sh3_coefficients
    float4 ar;
    float4 ag;
    float4 ab;
    float4 br;
    float4 bg;
    float4 bb;
    float4 c;
struct SCNPBRSurface {
    float3 n;
    float3 v;
    
    float3 albedo;
    float3 emission;
    float3 selfIllumination;
    float  metalness;
    float  roughness;
    float  ao;
    float  selfIlluminationOcclusion;
#define PBR_F0_NON_METALLIC 0.04f
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
inline float3 shEvalDirection(float4 dir, sh2_coefficients cachedSH)
    const float Exponent = 1;
    
    
    sh2_vector diffSH = sh2_compute_diffuse_transfer(half3(dir.xyz), Exponent);
    
    
    half3 lighting = max(half3(0,0,0), sh2_dot(cachedSH, diffSH)) * M_1_PI_F;
    
    
    
    return float3(lighting);
#endif
inline float3 shEvalDirection(float4 dir, sh3_coefficients sh)
    float3 x1, x2, x3;
    
    
    x1.r = dot(sh.ar, dir);
    x1.g = dot(sh.ag, dir);
    x1.b = dot(sh.ab, dir);
    
    
    float4 vB = dir.xyzz * dir.yzzx;
    x2.r = dot(sh.br, vB);
    x2.g = dot(sh.bg, vB);
    x2.b = dot(sh.bb, vB);
    
    
    float vC = dir.x * dir.x - dir.y * dir.y;
    x3 = sh.c.xyz * vC;
    
    return x1 + x2 + x3;
inline float scn_inverseBits(uint bits) {
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10; 
inline float3 scn_tangentSpaceToLocalSpace(float3 v, float3 normal) {
    float3 tangent,bitangent;
    scn::generate_basis(normal, &tangent, &bitangent);
    
    return tangent * v.x + bitangent * v.y + normal * v.z;
inline float2 scn_sampleHammersley(uint i, uint sampleCount) {
    return float2(float(i) / sampleCount, scn_inverseBits(i));
static float3 scn_importanceSampleGGX_brdf(float2 random, float roughness) __attribute__((overloadable)) {
    float alpha = roughness * roughness; 
    
    
    
    float cosTheta = sqrt((1.0 - random.x) / (1.0 + (alpha * alpha - 1.0) * random.x + 1e-6));
    float phi = 2.0 * M_PI_F * random.y;
    
    
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    return float3(sinTheta * cos(phi),
                  sinTheta * sin(phi),
                  cosTheta);
static float3 scn_importanceSampleGGX_brdf(float2 random, float roughness, float3 n) __attribute__((overloadable)) {
    float3 importanceSampleGGX = scn_importanceSampleGGX_brdf(random, roughness);
    return scn_tangentSpaceToLocalSpace(importanceSampleGGX, n);
static float3 scn_importanceSampleCosine_brdf(float2 random) __attribute__((overloadable)) {
    
    
    
    float r = sqrt(random.x);
    float phi = 2.0 * M_PI_F * random.y;
    
    float cosPhi;
    float sinPhi = sincos(phi, cosPhi);
    
    
    float x = r * cosPhi;
    float y = r * sinPhi;
    float z = sqrt(max(0.f, 1.f - random.x)); 
    return float3(x, y, z);
static float3 scn_importanceSampleCosine_brdf(float2 random, float3 n) __attribute__((overloadable)) {
    float3 importanceSampleCosine = scn_importanceSampleCosine_brdf(random);
    return scn_tangentSpaceToLocalSpace(importanceSampleCosine, n);
inline float scn_brdf_D(float alpha, float NoH) {
    float alpha_squared = alpha * alpha;
    float denom = (NoH * alpha_squared - NoH) * NoH + 1.0f;
    float denom_squared = denom * denom;
    return alpha_squared / (denom_squared * M_PI_F);
inline float3 scn_brdf_F(float3 F0, float LoH) {
    return F0 + (1.f - F0) * pow(1.f - LoH, 5.f);
inline float3 scn_brdf_F_opt(float3 F0, float LoH) {
    float inv_LoH = 1.f - LoH;
    float inv_LoH_pow_2 = inv_LoH * inv_LoH;
    float inv_LoH_pow_5 = inv_LoH_pow_2 * inv_LoH_pow_2 * inv_LoH;
    return F0 + (1.f - F0) * inv_LoH_pow_5;
inline float scn_brdf_G(float alpha, float NoL, float NoV) {
    float k = 0.5f * alpha;
    float Gl = NoL / (NoL * (1.0 - k) + k);
    float Gv = NoV / (NoV * (1.0 - k) + k);
    return Gl * Gv;
inline float scn_brdf_V(float alpha, float NoL, float NoV) {
    float alpha_squared = alpha * alpha;
    float NoL_squared = NoL * NoL;
    float NoV_squared = NoV * NoV;
    float lambda_L = NoV * sqrt(NoL_squared + alpha_squared * (1.0f - NoL_squared));
    float lambda_V = NoL * sqrt(NoV_squared + alpha_squared * (1.0f - NoV_squared));
    return 0.5f / (lambda_L + lambda_V + 1e-6f);
inline float scn_brdf_V_opt(float alpha, float LoH) {
    float k = alpha * 0.5f;
    float k2 = k * k;
    float invK2 = 1.f - k2;
    return 1.f / (LoH * LoH * invK2 + k2);
static float2 scn_computeHammonFactors(float NdotL, float NdotH, float NdotV, float LdotV, float roughness)
    float facing = 0.5f + 0.5f * LdotV;
    float rough = facing * (0.9f - 0.4f * facing) * (0.5f + NdotH) / NdotH;
    float smooth = 1.05f * (1.0f - pow(1.0f - NdotL, 5.f)) * (1.0f - pow(1.0f - NdotV, 5.f));
    float single = mix(smooth, rough, roughness);
    float multi = 0.1159f * roughness;
    return float2(single, multi);
inline float4 scn_specularDFG(float NoV,
                              float roughness)
    float4 DFG = float4(0.0);
    
    
    
    float3 v = float3(sqrt(1.0 - NoV * NoV),
                      0.0,
                      NoV);
    
    float alpha = roughness * roughness; 
    
    ushort const sampleCount = 1024;
    for (ushort i = 0; i < sampleCount; ++i) {
        float2 random = scn_sampleHammersley(i, sampleCount);
        
        float3 h = scn_importanceSampleGGX_brdf(random, roughness); 
        float3 l = reflect(-v, h); 
        
        float NoL = saturate(l.z); 
        float NoH = saturate(h.z); 
        float LoH = saturate(dot(l, h));
        
        if (NoL > 0.0 && NoH * NoV != 0.0) {
            float G = scn_brdf_G(alpha, NoL, NoV);
            float GVis = G * LoH / (NoH * NoV);
            float Fc = pow(1.0 - LoH, 5.0);
            DFG.x += (1.0 - Fc) * GVis;
            DFG.y += Fc * GVis;
        }
        
        float3 Ld = scn_importanceSampleCosine_brdf(random); 
        float NoLd = saturate(Ld.z);
        if (NoLd > 0) {
            float3 Hd = normalize(v + Ld);
            float NoHd = Hd.z;
            
            float LoVd = saturate(dot(Ld, v));
            float2 HF = scn_computeHammonFactors(NoLd, NoHd, NoV, LoVd, roughness);
            DFG.z += HF.x;
            DFG.w += HF.y;
        }
    }
    
    return DFG / sampleCount;
inline float3 scn_irradiance_cube(texturecube<float, access::sample> environment,
                                  uint                               environmentMipmapLevel,
                                  float3                             n_cube)
    float3 n = float3(n_cube.x, -n_cube.z, n_cube.y);
    
    constexpr sampler linearSampler(filter::linear);
    
    float3 L = float3(0.0);
    float weight = 0.0f;
    
    ushort const sampleCount = 1024;
    for (ushort i = 0; i < sampleCount; ++i) {
        float2 random = scn_sampleHammersley(i, sampleCount);
        float3 l = scn_importanceSampleCosine_brdf(random, n); 
        float NoL = saturate(dot(n, l));
        
        if (NoL > 0) {
            float3 Li = environment.sample(linearSampler, float3(l.x , l.z, -l.y), level(environmentMipmapLevel)).rgb;
            L += Li; 
            weight += 1.0;
        }
    }
    
    return L / weight;
inline float scn_pbr_distanceAttenuation(float3 lightVector)
    float sqrDist = dot(lightVector, lightVector);
    return 1. / max(sqrDist, 0.0001);
inline float3 scn_pbr_reference_world(SCNPBRSurface                      surface,
                                      texturecube<float, access::sample> environment,
                                      uint                               environmentSamplingLevel,
                                      float4x4                           localDirToWorldCubemapDir,
                                      float                              environmentIntensity)
    constexpr sampler linearSampler(filter::linear, mip_filter::linear);
    
    float3 n = surface.n;
    float3 v = surface.v;
    float3 albedo = surface.albedo;
    float metalness = surface.metalness;
    float roughness = surface.roughness;
    float ambientOcclusion = surface.ao;
    
    float NoV = saturate(dot(n, v));
    
    float3 effectiveAlbedo = mix(albedo, float3(0.0), metalness);
    float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), albedo, metalness);
    
    
    float3 irradiance = float3(0.0);
    
    ushort const sampleCountDiffuse = 1024;
    for (ushort i = 0; i < sampleCountDiffuse; ++i) {
        float2 random = scn_sampleHammersley(i, sampleCountDiffuse);
        float3 l = scn_importanceSampleCosine_brdf(random, n); 
        
        float NoL = saturate(dot(n, l));
        
        if (NoL > 0) {
            float3 Li = environment.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, l), level(environmentSamplingLevel)).rgb * environmentIntensity;
            irradiance += Li; 
        }
    }
    
    irradiance = irradiance / float(sampleCountDiffuse);
    
    
    float3 specular = float3(0.0);
    float specularWeight = 0.0;
    
    float correctedRoughness = mix(1.0f / 128.0f, 1.0f - 1.0f / 128.0f, roughness);
    float alpha = correctedRoughness * correctedRoughness; 
    
    ushort const sampleCountSpecular = 128;
    for (ushort i = 0; i < sampleCountSpecular; ++i) {
        float2 random = scn_sampleHammersley(i, sampleCountSpecular);
        float3 h = scn_importanceSampleGGX_brdf(random, correctedRoughness, n); 
        float3 l = reflect(-v, h); 
        
        float NoL = saturate(dot(n, l));
        float NoH = saturate(dot(n, h));
        float LoH = saturate(dot(l, h));
        
        if (NoH * NoV > 0) {
            float3 Li = environment.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, l), level(environmentSamplingLevel)).rgb * environmentIntensity;
            float3 F = scn_brdf_F(reflectance, LoH);
            float G = scn_brdf_G(alpha, NoL, NoV);
#if 0
            float D = scn_brdf_D(alpha, NoH);
            float pdf = (D * NoH) / (4.0f * LoH);
            
            if (pdf >= 0) {
                float3 l = D * F * G / (4.0f * NoV); 
                specular += Li * l / pdf;
                specularWeight += 1.0f;
            }
#else
            specular += Li * F * G * LoH / (NoH * NoV);
            specularWeight += 1.0f;
#endif
        }
    }
    
    specular /= specularWeight;
    
    
    return ambientOcclusion * (effectiveAlbedo * irradiance + specular);
inline float3x3 scn_ltc_matrix_invert_transpose(float3x3 m)
    float a = m[0][0];
    float b = m[1][0];
    float c = m[0][1];
    float d = m[1][1];
    float det = a * d - b * c;
    m[0][0] = +det * d;
    m[1][0] = -det * b;
    m[1][0] = -det * c;
    m[1][1] = +det * a;
    m[2][2] = 1.f / m[2][2];
    return m;
inline float3x3 scn_sample_area_light_precomputed_data(float3                 v,
                                                       float3                 n,
                                                       float                  roughness,
                                                       thread float*          brdfNorm,
                                                       texture2d_array<float> bakedDataTexture)
    constexpr sampler linearSampler = sampler(address::clamp_to_edge, filter::linear);
    
    float theta = acos(fabs(dot(n, v)));
    float2 uv = float2(roughness, theta * M_2_PI_F);
    
    float4 dataA = bakedDataTexture.sample(linearSampler, uv, 0);
    float4 dataB = bakedDataTexture.sample(linearSampler, uv, 1);
    
    *brdfNorm = dataB.y;
    
    return float3x3(float3(dataA.x, dataA.y, 0.f),
                    float3(dataA.z, dataA.w, 0.f),
                    float3(0.f, 0.f, dataB.x));
inline float3 scn_area_light_polygon_edge_vector_form_factor(float3 cornerDirectionA,
                                                             float3 cornerDirectionB)
    
    
    
#if 0
    float theta = acos(dot(cornerDirectionA, cornerDirectionB));
    return (0.5f * M_1_PI_F) * cross(cornerDirectionA, cornerDirectionB) * ((theta > 0.001) ? theta/sin(theta) : 1.0);
#else
    float x = dot(cornerDirectionA, cornerDirectionB);
    float y = abs(x);
    
    float a = 5.42031f + (3.12829f + 0.0902326 * y) * y;
    float b = 3.45068f + (4.18814f + y) * y;
    float thetaOverSinTheta = a / b;
    
    if (x < 0.f)
        thetaOverSinTheta = M_PI_F * rsqrt(1.f - x * x) - thetaOverSinTheta;
    
    float3 u = cross(cornerDirectionA, cornerDirectionB);
    return (0.5f * M_1_PI_F) * thetaOverSinTheta * u;
#endif
inline float scn_area_light_horizon_clipped_sphere_form_factor_from_polygon_vector_form_factor(float3 vectorFormFactor)
#if 1
    
    float l = length(vectorFormFactor);
    return max((l * l + vectorFormFactor.y) / (l + 1.f), 0.f);
#else
    
    return max(vectorFormFactor.y, 0.f);
#endif
inline float pbr_area_light_eval_rectangle(float4x3 corners)
    
    
    
    float3 corner0 = normalize(corners[0]);
    float3 corner1 = normalize(corners[1]);
    float3 corner2 = normalize(corners[2]);
    float3 corner3 = normalize(corners[3]);
    
    float3 vectorFormFactor = float3(0.f);
    vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner0, corner1);
    vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner1, corner2);
    vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner2, corner3);
    vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner3, corner0);
    
    return scn_area_light_horizon_clipped_sphere_form_factor_from_polygon_vector_form_factor(vectorFormFactor);
inline float pbr_area_light_eval_polygon(float3                position,
                                         float3                lightCenter,
                                         float3                lightRight,
                                         float3                lightTop,
                                         uint32_t              vertexCount,
                                         device packed_float2 *vertexPositions)
    
    
    
    float3 vectorFormFactor = float3(0.f);
    for (uint32_t vertexIndex = 0; vertexIndex < vertexCount; ++vertexIndex) {
        packed_float2 localCorner0 = vertexPositions[vertexIndex];
        packed_float2 localCorner1 = vertexPositions[(vertexIndex + 1) % vertexCount];
        
        
        
        float3 cornerDirection0 = lightCenter - localCorner0[0] * lightRight + localCorner0[1] * lightTop;
        float3 cornerDirection1 = lightCenter - localCorner1[0] * lightRight + localCorner1[1] * lightTop;
        
        float3 corner0 = normalize(cornerDirection0 - position);
        float3 corner1 = normalize(cornerDirection1 - position);
        
        vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner0, corner1);
    }
    
    return scn_area_light_horizon_clipped_sphere_form_factor_from_polygon_vector_form_factor(vectorFormFactor);
inline float pbr_area_light_line_integral_position(float d, float l) {
    float d_squared = d * d;
    float l_squared = l * l;
    return l / (d * (d_squared + l_squared)) + atan(l / d) / d_squared;
inline float pbr_area_light_line_integral_direction(float d, float l) {
    float d_squared = d * d;
    float l_squared = l * l;
    return l_squared / (d * (d_squared + l_squared));
inline float pbr_area_light_eval_line(float2x3 cornerDirections)
    
    
    
    float3 corner0 = normalize(cornerDirections[0]);
    float3 corner1 = normalize(cornerDirections[1]);
    
    float3 direction = normalize(corner1 - corner0);
    
    if (corner0.y <= 0.f && corner1.y <= 0.f) return 0.f;
    if (corner0.y < 0.f) corner0 = (+corner0 * corner1.y - corner1 * corner0.y) / (+corner1.y - corner0.y);
    if (corner1.y < 0.f) corner1 = (-corner0 * corner1.y + corner1 * corner0.y) / (-corner1.y + corner0.y);
    
    float l1 = dot(corner0, direction);
    float l2 = dot(corner1, direction);
    
    float3 position = corner0 - l1 * direction;
    float d = length(position);
    
    float I = (pbr_area_light_line_integral_position(d, l2) - pbr_area_light_line_integral_position(d, l1)) * position.y
            + (pbr_area_light_line_integral_direction(d, l2) - pbr_area_light_line_integral_direction(d, l1)) * direction.y;
    
    return M_1_PI_F * I;
uniform vec3 CocScaleBias;
uniform sampler2D colorSampler;
uniform sampler2D depthSampler;
uniform vec2 u_inversePixelSize;
varying vec2 v_tcColor0;
varying vec2 v_tcColor1;
varying vec2 v_tcDepth0;
varying vec2 v_tcDepth1;
varying vec2 v_tcDepth2;
varying vec2 v_tcDepth3;
vec4 saturate(vec4 val)
    return clamp(val, vec4(0.), vec4(1.));
void main (void)
    
    vec4 dofRowDelta = vec4(0., 1., 2., 3.) * u_inversePixelSize.y * 0.25;
    vec2 rowOfs[4];
    rowOfs[0] = dofRowDelta.xx; 
    rowOfs[1] = dofRowDelta.xy;
    rowOfs[2] = dofRowDelta.xz;
    rowOfs[3] = dofRowDelta.xw;
    
    
    vec3 color;
    color  = texture2D( colorSampler, v_tcColor0.xy ).rgb;
    color += texture2D( colorSampler, v_tcColor1.xy ).rgb;
    color += texture2D( colorSampler, v_tcColor0.xy + rowOfs[2] ).rgb;
    color += texture2D( colorSampler, v_tcColor1.xy + rowOfs[2] ).rgb;
    color *= 0.25;
    
    vec4 depth;
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[0] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[0] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[0] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[0] ).r;
    vec4 coc = abs(depth * CocScaleBias.x + CocScaleBias.y);
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[1] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[1] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[1] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[1] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[2] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[2] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[2] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[2] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[3] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[3] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[3] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[3] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    float maxCoc = max( max( coc.x, coc.y ), max( coc.z, coc.w ) );
    
    
gl_FragColor = vec4(color, maxCoc);
varying vec4 v_vertexColor;
void main()
    gl_FragColor = v_vertexColor;
#ifndef __SCNMetalDefines__
#define __SCNMetalDefines__
enum {
    SCNVertexSemanticPosition,
    SCNVertexSemanticNormal,
    SCNVertexSemanticTangent,
    SCNVertexSemanticColor,
    SCNVertexSemanticBoneIndices,
    SCNVertexSemanticBoneWeights,
    SCNVertexSemanticTexcoord0,
    SCNVertexSemanticTexcoord1,
    SCNVertexSemanticTexcoord2,
    SCNVertexSemanticTexcoord3,
    SCNVertexSemanticTexcoord4,
    SCNVertexSemanticTexcoord5,
    SCNVertexSemanticTexcoord6,
    SCNVertexSemanticTexcoord7
struct SCNSceneBuffer {
    float4x4    viewTransform;
    float4x4    inverseViewTransform; 
    float4x4    projectionTransform;
    float4x4    viewProjectionTransform;
    float4x4    viewToCubeTransform; 
    float4x4    lastFrameViewProjectionTransform;
    float4      ambientLightingColor;
    float4
fogColor;
    float3
fogParameters; 
    float2      inverseResolution;
    float       time;
    float       sinTime;
    float       cosTime;
    float       random01;
    float       motionBlurIntensity;
    
    float       environmentIntensity;
    float4x4    inverseProjectionTransform;
    float4x4    inverseViewProjectionTransform;
    
    float2      nearFar; 
    float4      viewportSize; 
    
    float4x4    inverseTransposeViewTransform;
    
    float4      clusterScale; 
#endif 
attribute vec4 a_position;
uniform vec2 u_inversePixelSize;
varying vec4 v_texCoord;
void main(void)
gl_Position = a_position;
    vec2 tc = (a_position.xy + 1.0) * 0.5;
    vec4 offset = vec4(-0.5, 0.5, -0.5, 0.5);
    v_texCoord = tc.xxyy + offset * u_inversePixelSize.xyxy;
varying vec2 TexCoord;
uniform sampler2D textureSampler0;
uniform vec2 offsets[MAX_SAMPLE];
uniform float weights[MAX_SAMPLE];
uniform int n_sample;
void main (void)
    int i;
    vec4 accum = vec4(0.0);
    for(i=0;i<n_sample;i++){
        accum += texture2D(textureSampler0, TexCoord+offsets[i]) *  weights[i];
    }
gl_FragColor = accum;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>targets</key>
<dict>
<key>VELOCITY</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba16f</string>
<key>scaleFactor</key>
<integer>1</integer>
<key>global</key>
<true/>
<key>clearColor</key>
<string>0. 0. 0. 999999999.</string>
</dict>
</dict>
<key>sequence</key>
<array>
<string>SceneKit_renderScene</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderScene</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>color1</key>
<string>VELOCITY</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
</dict>
</plist>
  "passes" : {
    "SceneKit_renderSceneFromLight" : {
      "outputs" : {
        "depth" : "SceneKit-spotShadowDepth"
      },
      "depthStates" : {
        "clear" : true
      },
      "isViewDependant" : false,
      "samples" : 1,
      "onlyShadowCasters" : true,
      "pointOfView" : "self",
      "ignoreFloors" : true,
      "draw" : "DRAW_SCENE"
    },
    "SceneKit_applyDeferredShadows" : {
      "outputs" : {
        "color" : "COLOR"
      },
      "inputs" : {
          "light_MVP" : "C3D-light_MVP-symbol",
          "viewTransform" : "C3D-camera_view-symbol",
          "depthSampler" : {
          "target" : "DEPTH",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_kernel" : "C3D-shadowKernel-symbol",
        "lightDepthSampler" : {
          "target" : "SceneKit-spotShadowDepth",
          "sampler" : {
            "wrapS" : "clamp",
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest",
            "wrapT" : "clamp"
          }
        },
        "shadowColor" : "C3D-shadowColor-symbol",
        "colorSampler" : "COLOR",
        "camera_MVP_i" : "C3D-camera_MVP_i-symbol",
        "cascadeScale" : "C3D-cascadeScale-symbol",
        "cascadeBias" : "C3D-cascadeBias-symbol",
        "cascadeDebugFactor" : "C3D-shadowCascadeDebugFactor-symbol",
        "u_lightPos" : "C3D-u_lightPos-symbol",
        "u_lightDir" : "C3D-u_lightDir-symbol",
        "shadowRadius" : "C3D-shadowRadius-symbol",
        "u_lightSpotAtt" : "C3D-u_lightSpotAtt-symbol"
      },
      "metalFragmentShader" : "shadowMap_frag",
      "draw" : "DRAW_QUAD",
      "clientProgram" : false,
      "metalVertexShader" : "shadowMap_vert"
    }
  },
  "sequence" : [
    "SceneKit_renderSceneFromLight",
    "SceneKit_applyDeferredShadows"
  ],
  "symbols" : {
    "C3D-u_lightSpotAtt-symbol" : {
      "type" : "vec3"
    },
    "C3D-shadowColor-symbol" : {
      "type" : "vec4"
    },
    "C3D-camera_MVP_i-symbol" : {
      "type" : "mat4"
    },
    "C3D-camera_view-symbol" : {
      "type" : "mat4"
    },
    "C3D-u_lightPos-symbol" : {
      "type" : "vec3"
    },
    "C3D-zMapFactor-symbol" : {
      "type" : "float"
    },
    "C3D-light_MVP-symbol" : {
      "type" : "mat4"
    },
    "C3D-shadowRadius-symbol" : {
      "type" : "float"
    },
    "C3D-shadowCascadeDebugFactor-symbol" : {
      "type" : "float"
    },
    "C3D-shadowKernel-symbol" : {
      "type" : "vec4[128]"
    },
    "C3D-cascadeScale-symbol" : {
      "type" : "vec3[4]"
    },
    "C3D-cascadeBias-symbol" : {
      "type" : "vec3[4]"
    },
    "C3D-u_lightDir-symbol" : {
      "type" : "vec3"
    }
  },
  "targets" : {
    "SceneKit-spotShadowDepth" : {
      "type" : "depth"
    }
attribute vec2 a_texCoord1; 
attribute vec4 a_position; 
attribute vec3 a_texCoord0; 
attribute vec4 a_color; 
#ifdef ENABLE_STRETCH
attribute vec4 a_texCoord2; 
uniform float u_stretchFactor;
#elif defined(ENABLE_ORIENTATION_FREE)
attribute vec4 a_texCoord2; 
mat3 axisangle_to_matrix(vec4 axis_angle)
float c = cos(axis_angle.w);
    float s = sin(axis_angle.w);
    float t = 1. - c;
    
    mat3 m;
    m[0][0] = c + axis_angle.x * axis_angle.x * t;
    m[1][1] = c + axis_angle.y * axis_angle.y * t;
    m[2][2] = c + axis_angle.z * axis_angle.z * t;
    
float tmp1 = axis_angle.x * axis_angle.y * t;
    float tmp2 = axis_angle.z * s;
    m[1][0] = tmp1 + tmp2;
    m[0][1] = tmp1 - tmp2;
    
    tmp1 = axis_angle.x * axis_angle.z * t;
    tmp2 = axis_angle.y * s;
    m[2][0] = tmp1 - tmp2;
    m[0][2] = tmp1 + tmp2;
    
    tmp1 = axis_angle.y*axis_angle.z*t;
    tmp2 = axis_angle.x*s;
    m[2][1] = tmp1 + tmp2;
    m[1][2] = tmp1 - tmp2;
    return m;
#endif
#ifdef ENABLE_FOG
uniform mediump vec4 u_fogColor;
uniform vec3 u_fogParameters; 
#endif
#ifdef ENABLE_SOFT
varying float v_eyeLinearZ;
#endif
#ifdef ENABLE_CUBE_MAP
uniform mat4 u_viewToCubeWorld;
varying vec4 v_normal;
#endif
#ifdef ENABLE_ANIMATION
#define REPEAT 0
#define CLAMP 1
#define AUTOREVERSE  2
uniform vec4 u_frameSize; 
float __modf(float value, out float intValue)
float fracValue = fract(value);
intValue = value - fracValue;
return fracValue;
vec4 ComputeUVS(vec2 iNormUV, float iFrame)
vec4 outUV;
#if ENABLE_ANIMATION == CLAMP
    
    iFrame = clamp(iFrame, 0., u_frameSize.w - 1.); 
    
    float intFrame;
    float frameFrac = __modf(iFrame, intFrame);
    vec2 frame;
    frame.x = __modf(intFrame * u_frameSize.x, frame.y);
    frame.y *= u_frameSize.y;
    
    outUV.xy = frame + iNormUV * u_frameSize.xy;
    outUV.w = frameFrac;
    outUV.z = ((frame.x + u_frameSize.x) == 1.)?1.:0.; 
#elif ENABLE_ANIMATION == REPEAT
    
    float tmp = iFrame * u_frameSize.x;
    
    vec2 frame;
    frame.y = tmp - fract(tmp);
    frame.x = fract(tmp) * u_frameSize.z;
    
    float frameFrac = fract(frame.x);
    frame.x -= frameFrac;
    
    outUV.xy = (frame + iNormUV) * u_frameSize.xy;
    outUV.w = frameFrac;
    outUV.z = (frame.x == (u_frameSize.z - 1.))?1.:0.; 
#else 
    
    float invFrameCount = u_frameSize.x * u_frameSize.y;
    float normFrame = iFrame * invFrameCount;
    float lastFrame = u_frameSize.w - 1.;
    float frameIndex = fract(normFrame) * u_frameSize.w;
    if (fract(normFrame * 0.5) > 0.5) {
        frameIndex = (lastFrame-frameIndex);
    }
    frameIndex = clamp(frameIndex, 0., lastFrame); 
    
    float tmp = frameIndex * u_frameSize.x;
    
    vec2 frame;
    frame.y = tmp - fract(tmp);
    
    frame.x = fract(tmp) * u_frameSize.z;
    
    float frameFrac = fract(frame.x);
    frame.x -= frameFrac;
    
    outUV.xy = (frame + iNormUV) * u_frameSize.xy;
    
    outUV.w = frameFrac;
    outUV.z = (frame.x == (u_frameSize.z - 1.))?1.:0.; 
#endif
return outUV;
#endif
uniform mat4 viewTransform; 
uniform mat4 u_projectionTransform;
#ifdef ENABLE_LIGHTING
uniform vec3 u_lightPosition0; 
uniform vec4 u_lightColor0;
#endif
#ifdef ENABLE_COLOR_RAMP
uniform sampler2D u_colorRamp;
#endif
#ifdef ENABLE_ANIMATION
varying vec3 v_uv0;
varying vec2 v_uv1;
#else
varying vec2 v_uv0;
#endif
varying vec4 v_vertexColor;
void main()
    
    vec4 viewPos = viewTransform * vec4(a_position.xyz, 1);
#ifdef ENABLE_STRETCH
    
    vec4 viewDir = viewTransform * vec4(a_texCoord2.xyz, 0);
    viewDir *= u_stretchFactor;
    
    
    viewPos.xyz += (a_texCoord1.y > 0.) ? viewDir.xyz : vec3(0.);
    
    
    vec2 u = normalize(viewDir.xy); 
    vec2 r = vec2(-u.y, u.x);
    vec2 off = r * a_texCoord1.x + u * a_texCoord1.y ; 
    viewPos.xy += off * a_texCoord0.y; 
    vec3 N = normalize(vec3(-off.x, -off.y, -2));
    
#else 
    
    
    float sn = sin(a_position.w);
    float cs = cos(a_position.w);
    
    vec2 dir = vec2( a_texCoord1.x * cs - a_texCoord1.y * sn,  a_texCoord1.y * cs + a_texCoord1.x * sn);
    dir *= a_texCoord0.y;
#ifdef ENABLE_ORIENTATION_FREE
    
    
    mat3 vt = mat3(viewTransform[0].xyz, viewTransform[1].xyz, viewTransform[2].xyz);
    mat3 mat = vt * axisangle_to_matrix(a_texCoord2); 
    
#ifdef ENABLE_CUBE_MAP
    vec3 N = mat[0] * dir.x + mat[1] * dir.y + mat[2];
    viewPos.xy += dir;
#else
    vec3 off = mat[0] * dir.x + mat[1] * dir.y;
    viewPos.xyz += off;
#endif
    
    
#elif defined(ENABLE_BILLBOARD_VIEW)
    vec3 u = vec3(0,1,0);
    vec3 r = normalize(cross(u, -viewPos.xyz));
    vec3 off = dir.x * r + dir.y * u;
    viewPos.xyz += off;
    vec3 N = normalize(vec3(-off.x/a_texCoord0.y, -off.y/a_texCoord0.y, -2));
#elif defined(ENABLE_BILLBOARD_Y)
    vec3 u = (viewTransform * vec4(0, 1, 0, 0)).xyz;
    vec3 r = normalize(cross(u, vec3(0,0,1))); 
    vec3 off = dir.x * r + dir.y * u;
    viewPos.xyz += off;
    vec3 N = normalize(vec3(-off.x/a_texCoord0.y, -off.y/a_texCoord0.y, -2));
    
#else 
    viewPos.xy += dir;
    vec3 N = normalize(vec3(-dir.x, -dir.y, -2));
    
#endif 
#endif 
#ifdef ENABLE_CUBE_MAP
#ifdef ENABLE_ORIENTATION_FREE
    v_normal.xyz = N;
#else
    vec3 refl = reflect( viewPos.xyz, N );
    v_normal.xyz = mat3(u_viewToCubeWorld) * refl;
#endif 
#endif
#ifdef ENABLE_COLOR_RAMP
    v_vertexColor = a_color * texture2D(u_colorRamp, a_texCoord0.xx);
#else 
    v_vertexColor = a_color;
#endif
    
#ifndef ENABLE_BLACKPASS
#ifdef ENABLE_LIGHTING
    vec3 L = normalize(viewPos.xyz - u_lightPosition0);
#if defined(ENABLE_ORIENTATION_FREE) && !defined(ENABLE_CUBE_MAP)
    
    
    vec3 N = sign(dot(mat[2], viewPos.xyz)) * mat[2];
    
    float NdotL = dot(N, L);
    vec3 diff = u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * (1. - abs(NdotL)));
    
    float _shininess = 100.0;
    vec3 halfVector = normalize(L + viewPos.xyz);
    float spec = max(0.0, pow(max(0.0, dot(N, halfVector)), _shininess));
    v_vertexColor.rgb *= diff;
    v_vertexColor.rgb += spec;
#else
    
    vec3 diff = vec3(max(0.0, dot(N, L))) * u_lightColor0.rgb;
    
    
    
    
    
    v_vertexColor.rgb *= diff;
#endif 
#endif 
#endif 
    
#ifdef ENABLE_ANIMATION
    vec4 animUVS = ComputeUVS(a_texCoord1.xy * vec2(0.5, -0.5) + 0.5, a_texCoord0.z);
    v_uv0 = animUVS.xyw;
    v_uv1 = animUVS.xy + u_frameSize.xy * vec2(1.0, animUVS.z);
#else
    v_uv0 = a_texCoord1.xy * vec2(0.5, -0.5) + 0.5;
#endif
    
#ifndef ENABLE_BLACKPASS
    #ifdef ENABLE_FOG
        float fogFactor = pow(clamp(viewPos.z * u_fogParameters.x + u_fogParameters.y, 0.0, u_fogColor.a), u_fogParameters.z);
        #ifdef ENABLE_CUBE_MAP
            v_normal.a = fogFactor;
        #else
            
            v_vertexColor.rgb = mix(v_vertexColor.rgb, u_fogColor.rgb * v_vertexColor.a, fogFactor);
        #endif 
    #endif 
#endif 
#ifdef ENABLE_SOFT
    v_eyeLinearZ = viewPos.z;
#endif
    
    gl_Position = u_projectionTransform * viewPos;
uniform sampler2D colorBuffer;
uniform sampler2D pickedColorBuffer;
uniform sampler2D depthBuffer;
uniform sampler2D pickedDepthBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    
    float texels[9];
    texels[0] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, -u_inverseResolution.y)).r;
    texels[1] = texture2D(pickedColorBuffer, uv + vec2(                0., -u_inverseResolution.y)).r;
    texels[2] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, -u_inverseResolution.y)).r;
    
    texels[3] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, 0.)).r;
    
    texels[5] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, 0.)).r;
    
    texels[6] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, u_inverseResolution.y)).r;
    texels[7] = texture2D(pickedColorBuffer, uv + vec2(                0., u_inverseResolution.y)).r;
    texels[8] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, u_inverseResolution.y)).r;
    
    
    
    vec3 a = vec3(texels[0],texels[3],texels[6]);
    vec3 b = vec3(texels[2],texels[5],texels[7]);
    bvec3 tmp = equal(a,b);
    vec3 retLin = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    a = vec3(texels[0],texels[1],texels[2]);
    b = vec3(texels[6],texels[7],texels[8]);
    tmp = equal(a,b);
    vec3 retCol = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    vec4 last = step(vec4(0.002), vec4(texels[5],texels[7],texels[8], min(retLin.x, retCol.x)) );
    
    
    float x = last.w + 2.*retLin.y + retLin.z - retCol.z - 2.*last.x - last.z;
    float y = last.w + 2.*retCol.y + retCol.z - retLin.z- 2.*last.y - last.z;
    float magnitude = sqrt( x*x + y*y );
    
    
    
    
    float depth = 1.;
    for(int i=-2; i<3; i++)
    for(int j=-2; j<3; j++)
        depth = min(depth, texture2D(pickedDepthBuffer, uv + u_inverseResolution*vec2(i,j)).r);
    
    
    
    vec3 outline = vec3(1.,.6,.2);
    if( texture2D(depthBuffer, uv).x < depth-0.0000001 &&  texture2D(pickedColorBuffer, uv).r > 0.  )
        gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(outline,1.), .25);
    else
        gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(outline,1.), min(magnitude/4.,1.) );
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>sequence</key>
<array>
<string>authoring-overlay</string>
<string>authoringBlend</string>
</array>
<key>targets</key>
<dict>
<key>authoring-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba</string>
</dict>
<key>authoring-depth</key>
<dict>
<key>type</key>
<string>depth</string>
</dict>
</dict>
<key>passes</key>
<dict>
<key>authoring-overlay</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>authoring-color</string>
<key>depth</key>
<string>authoring-depth</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>layerMask</key>
<integer>4</integer>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clearColor</key>
<string>0 0 0 0</string>
<key>clear</key>
<true/>
</dict>
</dict>
<key>authoringBlend</key>
<dict>
<key>clientProgram</key>
<string>NO</string>
<key>program</key>
<string>C3D-BlendAuthoring</string>
<key>metalVertexShader</key>
<string>blendAuthoring_vert</string>
<key>metalFragmentShader</key>
<string>blendAuthoring_frag</string>
<key>inputs</key>
<dict>
<key>authoringColor</key>
<string>authoring-color</string>
<key>sceneColor</key>
<string>COLOR</string>
</dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>depthStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
</dict>
</plist>
uniform sampler2D colorBuffer;
uniform sampler2D pickedColorBuffer;
uniform sampler2D depthBuffer;
uniform sampler2D pickedDepthBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    
    float texels[9];
    texels[0] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, -u_inverseResolution.y)).r;
    texels[1] = texture2D(pickedColorBuffer, uv + vec2(                0., -u_inverseResolution.y)).r;
    texels[2] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, -u_inverseResolution.y)).r;
    
    texels[3] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, 0.)).r;
    
    texels[5] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, 0.)).r;
    
    texels[6] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, u_inverseResolution.y)).r;
    texels[7] = texture2D(pickedColorBuffer, uv + vec2(                0., u_inverseResolution.y)).r;
    texels[8] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, u_inverseResolution.y)).r;
    
    
    
    vec3 a = vec3(texels[0],texels[3],texels[6]);
    vec3 b = vec3(texels[2],texels[5],texels[7]);
    bvec3 tmp = equal(a,b);
    vec3 retLin = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    a = vec3(texels[0],texels[1],texels[2]);
    b = vec3(texels[6],texels[7],texels[8]);
    tmp = equal(a,b);
    vec3 retCol = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    vec4 last = step(vec4(0.002), vec4(texels[5],texels[7],texels[8], min(retLin.x, retCol.x)) );
    
    
    float x = last.w + 2.*retLin.y + retLin.z - retCol.z - 2.*last.x - last.z;
    float y = last.w + 2.*retCol.y + retCol.z - retLin.z- 2.*last.y - last.z;
    float magnitude = sqrt( x*x + y*y );
    
    
    
    
    float depth = 1.;
    for(int i=-1; i<2; i++)
    for(int j=-1; j<2; j++)
        depth = min(depth, texture2D(pickedDepthBuffer, uv + u_inverseResolution*vec2(i,j)).r);
    
    
    
    if( texture2D(depthBuffer, uv).x < depth-0.0000001 &&  texture2D(pickedColorBuffer, uv).r > 0.  )
        gl_FragColor = vec4(.25);
    else
        gl_FragColor = vec4( min(magnitude/4.,1.) );
    
uniform sampler2D u_textureSampler0;
varying vec2 v_uv0;
varying vec4 v_vertexColor;
void main(){
    vec4 tex = texture2D(u_textureSampler0, v_uv0);
    tex.rgb *= tex.a; 
    
    vec4 col = v_vertexColor * tex;
gl_FragColor = vec4(col);
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
attribute vec4 a_color;
attribute vec2 a_texCoord0;
varying vec4 v_vertexColor;
varying vec2 v_texCoord;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
    v_vertexColor = a_color;
    v_texCoord = a_texCoord0;
ManipulatorPass
normalTexcoord
tangent
ambientTexcoord
diffuseTexcoord
specularTexcoord
emissionTexcoord
selfIlluminationTexcoord
multiplyTexcoord
transparentTexcoord
displacementTexcoord
clearCoatTexcoord
clearCoatRoughnessTexcoord
clearCoatNormalTexcoord
fresnel
_surface.%@
_geometry.normal
_geometry.tangent
_geometry.color
C3DShaderModifier
<C3DShaderModifier %p language:%s, entryPoint:"%d" flags:%x
Metal
GLSL
  declaration : %@
  arguments : %@
  varyings : %@
  code : %@
USE_EMISSIVETEXCOORD
USE_AMBIENTTEXCOORD
USE_DIFFUSETEXCOORD
USE_SPECULARTEXCOORD
USE_REFLECTIVETEXCOORD
USE_TRANSPARENTTEXCOORD
USE_FILTERTEXCOORD
USE_NORMALTEXCOORD
USE_METALNESSTEXCOORD
USE_ROUGHNESSTEXCOORD
USE_CLEARCOATTEXCOORD
USE_CLEARCOATROUGHNESSTEXCOORD
USE_CLEARCOATNORMALTEXCOORD
u_%@TextureMatrix
{_SCNVector4=dddd}
{_SCNVector3=ddd}
is%@%@
v@:^v
^v@:
v@:f
v@:i
v@:B
v@:c
v@:d
v@:{CGPoint=dd}
{CGPoint=dd}@:
v@:{SCNVector3=fff}
{SCNVector3=fff}@:
v@:{SCNVector4=ffff}
{SCNVector4=ffff}@:
v@:{SCNMatrix4=ffffffffffffffff}
{SCNMatrix4=ffffffffffffffff}@:
v@:{CATransform3D=ffffffffffffffff}
{CATransform3D=ffffffffffffffff}@:
v@:{C3DMatrix3x3=fffffffff}
{C3DMatrix3x3=fffffffff}@:
v@:{C3DColor4=ffff}
{C3DColor4=ffff}@:
v@:s
v@:C
v@:S
MainPass
#pragma opaque
#pragma transparent
#pragma declaration
#pragma arguments
#pragma varyings
#pragma body
C3DConstraintController
<C3DConstraintController>
C3DConstraint
<C3DConstraint %@ %p>
C3DConstraintLookAt
<C3DConstraintLookAt %p>
C3DConstraintBillboard
<C3DConstraintBillboard %p>
C3DConstraintConstantScale
<C3DConstraintConstantScale>
C3DConstraintProcedural
<C3DConstraintProcedural>
C3DConstraintIK
<C3DConstraintIK %p>
C3DConstraintDistance
<C3DConstraintDistance>
maximumDistance
C3DConstraintAcceleration
maximumLinearAcceleration
maximumLinearVelocity
decelerationDistance
C3DConstraintReplicator
<C3DConstraintReplicator>
orientationOffset
positionOffset
scaleOffset
wheel
C3DConstraintManager
<C3DConstraintManagerRef>
__controller
superClass
C3DModelTarget
<C3DModelTarget>
C3DAnimationPlayer
<C3DAnimationPlayer %p>
C3DModelValueStorageItem
<C3DModelValueStorageItem %p>
C3DModelValueStorage
<C3DModelValueStorage>
IESNA:LM-63-1995
IESNA91
IESNA:LM-63-2002
TILT=NONE
TILT= NONE
TILT =NONE
TILT = NONE
TILT=
TILT =
targetDirection
replicatesOrientation
replicatesScale
replicatesPosition
collisionCategoryBitMask
bias
T@"<SCNAvoidOccluderConstraintDelegate>",N
occluderCategoryBitMask
freeAxes
preserveScale
TQ,N,V_freeAxes
v36@?0^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}8^v16^{__C3DModelTarget={__CFRuntimeBase=QAQ}^v^vscCCB^?^?}24f32
joint
T@"SCNNode",N,Vjoint
maxAllowedRotationAngle
Td,N,VmaxAllowedRotationAngle
node%d
angle%d
ikTarget
ds_default_vert_N
ds_default_frag_N
ds_default_vert
ds_default_frag
C3DAnimationEvents
<C3DAnimationEvents>
v24@?0@"<MTLRenderPipelineState>"8@"NSError"16
v32@?0@"<MTLRenderPipelineState>"8@"MTLRenderPipelineReflection"16@"NSError"24
v16@?0^v8
C3DRendererElementStore
<C3DRendererElementStore %p>
C3DIndexStore
<C3DIndexStore>
__C3DMeshElementCreateRenderablePrimitiveTypeCopy
C3DAllocator
<C3DAllocator>
TemporalAA
temporal_aa
ConvertCubeComputePass-%sTo%s
compute_cube_from_dual_views
compute_cube_from_dual
compute_equi_from_dual
compute_dual_from_cube
compute_dual_from_equi
__allocateChunk
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Engine/Allocator/C3DStackAllocator.cpp
C3DStackAllocatorAllocateAligned
allocator->_currentChunck
C3DStackAllocator
<C3DStackAllocator>
C3DAnimatableParamController
<C3DAnimatableParamController>
_timesToRepeat
_timesRepeated
_repeatedAction
_forever
DOFBlurCoCXPass
dof_coc_blurV
player
T@"AVPlayer",&,N
C3DFXMetalProgram
<C3DFXMetalProgram %p [vertex:`%@` fragment:`%@` macros:%@]>
v24@?0^{__CFString=}8r^v16
T@?,C,N,V_block
frequency
Tq,N,V_frequency
T@"NSString",C,N,V_semantic
T@"NSDictionary",&,N,V_options
SCNProgramDidChangeNotification
parameter
sourceFile
semanticInfos
draw
ignoreFloors
onlyShadowCasters
onlyMovableNodes
hasConstantAlpha
installViewport
isViewDependant
overridesCustomProgram
layerMask
includeCategoryMask
excludeCategoryMask
samples
colorStates
clearColor
sceneBackground
clear
depthStates
enableWrite
enableRead
func
stencilStates
behavior
backFaceBehavior
blendStates
C3DFXPassInput
<C3DFXPassInput %@>
symbolName
uniformName
C3DFXPass
<C3DFXPass %@>
nameToInput
draw_scene
draw_node
draw_main_scene
draw_nodes
draw_geometry
draw_quad
metal_custom
draw_none
custom
preDraw
preFX
preToneMap
postFX
front
cullNone
back
never
always
equal
notEqual
less
lessEqual
greater
greaterEqual
depthFail
fail
pass
readMask
writeMask
referenceValue
keep
zero
replace
increment
decrement
invert
incrementWrap
decrementWrap
colorSrc
colorDst
alphaSrc
alphaDst
colorOp
alphaOp
srcColor
oneMinusSrcColor
srcAlpha
oneMinusSrcAlpha
dstColor
oneMinusDstColor
dstAlpha
oneMinusDstAlpha
constantColor
oneMinusConstantColor
constantAlpha
oneMinusConstantAlpha
alphaSaturate
substract
reverseSubstract
scaleFactor
mipmapped
%fx%f
texture_rectangle
color0
color1
color2
color3
stencil
format
modelViewProjectionInverseTransform
modelViewInverseTransform
modelInverseTransform
viewInverseTransform
projectionInverseTransform
normalInverseTransform
global
persistent
OverlayPass
(1 - srcColor)
(1 - srcAlpha)
(1 - dstColor)
(1 - dstAlpha)
blendColor
(1 - blendColor)
blendAlpha
(1 - blendAlpha)
srcAlphaSat
C3DBlendStates
<C3DBlendStates %p targetCount:%d needsBlendColor:%d
  blend:%s col[(src * %@) %@ (dst * %@)] alpha[(src * %@) %@ (dst * %@)]
  blend:%s col[(src * %@) %@ (dst * %@)]
SCNShaderModifierEntryPointGeometry
SCNShaderModifierEntryPointSurface
SCNShaderModifierEntryPointFragment
SCNShaderModifierEntryPointLightingModel
v32@?0@"NSString"8@"SCNBufferBinding"16^B24
v24@?0i8^{__CFString=}12B20
owner
shaderModifiersArgumentsNames
SCNShadableDidCompileNotificationName
issues
shadable
T@"<SCNShadable>",R,N,V_shadable
entryPoint
T@"NSString",R,N,V_entryPoint
effectiveModifier
T@"NSString",R,N,V_effectiveModifier
message
T@"NSString",R,N,V_message
TQ,R,N,V_type
Tq,R,N,V_line
C3DArray
<C3DArray %p:, %d objects>
C3DSpanAllocator
<C3DSpanAllocator %p>
<%@ | string=%@ extrusionDepth=%.3f> 
-[SCNText set_wantsSeparateGeometryElements:]
-[SCNText setChamferRadius:]
-[SCNText setDiscretizedStraightLineMaxLength:]
-[SCNText setExtrusionDepth:]
-[SCNText setFlatness:]
-[SCNText setPrimitiveType:]
-[SCNText setString:]
-[SCNText setWrapped:]
.SFUI
HelveticaNeue
-[SCNText setContainerFrame:]
discretizedStraightLineMaxLength
useCustomContainerFrame
customContainerFrame
_wantsSeparateGeometryElements
T@"UIFont",&,N
T@"UIBezierPath",C,N
<%@ | path=%@ extrusionDepth=%.3f> 
-[SCNShape setChamferMode:]
-[SCNShape setChamferRadius:]
-[SCNShape setDiscretizedStraightLineMaxLength:]
-[SCNShape setExtrusionDepth:]
-[SCNShape setPrimitiveType:]
C3DShape
<C3DShape '%@'>
C3DShapeGeometryValidate
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/sources/Core3DRuntime/Core/C3DShapeGeometry.m
CFGetTypeID(geometry) == C3DShapeGeometryGetTypeID()
Helvetica
C3DShapeGeometryMeshForBoundingBox
^{__C3DMesh=}8@?0
C3DShapeGeometryGetBoundingBox
C3DShapeGeometryGetBoundingSphere
C3DShapeGeometry
C3DTextGeometry
AuthoringPass
scn_clear_z_reversed
scn_clear_z
debug_probe_vert
debug_probe_frag_cube_array
debug_probe_frag_2d_array
Authoring
levelOfDetail <%p>: geometry:%@ threshold:%f useDistance:%d
mode
mat2x3
scn_frame.invScreenPixelSize
btOptimizedBvhNodeData
btQuantizedBvhNodeData
btBvhSubtreeInfoData
btQuantizedBvhFloatData
btCollisionObjectFloatData
Overflow in AABB, object removed from simulation
If you can reproduce this, please email bugs@continuousphysics.com
Please include above information, your Platform, version of OS.
Thanks.
Triangle
btConvexInternalShapeData
Box2d
btTriangleMeshShapeData
BVHTRIANGLEMESH
CapsuleShape
btCapsuleShapeData
btCollisionShapeData
btCompoundShapeChildData
btCompoundShapeData
Compound
btVector3FloatData
btConvexHullShapeData
Convex
ConvexTrimesh
CylinderY
btCylinderShapeData
btPositionAndRadius
btMultiSphereShapeData
MultiSphere
SPHERE
STATICPLANE
btStaticPlaneShapeData
btIntIndexData
btShortIntIndexTripletData
btCharIndexTripletData
btVector3DoubleData
btMeshPartData
btStridingMeshInterfaceData
TRIANGLEMESH
btConeTwistConstraintData
btHingeConstraintFloatData
btPoint2PointConstraintFloatData
btSliderConstraintData
btTypedConstraintData
btDynamicsWorldFloatData
btRigidBodyFloatData
completeTopologyFromFaceValues
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/vtr/fvarLevel.cpp
vSpan._size != 0
getVertexEdgeValues
edgeTopologyMatches(eIndex)
getFaceValueTags
_vertValueIndices[srcValueIndex] == faceValues[i]
getFaceCompositeValueTag
bilinear
catmark
loop
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/stencilBuilder.cpp
_sources[i] < _coarseVertCount
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/patchTableFactory.cpp
IsPatchEligible
fVerts.size() == 4
GetRegularPatchBoundaryMask
eBoundaryMask != -1
computePatchParam
ptexIndex!=-1
createUniform
refiner.IsUniform()
ptype!=PatchDescriptor::NON_PATCH
npatches>=0
(levelVertOffset + fvalues[vert]) < (int)table->getFVarValues(fvc).size()
createAdaptive
! refiner.IsUniform()
populateAdaptivePatches
"Unknown Descriptor for FVar patch" == 0
identifyNonManifoldCornerSpan
vSpan._numFaces == 1
getPatchIndex
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/patchTable.cpp
patchIndex<pa.numPatches
getPatchArrayVertices
pa.vertIndex<(Index)_patchVerts.size()
GetPatchArrayVertices
GetPatchVertices
(pa.vertIndex + patchIndex*size)<(Index)_patchVerts.size()
getFVarPatchChannel
channel>=0 && channel<(int)_fvarChannels.size()
getPatchArray
arrayIndex<(Index)GetNumPatchArrays()
Failure in TopologyRefinerFactory<>::Create() -- mesh contains no vertices.
Failure in TopologyRefinerFactory<>::Create() -- meshes without faces not yet supported.
Failure in TopologyRefinerFactory<>::Create() -- face with %d vertices > %d max.
Failure in TopologyRefinerFactory<>::Create() -- mesh contains no face-vertices.
Failure in TopologyRefinerFactory<>::Create() -- non-triangular faces not supported by Loop scheme.
prepareComponentTopologySizing
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/topologyRefinerFactory.cpp
baseLevel.getNumFaceEdgesTotal() > 0
baseLevel.getNumEdgeVerticesTotal() > 0
baseLevel.getNumEdgeFacesTotal() > 0
baseLevel.getNumVertexFacesTotal() > 0
baseLevel.getNumVertexEdgesTotal() > 0
Failure in TopologyRefinerFactory<>::Create() -- vertex with valence %d > %d max.
Failure in TopologyRefinerFactory<>::Create() -- maximum valence not assigned.
Failure in TopologyRefinerFactory<>::Create() -- invalid topology detected from partial specification.
Failure in TopologyRefinerFactory<>::Create() -- invalid topology detected as fully specified.
prepareComponentTagsAndSharpness
(schemeRegularInteriorValence == 4) || (schemeRegularInteriorValence == 6)
Failure in TopologyRefinerFactory<>::Create() -- face-varying channel %d has no values.
GetFaceId
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/ptexIndices.cpp
f<(int)_ptexIndices.size()
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/osd/mtlPatchTable.mm
0 && "MTLPatchTable Creation Failed"
OSD PatchIndexBuffer
OSD PatchParamBuffer
MISSING_EDGE_FACES
MISSING_EDGE_VERTS
MISSING_FACE_EDGES
MISSING_FACE_VERTS
MISSING_VERT_FACES
MISSING_VERT_EDGES
FAILED_CORRELATION_FACE_VERT
FAILED_CORRELATION_FACE_EDGE
FAILED_ORIENTATION_INCIDENT_EDGE
FAILED_ORIENTATION_INCIDENT_FACE
FAILED_ORIENTATION_INCIDENT_FACES_EDGES
DEGENERATE_EDGE
NON_MANIFOLD_EDGE
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/vtr/level.cpp
%s - missing face-verts
%s - missing vert-faces
%s - face %d correlation of vert %d failed
%s - missing edge-faces
%s - missing face-edges
%s - face %d correlation of edge %d failed
%s - missing edge-verts
%s - missing vert-edges
%s - edge %d correlation of vert %d failed
%s - vertex %d cannot orient incident faces and edges
%s - vertex %d orientation failure at incident face %d
%s - vertex %d orientation failure at incident edge %d
%s - Error in eIndex = %d:  degenerate edge not tagged marked non-manifold
%s - edge %d with %d incident faces not tagged non-manifold
gatherQuadRegularPartialRingAroundVertex
! level.isVertexNonManifold(vIndex)
(0 <= rotation) && (rotation < 4)
gatherQuadRegularInteriorPatchPoints
gatherQuadRegularBoundaryPatchPoints
(boundaryFaceInV0Faces >= 0) && (boundaryFaceInV1Faces >= 0)
gatherQuadRegularCornerPatchPoints
cornerFaceInIntVertFaces >= 0
completeTopologyFromFaceVertices
(vCount > 0) && (fCount > 0) && (eCount == 0)
_maxValence > 0
orderVertexFacesAndEdges
eCountOrdered == eCount
fCountOrdered == fCount
FindIndexIn4Tuple
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/vtr/../vtr/array.h
_size>=4
"FindIndexIn4Tuple() did not find expected value!" == 0
MTLStencilTable
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/osd/mtlComputeEvaluator.mm
context != nil
context->device != nil && context->commandQueue != nil
StencilTable Sizes
StencilTable Offsets
StencilTable Indices
StencilTable Weights
Compile
Using OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
LENGTH
SRC_STRIDE
DST_STRIDE
WORK_GROUP_SIZE
OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
PARAMETER_BUFFER_INDEX
SIZES_BUFFER_INDEX
OFFSETS_BUFFER_INDEX
WEIGHTS_BUFFER_INDEX
SRC_VERTEX_BUFFER_INDEX
DST_VERTEX_BUFFER_INDEX
DU_WEIGHTS_BUFFER_INDEX
DV_WEIGHTS_BUFFER_INDEX
DU_DERIVATIVE_BUFFER_INDEX
DV_DERIVATIVE_BUFFER_INDEX
PATCH_ARRAYS_BUFFER_INDEX
PATCH_COORDS_BUFFER_INDEX
PATCH_PARAMS_BUFFER_INDEX
Error compiling MTL Shader: %s
eval_stencils
Error compiling MTL Pipeline eval_stencils: %s
eval_patches
Error compiling MTL Pipeline eval_patches:  %s
EvalStencils
context != nullptr
device != nil && commandQueue != nil
#line 0 "osd/mtlComputeKernel.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
#include <metal_stdlib>
#ifndef OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
#define OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES 0
#endif
using namespace metal;
struct PatchCoord
    int arrayIndex;
    int patchIndex;
    int vertIndex;
    float s;
    float t;
struct PatchParam
    uint field0;
    uint field1;
    float sharpness;
struct KernelUniformArgs
int batchStart;
int batchEnd;
    int srcOffset;
int dstOffset;
    int3 duDesc;
    int3 dvDesc;
struct Vertex {
    float vertexData[LENGTH];
void clear(thread Vertex& v) {
    for (int i = 0; i < LENGTH; ++i) {
        v.vertexData[i] = 0;
    }
Vertex readVertex(int index, device float* vertexBuffer, KernelUniformArgs args) {
    Vertex v;
    int vertexIndex = args.srcOffset + index * SRC_STRIDE;
    for (int i = 0; i < LENGTH; ++i) {
        v.vertexData[i] = vertexBuffer[vertexIndex + i];
    }
    return v;
void writeVertex(int index, Vertex v, device float* vertexBuffer, KernelUniformArgs args) {
    int vertexIndex = args.dstOffset + index * DST_STRIDE;
    for (int i = 0; i < LENGTH; ++i) {
        vertexBuffer[vertexIndex + i] = v.vertexData[i];
    }
void writeVertexSeparate(int index, Vertex v, device float* dstVertexBuffer, KernelUniformArgs args) {
    int vertexIndex = args.dstOffset + index * DST_STRIDE;
    for (int i = 0; i < LENGTH; ++i) {
        dstVertexBuffer[vertexIndex + i] = v.vertexData[i];
    }
void addWithWeight(thread Vertex& v, const Vertex src, float weight) {
    for (int i = 0; i < LENGTH; ++i) {
        v.vertexData[i] += weight * src.vertexData[i];
    }
void writeDu(int index, Vertex du, device float* duDerivativeBuffer, KernelUniformArgs args)
    int duIndex = args.duDesc.x + index * args.duDesc.z;
    for(int i = 0; i < LENGTH; i++)
    {
        duDerivativeBuffer[duIndex + i] = du.vertexData[i];
    }
void writeDv(int index, Vertex dv, device float* dvDerivativeBuffer, KernelUniformArgs args)
    int dvIndex = args.dvDesc.x + index * args.dvDesc.z;
    for(int i = 0; i < LENGTH; i++)
    {
        dvDerivativeBuffer[dvIndex + i] = dv.vertexData[i];
    }
// ---------------------------------------------------------------------------
kernel void eval_stencils(
    uint thread_position_in_grid [[thread_position_in_grid]],
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    const device uint8_t* sizes [[buffer(SIZES_BUFFER_INDEX)]],
    const device int* offsets [[buffer(OFFSETS_BUFFER_INDEX)]],
    const device uint16_t* indices [[buffer(INDICES_BUFFER_INDEX)]],
    const device half* weights [[buffer(WEIGHTS_BUFFER_INDEX)]],
#else
    const device int* sizes [[buffer(SIZES_BUFFER_INDEX)]],
    const device int* offsets [[buffer(OFFSETS_BUFFER_INDEX)]],
    const device int* indices [[buffer(INDICES_BUFFER_INDEX)]],
    const device float* weights [[buffer(WEIGHTS_BUFFER_INDEX)]],
#endif
    device float* srcVertices [[buffer(SRC_VERTEX_BUFFER_INDEX)]],
    device float* dstVertexBuffer [[buffer(DST_VERTEX_BUFFER_INDEX)]],
    const device float* duWeights [[buffer(DU_WEIGHTS_BUFFER_INDEX)]],
    const device float* dvWeights [[buffer(DV_WEIGHTS_BUFFER_INDEX)]],
    device float* duDerivativeBuffer [[buffer(DU_DERIVATIVE_BUFFER_INDEX)]],
    device float* dvDerivativeBuffer [[buffer(DV_DERIVATIVE_BUFFER_INDEX)]],
    const constant KernelUniformArgs& args [[buffer(PARAMETER_BUFFER_INDEX)]]
    auto current  = thread_position_in_grid + args.batchStart;
    if(current >= args.batchEnd)
        return;
    Vertex dst;
    clear(dst);
    auto offset = offsets[current];
    auto size = sizes[current];
    for(auto stencil = 0; stencil < size; stencil++)
    {
        auto vindex = offset + stencil;
        addWithWeight(dst, readVertex(indices[vindex], srcVertices, args), weights[vindex]);
    }
    writeVertex(current, dst, dstVertexBuffer, args);
#if OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
    Vertex du, dv;
    clear(du);
    clear(dv);
    for(auto i = 0; i < size; i++)
    {
        auto src = readVertex(indices[offset + i], srcVertices, args);
        addWithWeight(du, src, duWeights[offset + i]);
        addWithWeight(dv, src, dvWeights[offset + i]);
    }
    writeDu(current, du, duDerivativeBuffer, args);
    writeDv(current, dv, dvDerivativeBuffer, args);
#endif
// ---------------------------------------------------------------------------
// PERFORMANCE: stride could be constant, but not as significant as length
//struct PatchArray {
//    int patchType;
//    int numPatches;
//    int indexBase;        // an offset within the index buffer
//    int primitiveIdBase;  // an offset within the patch param buffer
//};
// # of patcharrays is 1 or 2.
uint getDepth(uint patchBits) {
    return (patchBits & 0xf);
float getParamFraction(uint patchBits) {
    uint nonQuadRoot = (patchBits >> 4) & 0x1;
    uint depth = getDepth(patchBits);
    if (nonQuadRoot == 1) {
        return 1.0f / float( 1 << (depth-1) );
    } else {
        return 1.0f / float( 1 << depth );
    }
float2 normalizePatchCoord(uint patchBits, float2 uv) {
    float frac = getParamFraction(patchBits);
    uint iu = (patchBits >> 22) & 0x3ff;
    uint iv = (patchBits >> 12) & 0x3ff;
    // top left corner
    float pu = float(iu*frac);
    float pv = float(iv*frac);
    // normalize u,v coordinates
    return float2((uv.x - pu) / frac, (uv.y - pv) / frac);
bool isRegular(uint patchBits) {
    return (((patchBits >> 5) & 0x1u) != 0);
int getNumControlVertices(int patchType) {
    switch(patchType) {
        case 3: return 4;
        case 6: return 16;
        case 9: return 20;
        default: return 0;
    }
// ---------------------------------------------------------------------------
kernel void eval_patches(
                         uint thread_position_in_grid [[thread_position_in_grid]],
                         const constant uint4* patchArrays [[buffer(PATCH_ARRAYS_BUFFER_INDEX)]],
                         device PatchCoord* patchCoords [[buffer(PATCH_COORDS_BUFFER_INDEX)]],
                         device int* patchIndices [[buffer(PATCH_INDICES_BUFFER_INDEX)]],
                         device PatchParam* patchParams [[buffer(PATCH_PARAMS_BUFFER_INDEX)]],
                         device float* srcVertexBuffer [[buffer(SRC_VERTEX_BUFFER_INDEX)]],
                         device float* dstVertexBuffer [[buffer(DST_VERTEX_BUFFER_INDEX)]],
                         device float* duDerivativeBuffer [[buffer(DU_DERIVATIVE_BUFFER_INDEX)]],
                         device float* dvDerivativeBuffer [[buffer(DV_DERIVATIVE_BUFFER_INDEX)]],
                         const constant KernelUniformArgs& args [[buffer(PARAMETER_BUFFER_INDEX)]]
                         )
    auto current = thread_position_in_grid;
    auto patchCoord = patchCoords[current];
    auto patchIndex = patchIndices[patchCoord.patchIndex];
    auto patchArray = patchArrays[patchCoord.arrayIndex];
    auto patchBits = patchParams[patchIndex].field1; 
    auto patchType = select(patchArray.x, uint(6), isRegular(patchBits));
    auto numControlVertices = getNumControlVertices(patchType);
    auto uv = normalizePatchCoord(patchBits, float2(patchCoord.s, patchCoord.t));
    auto dScale = float(1 << getDepth(patchBits));
    auto boundaryMask = int((patchBits >> 8) & 0xFU);
    float wP[20], wDs[20], wDt[20], wDss[20], wDst[20], wDtt[20];
    if(patchType == 3) {
        OsdGetBilinearPatchWeights(uv.x, uv.y, dScale, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if(patchType == 6) {
        OsdGetBSplinePatchWeights(uv.x, uv.y, dScale, boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if(patchType == 9) {
        OsdGetGregoryPatchWeights(uv.x, uv.y, dScale, wP, wDs, wDt, wDss, wDst, wDtt);
    }
    Vertex dst, du, dv;
    clear(dst);
    clear(du);
    clear(dv);
    auto indexBase = patchArray.z + numControlVertices * (patchCoord.patchIndex - patchArray.w);
    for(auto cv = 0; cv < numControlVertices; cv++)
    {
        auto index = patchIndices[indexBase + cv];
        auto src = readVertex(index, srcVertexBuffer, args);
        addWithWeight(dst, src, wP[cv]);
        addWithWeight(du, src, wDs[cv]);
        addWithWeight(dv, src, wDt[cv]);
    }
    writeVertex(current, dst, dstVertexBuffer, args);
#if OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
    if(args.duDesc.y > 0)
        writeDu(current, du, duDerivativeBuffer, args);
    if(args.dvDesc.y > 0)
        writeDv(current, dv, dvDerivativeBuffer, args);
#endif
appendLocalPointStencilTable
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/stencilTableFactory.cpp
Create
GetStencil
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/../far/stencilTable.h
(! _offsets.empty()) && i<(int)_offsets.size()
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/../far/primvarRefiner.h
ProtoBasis
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/gregoryBasis.cpp
cornerPatchFace[corner] != -1
computeCoefficient
valence > 0
Refinement
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/vtr/refinement.cpp
(childArg.getDepth() == 0) && (childArg.getNumVertices() == 0)
refine
_parent && _child
populateParentToChildMapping
"Unsupported empty sparse refinement detected in Refinement" == 0
subdivideFVarChannels
_child->_fvarChannels.size() == 0
this->_fvarChannels.size() == 0
markSparseVertexChildren
_parentVertexTag.size() > 0
markSparseEdgeChildren
_parentEdgeTag.size() > 0
No Error
Fatal Error
Coding Error (internal)
Coding Error
Error
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/error.cpp
err!=FAR_NO_ERROR
%s: %s
Warning: %s
estimateAndAllocateChildValues
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/vtr/fvarRefinement.cpp
_refinement.isChildVertexComplete(cVert)
propagateValueTags
propagateValueCreases
_childFVar.hasSmoothBoundaries()
populateChildValuesForEdgeVertex
cVertFaces.size() == cVertFaceSiblings.size()
cVertFaces.size() >= cValueCount
populateChildValuesForVertexVertex
populateFaceVerticesFromParentFaces
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/vtr/triRefinement.cpp
pFaceVerts.size() == 3
pFaceChildren.size() == 4
populateFaceEdgesFromParentFaces
pFaceChildFaces.size() == 4
pFaceChildEdges.size() == 3
populateEdgeVerticesFromParentFaces
pFaceEdges.size() == 3
populateEdgeFacesFromParentFaces
populateVertexFacesFromParentEdges
markSparseFaceChildren
_parentFaceTag.size() > 0
fChildFaces.size() == 4
fChildEdges.size() == 3
#define OSD_METAL_IOS 1
#define OSD_PATCH_BASIS_METAL 1
#line 0 "osd/mtlPatchCommon.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.Common
//----------------------------------------------------------
#include <metal_stdlib>
#define offsetof_(X, Y) &(((device X*)nullptr)->Y)
#define OSD_IS_ADAPTIVE (OSD_PATCH_REGULAR || OSD_PATCH_GREGORY_BASIS || OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY)
#ifndef OSD_MAX_TESS_LEVEL
#define OSD_MAX_TESS_LEVEL 64
#endif
#ifndef OSD_NUM_ELEMENTS
#define OSD_NUM_ELEMENTS 3
#endif
#ifndef OSD_USER_VARYING_DECLARE
#define OSD_USER_VARYING_DECLARE
#endif
#ifndef OSD_USER_VARYING_DECLARE_ATTRIBUTE
#define OSD_USER_VARYING_DECLARE_ATTRIBUTE
#endif
#ifndef OSD_USER_VARYING_PER_VERTEX
#define OSD_USER_VARYING_PER_VERTEX(in, out)
#endif
#ifndef OSD_USER_VARYING_PER_CONTROL_POINT
#define OSD_USER_VARYING_PER_CONTROL_POINT(in, out)
#endif
#ifndef OSD_USER_VARYING_PER_EVAL_POINT
#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d, out)
#endif
static_assert(sizeof(OsdInputVertexType) > 0, "OsdInputVertexType must be defined and have a float3 position member");
#if OSD_IS_ADAPTIVE
#if OSD_PATCH_GREGORY_BASIS
constant constexpr unsigned IndexLookupStride = 5;
#else 
constant constexpr unsigned IndexLookupStride = 1;
#endif
#define PATCHES_PER_THREADGROUP ((THREADS_PER_THREADGROUP * CONTROL_POINTS_PER_THREAD) / CONTROL_POINTS_PER_PATCH)
#define REAL_THREADGROUP_DIVISOR (CONTROL_POINTS_PER_PATCH / CONTROL_POINTS_PER_THREAD)
static_assert(REAL_THREADGROUP_DIVISOR % 2 == 0, "REAL_THREADGROUP_DIVISOR must be a power of 2");
static_assert(!OSD_ENABLE_SCREENSPACE_TESSELLATION || !USE_PTVS_FACTORS, "USE_PTVS_FACTORS cannot be enabled if OSD_ENABLE_SCREENSPACE_TESSELLATION is enabled");
static_assert((OSD_ENABLE_SCREENSPACE_TESSELLATION && (OSD_FRACTIONAL_ODD_SPACING || OSD_FRACTIONAL_EVEN_SPACING)) || !OSD_ENABLE_SCREENSPACE_TESSELLATION, "OSD_ENABLE_SCREENSPACE_TESSELLATION requires OSD_FRACTIONAL_ODD_SPACING or OSD_FRACTIONAL_EVEN_SPACING");
#endif
//Adjustments to the UV reparameterization can be defined here. 
#ifndef OSD_UV_CORRECTION
#define OSD_UV_CORRECTION
#endif
using namespace metal;
// ----------------------------------------------------------------------------
// Patch Parameters
// ----------------------------------------------------------------------------
// Each patch has a corresponding patchParam. This is a set of three values
// specifying additional information about the patch:
//    faceId    -- topological face identifier (e.g. Ptex FaceId)
//    bitfield  -- refinement-level, non-quad, boundary, transition, uv-offset
//    sharpness -- crease sharpness for single-crease patches
// These are stored in OsdPatchParamBuffer indexed by the value returned
// from OsdGetPatchIndex() which is a function of the current PrimitiveID
// along with an optional client provided offset.
using OsdPatchParamBufferType = packed_int3;
struct OsdPerVertexGregory {
    float3 P;
    short3 clipFlag;
    int valence;
    float3 e0;
    float3 e1;
#if OSD_PATCH_GREGORY_BOUNDARY
    int zerothNeighbor;
    float3 org;
#endif
    float3 r[OSD_MAX_VALENCE];
    OSD_USER_VARYING_DECLARE
struct OsdPerPatchVertexGregory {
    packed_float3 P;
    packed_float3 Ep;
    packed_float3 Em;
    packed_float3 Fp;
    packed_float3 Fm;
    OSD_USER_VARYING_DECLARE
//----------------------------------------------------------
// HLSL->Metal Compatibility
//----------------------------------------------------------
static inline float4 mul(float4x4 a, float4 b)
    return a * b;
static inline float3 mul(float4x4 a, float3 b)
    float3x3 m(a[0].xyz, a[1].xyz, a[2].xyz);
    return m * b;
//----------------------------------------------------------
// Patches.Common
//----------------------------------------------------------
// For now, fractional spacing is supported only with screen space tessellation
#ifndef OSD_ENABLE_SCREENSPACE_TESSELLATION
#undef OSD_FRACTIONAL_EVEN_SPACING
#undef OSD_FRACTIONAL_ODD_SPACING
#endif
struct HullVertex {
    float4 position;
#if OSD_ENABLE_PATCH_CULL
    short3 clipFlag;
#endif
    OSD_USER_VARYING_DECLARE
    float3 GetPosition() threadgroup
    {
        return position.xyz;
    }
    void SetPosition(float3 v) threadgroup
    {
    
position.xyz = v;
    }
// XXXdyu all downstream data can be handled by client code
struct OsdPatchVertex {
    float3 position;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 patchCoord; //u, v, faceLevel, faceId
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    float3 Nu;
    float3 Nv;
#endif
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    float2 vSegments;
#endif
    OSD_USER_VARYING_DECLARE
struct OsdPerPatchTessFactors {
    float4 tessOuterLo;
    float4 tessOuterHi;
struct OsdPerPatchVertexBezier {
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    packed_half3 P;
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    packed_half3 P1;
    packed_half3 P2;
#if !USE_PTVS_SHARPNESS
    half2 vSegments;
#endif
#endif
#else
    packed_float3 P;
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    packed_float3 P1;
    packed_float3 P2;
#if !USE_PTVS_SHARPNESS
    float2 vSegments;
#endif
#endif
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    OSD_USER_VARYING_DECLARE
struct OsdPerPatchVertexGregoryBasis {
    packed_float3 P;
    OSD_USER_VARYING_DECLARE
#if OSD_PATCH_REGULAR
using PatchVertexType = HullVertex;
using PerPatchVertexType = OsdPerPatchVertexBezier;
#elif OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
using PatchVertexType = OsdPerVertexGregory;
using PerPatchVertexType = OsdPerPatchVertexGregory;
#elif OSD_PATCH_GREGORY_BASIS
using PatchVertexType = HullVertex;
using PerPatchVertexType = OsdPerPatchVertexGregoryBasis;
#else
using PatchVertexType = OsdInputVertexType;
using PerPatchVertexType = OsdInputVertexType;
#endif
//Shared buffers used by OSD that are common to all kernels
struct OsdPatchParamBufferSet
const device OsdInputVertexType* vertexBuffer [[buffer(VERTEX_BUFFER_INDEX)]];
const device unsigned* indexBuffer [[buffer(CONTROL_INDICES_BUFFER_INDEX)]];
const device OsdPatchParamBufferType* patchParamBuffer [[buffer(OSD_PATCHPARAM_BUFFER_INDEX)]];
device PerPatchVertexType* perPatchVertexBuffer [[buffer(OSD_PERPATCHVERTEXBEZIER_BUFFER_INDEX)]];
#if !USE_PTVS_FACTORS    
    device OsdPerPatchTessFactors* patchTessBuffer [[buffer(OSD_PERPATCHTESSFACTORS_BUFFER_INDEX)]];
#endif
#if OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
const device int* quadOffsetBuffer [[buffer(OSD_QUADOFFSET_BUFFER_INDEX)]];
const device int* valenceBuffer [[buffer(OSD_VALENCE_BUFFER_INDEX)]];
#endif
const constant unsigned& kernelExecutionLimit [[buffer(OSD_KERNELLIMIT_BUFFER_INDEX)]];
//Shared buffers used by OSD that are common to all PTVS implementations
struct OsdVertexBufferSet
const device OsdInputVertexType* vertexBuffer [[buffer(VERTEX_BUFFER_INDEX)]];
const device unsigned* indexBuffer [[buffer(CONTROL_INDICES_BUFFER_INDEX)]];
const device OsdPatchParamBufferType* patchParamBuffer [[buffer(OSD_PATCHPARAM_BUFFER_INDEX)]];
device PerPatchVertexType* perPatchVertexBuffer [[buffer(OSD_PERPATCHVERTEXBEZIER_BUFFER_INDEX)]];
#if !USE_PTVS_FACTORS    
    device OsdPerPatchTessFactors* patchTessBuffer [[buffer(OSD_PERPATCHTESSFACTORS_BUFFER_INDEX)]];
#endif
// ----------------------------------------------------------------------------
// Patch Parameters Accessors
// ----------------------------------------------------------------------------
static int3 OsdGetPatchParam(int patchIndex, const device OsdPatchParamBufferType* osdPatchParamBuffer)
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    return int3(osdPatchParamBuffer[patchIndex]);
#else
    auto p = osdPatchParamBuffer[patchIndex];
    return int3(p[0], p[1], 0);
#endif
static int OsdGetPatchIndex(int primitiveId)
    return primitiveId;
static int OsdGetPatchFaceId(int3 patchParam)
    return (patchParam.x & 0xfffffff);
static int OsdGetPatchFaceLevel(int3 patchParam)
    return (1 << ((patchParam.y & 0xf) - ((patchParam.y >> 4) & 1)));
static int OsdGetPatchRefinementLevel(int3 patchParam)
    return (patchParam.y & 0xf);
static int OsdGetPatchBoundaryMask(int3 patchParam)
    return ((patchParam.y >> 8) & 0xf);
static int OsdGetPatchTransitionMask(int3 patchParam)
    return ((patchParam.x >> 28) & 0xf);
static int2 OsdGetPatchFaceUV(int3 patchParam)
    int u = (patchParam.y >> 22) & 0x3ff;
    int v = (patchParam.y >> 12) & 0x3ff;
    return int2(u,v);
static bool OsdGetPatchIsRegular(int3 patchParam)
    return ((patchParam.y >> 5) & 0x1) != 0;
static float OsdGetPatchSharpness(int3 patchParam)
    return as_type<float>(patchParam.z);
static float OsdGetPatchSingleCreaseSegmentParameter(int3 patchParam, float2 uv)
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    float s = 0;
    if ((boundaryMask & 1) != 0) {
        s = 1 - uv.y;
    } else if ((boundaryMask & 2) != 0) {
        s = uv.x;
    } else if ((boundaryMask & 4) != 0) {
        s = uv.y;
    } else if ((boundaryMask & 8) != 0) {
        s = 1 - uv.x;
    }
    return s;
// ----------------------------------------------------------------------------
static void OsdUnivar4x4(float u, thread float* B)
    float t = u;
    float s = 1.0f - u;
    
    float A0 = s * s;
    float A1 = 2 * s * t;
    float A2 = t * t;
    
    B[0] = s * A0;
    B[1] = t * A0 + s * A1;
    B[2] = t * A1 + s * A2;
    B[3] = t * A2;
static void OsdUnivar4x4(float u, thread float* B, thread float* D)
    float t = u;
    float s = 1.0f - u;
    float A0 = s * s;
    float A1 = 2 * s * t;
    float A2 = t * t;
    B[0] = s * A0;
    B[1] = t * A0 + s * A1;
    B[2] = t * A1 + s * A2;
    B[3] = t * A2;
    D[0] =    - A0;
    D[1] = A0 - A1;
    D[2] = A1 - A2;
    D[3] = A2;
static void OsdUnivar4x4(float u, thread float* B, thread float* D, thread float* C)
    float t = u;
    float s = 1.0f - u;
    float A0 = s * s;
    float A1 = 2 * s * t;
    float A2 = t * t;
    B[0] = s * A0;
    B[1] = t * A0 + s * A1;
    B[2] = t * A1 + s * A2;
    B[3] = t * A2;
    D[0] =    - A0;
    D[1] = A0 - A1;
    D[2] = A1 - A2;
    D[3] = A2;
    A0 =   - s;
    A1 = s - t;
    A2 = t;
    C[0] =    - A0;
    C[1] = A0 - A1;
    C[2] = A1 - A2;
    C[3] = A2;
// ----------------------------------------------------------------------------
static float3 OsdEvalBezier(float3 cp[16], float2 uv)
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    float B[4], D[4];
    OsdUnivar4x4(uv.x, B, D);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = cp[4*i + j];
            BUCP[i] += A * B[j];
        }
    }
    float3 P = float3(0,0,0);
    OsdUnivar4x4(uv.y, B, D);
    for (int k=0; k<4; ++k) {
        P += B[k] * BUCP[k];
    }
    return P;
static bool OsdCullPerPatchVertex(
threadgroup PatchVertexType* patch, 
float4x4 ModelViewMatrix
#if OSD_ENABLE_BACKPATCH_CULL && OSD_PATCH_REGULAR
    auto v0 = float3(ModelViewMatrix * patch[5].position);
    auto v3 = float3(ModelViewMatrix * patch[6].position);
    auto v12 = float3(ModelViewMatrix * patch[9].position);
    auto n = normalize(cross(v3 - v0, v12 - v0));
    v0 = normalize(v0 + v3 + v12);
    if(dot(v0, n) > 0.6f)
    {
        return false;
    }
#endif
#if OSD_ENABLE_PATCH_CULL
    short3 clipFlag = short3(0,0,0);
    for(int i = 0; i < CONTROL_POINTS_PER_PATCH; ++i) {
        clipFlag |= patch[i].clipFlag;
    }
    if (any(clipFlag != short3(3,3,3))) {
        return false;
    }
#endif
    return true;
// When OSD_PATCH_ENABLE_SINGLE_CREASE is defined,
// this function evaluates single-crease patch, which is segmented into
// 3 parts in the v-direction.
//  v=0             vSegment.x        vSegment.y              v=1
//   +------------------+-------------------+------------------+
//   |       cp 0       |     cp 1          |      cp 2        |
//   | (infinite sharp) | (floor sharpness) | (ceil sharpness) |
//   +------------------+-------------------+------------------+
static float3 OsdEvalBezier(device OsdPerPatchVertexBezier* cp, int3 patchParam, float2 uv)
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    float B[4], D[4];
    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, uv);
    OsdUnivar4x4(uv.x, B, D);
#if OSD_PATCH_ENABLE_SINGLE_CREASE
#if USE_PTVS_SHARPNESS
    float sharpness = OsdGetPatchSharpness(patchParam);
    float Sf = floor(sharpness);
    float Sc = ceil(sharpness);
    float s0 = 1 - exp2(-Sf);
    float s1 = 1 - exp2(-Sc);
    float2 vSegments(s0, s1);
#else
    float2 vSegments = float2(cp[0].vSegments);
#endif // USE_PTVS_SHARPNESS
    //By doing the offset calculation ahead of time it can be kept out of the actual indexing lookup.
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    if(s <= vSegments.x)
        cp = (device OsdPerPatchVertexBezier*)(((device half*)cp) + 0);
    else if( s <= vSegments.y)
        cp = (device OsdPerPatchVertexBezier*)(((device half*)cp) + 3);
    else
        cp = (device OsdPerPatchVertexBezier*)(((device half*)cp) + 6);
#else
    if(s <= vSegments.x)
        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 0);
    else if( s <= vSegments.y)
        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 3);
    else
        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 6);
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    BUCP[0] += float3(cp[0].P) * B[0];
    BUCP[0] += float3(cp[1].P) * B[1];
    BUCP[0] += float3(cp[2].P) * B[2];
    BUCP[0] += float3(cp[3].P) * B[3];
    BUCP[1] += float3(cp[4].P) * B[0];
    BUCP[1] += float3(cp[5].P) * B[1];
    BUCP[1] += float3(cp[6].P) * B[2];
    BUCP[1] += float3(cp[7].P) * B[3];
    BUCP[2] += float3(cp[8].P) * B[0];
    BUCP[2] += float3(cp[9].P) * B[1];
    BUCP[2] += float3(cp[10].P) * B[2];
    BUCP[2] += float3(cp[11].P) * B[3];
    BUCP[3] += float3(cp[12].P) * B[0];
    BUCP[3] += float3(cp[13].P) * B[1];
    BUCP[3] += float3(cp[14].P) * B[2];
    BUCP[3] += float3(cp[15].P) * B[3];
#else // single crease
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = float3(cp[4*i + j].P);
            BUCP[i] += A * B[j];
        }
    }
#endif  // single crease
    OsdUnivar4x4(uv.y, B);
    float3 P = B[0] * BUCP[0];
    for (int k=1; k<4; ++k) {
        P += B[k] * BUCP[k];
    }
    return P;
// ----------------------------------------------------------------------------
// Boundary Interpolation
// ----------------------------------------------------------------------------
template<typename VertexType>
static void OsdComputeBSplineBoundaryPoints(threadgroup VertexType* cpt, int3 patchParam)
//APPL TODO - multithread this
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    if ((boundaryMask & 1) != 0) {
        cpt[0].SetPosition(2*cpt[4].GetPosition() - cpt[8].GetPosition());
        cpt[1].SetPosition(2*cpt[5].GetPosition() - cpt[9].GetPosition());
        cpt[2].SetPosition(2*cpt[6].GetPosition() - cpt[10].GetPosition());
        cpt[3].SetPosition(2*cpt[7].GetPosition() - cpt[11].GetPosition());
    }
    if ((boundaryMask & 2) != 0) {
        cpt[3].SetPosition(2*cpt[2].GetPosition() - cpt[1].GetPosition());
        cpt[7].SetPosition(2*cpt[6].GetPosition() - cpt[5].GetPosition());
        cpt[11].SetPosition(2*cpt[10].GetPosition() - cpt[9].GetPosition());
        cpt[15].SetPosition(2*cpt[14].GetPosition() - cpt[13].GetPosition());
    }
    if ((boundaryMask & 4) != 0) {
        cpt[12].SetPosition(2*cpt[8].GetPosition() - cpt[4].GetPosition());
        cpt[13].SetPosition(2*cpt[9].GetPosition() - cpt[5].GetPosition());
        cpt[14].SetPosition(2*cpt[10].GetPosition() - cpt[6].GetPosition());
        cpt[15].SetPosition(2*cpt[11].GetPosition() - cpt[7].GetPosition());
    }
    if ((boundaryMask & 8) != 0) {
        cpt[0].SetPosition(2*cpt[1].GetPosition() - cpt[2].GetPosition());
        cpt[4].SetPosition(2*cpt[5].GetPosition() - cpt[6].GetPosition());
        cpt[8].SetPosition(2*cpt[9].GetPosition() - cpt[10].GetPosition());
        cpt[12].SetPosition(2*cpt[13].GetPosition() - cpt[14].GetPosition());
    }
template<typename VertexType>
static void OsdComputeBSplineBoundaryPoints(thread VertexType* cpt, int3 patchParam)
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    if ((boundaryMask & 1) != 0) {
        cpt[0].SetPosition(2*cpt[4].GetPosition() - cpt[8].GetPosition());
        cpt[1].SetPosition(2*cpt[5].GetPosition() - cpt[9].GetPosition());
        cpt[2].SetPosition(2*cpt[6].GetPosition() - cpt[10].GetPosition());
        cpt[3].SetPosition(2*cpt[7].GetPosition() - cpt[11].GetPosition());
    }
    if ((boundaryMask & 2) != 0) {
        cpt[3].SetPosition(2*cpt[2].GetPosition() - cpt[1].GetPosition());
        cpt[7].SetPosition(2*cpt[6].GetPosition() - cpt[5].GetPosition());
        cpt[11].SetPosition(2*cpt[10].GetPosition() - cpt[9].GetPosition());
        cpt[15].SetPosition(2*cpt[14].GetPosition() - cpt[13].GetPosition());
    }
    if ((boundaryMask & 4) != 0) {
        cpt[12].SetPosition(2*cpt[8].GetPosition() - cpt[4].GetPosition());
        cpt[13].SetPosition(2*cpt[9].GetPosition() - cpt[5].GetPosition());
        cpt[14].SetPosition(2*cpt[10].GetPosition() - cpt[6].GetPosition());
        cpt[15].SetPosition(2*cpt[11].GetPosition() - cpt[7].GetPosition());
    }
    if ((boundaryMask & 8) != 0) {
      cpt[0].SetPosition(2*cpt[1].GetPosition() - cpt[2].GetPosition());
      cpt[4].SetPosition(2*cpt[5].GetPosition() - cpt[6].GetPosition());
      cpt[8].SetPosition(2*cpt[9].GetPosition() - cpt[10].GetPosition());
      cpt[12].SetPosition(2*cpt[13].GetPosition() - cpt[14].GetPosition());
    }
static void OsdEvalPatchGregory(int3 patchParam, float2 UV, thread float3* cv,
                    thread float3& P, thread float3& dPu, thread float3& dPv,
                    thread float3& N, thread float3& dNu, thread float3& dNv)
    float u = UV.x, v = UV.y;
    float U = 1-u, V = 1-v;
    //(0,1)                              (1,1)
    //   P3         e3-      e2+         P2
    //      15------17-------11-------10
    //      |        |        |        |
    //      |        |        |        |
    //      |        | f3-    | f2+    |
    //      |       19       13        |
    //  e3+ 16-----18          14-----12 e2-
    //      |     f3+          f2-     |
    //      |                          |
    //      |                          |
    //      |     f0-         f1+      |
    //  e0- 2------4            8------6 e1+
    //      |        3 f0+    9        |
    //      |        |        | f1-    |
    //      |        |        |        |
    //      |        |        |        |
    //      0--------1--------7--------5
    //    P0        e0+      e1-         P1
    //(0,0)                               (1,0)
    float d11 = u+v;
    float d12 = U+v;
    float d21 = u+V;
    float d22 = U+V;
    float3 q[16];
    q[ 5] = (d11 == 0.0) ? cv[3]  : (u*cv[3] + v*cv[4])/d11;
    q[ 6] = (d12 == 0.0) ? cv[8]  : (U*cv[9] + v*cv[8])/d12;
    q[ 9] = (d21 == 0.0) ? cv[18] : (u*cv[19] + V*cv[18])/d21;
    q[10] = (d22 == 0.0) ? cv[13] : (U*cv[13] + V*cv[14])/d22;
    q[ 0] = cv[0];
    q[ 1] = cv[1];
    q[ 2] = cv[7];
    q[ 3] = cv[5];
    q[ 4] = cv[2];
    q[ 7] = cv[6];
    q[ 8] = cv[16];
    q[11] = cv[12];
    q[12] = cv[15];
    q[13] = cv[17];
    q[14] = cv[11];
    q[15] = cv[10];
    P   = float3(0,0,0);
    dPu = float3(0,0,0);
    dPv = float3(0,0,0);
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    float B[4], D[4], C[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    CUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    float3 dUU = float3(0,0,0);
    float3 dVV = float3(0,0,0);
    float3 dUV = float3(0,0,0);
    OsdUnivar4x4(UV.x, B, D, C);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = q[4*i + j];
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
            CUCP[i] += A * C[j];
        }
    }
    OsdUnivar4x4(UV.y, B, D, C);
    for (int i=0; i<4; ++i) {
        P   += B[i] * BUCP[i];
        dPu += B[i] * DUCP[i];
        dPv += D[i] * BUCP[i];
        dUU += B[i] * CUCP[i];
        dVV += C[i] * BUCP[i];
        dUV += D[i] * DUCP[i];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    dUU *= 6 * level;
    dVV *= 6 * level;
    dUV *= 9 * level;
    float3 n = cross(dPu, dPv);
    N = normalize(n);
    float E = dot(dPu, dPu);
    float F = dot(dPu, dPv);
    float G = dot(dPv, dPv);
    float e = dot(N, dUU);
    float f = dot(N, dUV);
    float g = dot(N, dVV);
    dNu = (f*F-e*G)/(E*G-F*F) * dPu + (e*F-f*E)/(E*G-F*F) * dPv;
    dNv = (g*F-f*G)/(E*G-F*F) * dPu + (f*F-g*E)/(E*G-F*F) * dPv;
    dNu = dNu/length(n) - n * (dot(dNu,n)/powr(dot(n,n), 1.5));
    dNv = dNv/length(n) - n * (dot(dNv,n)/powr(dot(n,n), 1.5));
#else //OSD_COMPUTE_NORMAL_DERIVATIVES
    float B[4], D[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    OsdUnivar4x4(UV.x, B, D);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = q[4*i + j];
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
        }
    }
    OsdUnivar4x4(UV.y, B, D);
    for (int i=0; i<4; ++i) {
        P += B[i] * BUCP[i];
        dPu += B[i] * DUCP[i];
        dPv += D[i] * BUCP[i];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    N = normalize(cross(dPu, dPv));
    dNu = float3(0,0,0);
    dNv = float3(0,0,0);
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
// ----------------------------------------------------------------------------
// Tessellation
// ----------------------------------------------------------------------------
// Organization of B-spline and Bezier control points.
// Each patch is defined by 16 control points (labeled 0-15).
// The patch will be evaluated across the domain from (0,0) at
// the lower-left to (1,1) at the upper-right. When computing
// adaptive tessellation metrics, we consider refined vertex-vertex
// and edge-vertex points along the transition edges of the patch
// (labeled vv* and ev* respectively).
// The two segments of each transition edge are labeled Lo and Hi,
// with the Lo segment occuring before the Hi segment along the
// transition edge's domain parameterization. These Lo and Hi segment
// tessellation levels determine how domain evaluation coordinates
// are remapped along transition edges. The Hi segment value will
// be zero for a non-transition edge.
// (0,1)                                         (1,1)
//   vv3                  ev23                   vv2
//        |       Lo3       |       Hi3       |
//      --O-----------O-----+-----O-----------O--
//        | 12        | 13     14 |        15 |
//        |           |           |           |
//        |           |           |           |
//    Hi0 |           |           |           | Hi2
//        |           |           |           |
//        O-----------O-----------O-----------O
//        | 8         | 9      10 |        11 |
//        |           |           |           |
// ev03 --+           |           |           +-- ev12
//        |           |           |           |
//        | 4         | 5       6 |         7 |
//        O-----------O-----------O-----------O
//        |           |           |           |
//    Lo0 |           |           |           | Lo2
//        |           |           |           |
//        |           |           |           |
//        | 0         | 1       2 |         3 |
//      --O-----------O-----+-----O-----------O--
//        |       Lo1       |       Hi1       |
//   vv0                  ev01                   vv1
// (0,0)                                         (1,0)
static float OsdComputePostProjectionSphereExtent(const float4x4 OsdProjectionMatrix, float3 center, float diameter)
    //float4 p = OsdProjectionMatrix * float4(center, 1.0);
    float w = OsdProjectionMatrix[0][3] * center.x + OsdProjectionMatrix[1][3] * center.y + OsdProjectionMatrix[2][3] * center.z + OsdProjectionMatrix[3][3];
    return abs(diameter * OsdProjectionMatrix[1][1] / w);
// Round up to the nearest even integer
static float OsdRoundUpEven(float x) {
    return 2*ceil(x/2);
// Round up to the nearest odd integer
static float OsdRoundUpOdd(float x) {
    return 2*ceil((x+1)/2)-1;
// Compute outer and inner tessellation levels taking into account the
// current tessellation spacing mode.
static void OsdComputeTessLevels(thread float4& tessOuterLo, thread float4& tessOuterHi,
                     thread float4& tessLevelOuter, thread float2& tessLevelInner)
    // Outer levels are the sum of the Lo and Hi segments where the Hi
    // segments will have lengths of zero for non-transition edges.
#if OSD_FRACTIONAL_EVEN_SPACING
    // Combine fractional outer transition edge levels before rounding.
    float4 combinedOuter = tessOuterLo + tessOuterHi;
    // Round the segments of transition edges separately. We will recover the
    // fractional parameterization of transition edges after tessellation.
    tessLevelOuter = combinedOuter;
    if (tessOuterHi[0] > 0) {
        tessLevelOuter[0] =
            OsdRoundUpEven(tessOuterLo[0]) + OsdRoundUpEven(tessOuterHi[0]);
    }
    if (tessOuterHi[1] > 0) {
        tessLevelOuter[1] =
            OsdRoundUpEven(tessOuterLo[1]) + OsdRoundUpEven(tessOuterHi[1]);
    }
    if (tessOuterHi[2] > 0) {
        tessLevelOuter[2] =
            OsdRoundUpEven(tessOuterLo[2]) + OsdRoundUpEven(tessOuterHi[2]);
    }
    if (tessOuterHi[3] > 0) {
        tessLevelOuter[3] =
            OsdRoundUpEven(tessOuterLo[3]) + OsdRoundUpEven(tessOuterHi[3]);
    }
#elif OSD_FRACTIONAL_ODD_SPACING
    // Combine fractional outer transition edge levels before rounding.
    float4 combinedOuter = tessOuterLo + tessOuterHi;
    // Round the segments of transition edges separately. We will recover the
    // fractional parameterization of transition edges after tessellation.
    //
    // The sum of the two outer odd segment lengths will be an even number
    // which the tessellator will increase by +1 so that there will be a
    // total odd number of segments. We clamp the combinedOuter tess levels
    // (used to compute the inner tess levels) so that the outer transition
    // edges will be sampled without degenerate triangles.
    tessLevelOuter = combinedOuter;
    if (tessOuterHi[0] > 0) {
        tessLevelOuter[0] =
            OsdRoundUpOdd(tessOuterLo[0]) + OsdRoundUpOdd(tessOuterHi[0]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
    if (tessOuterHi[1] > 0) {
        tessLevelOuter[1] =
            OsdRoundUpOdd(tessOuterLo[1]) + OsdRoundUpOdd(tessOuterHi[1]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
    if (tessOuterHi[2] > 0) {
        tessLevelOuter[2] =
            OsdRoundUpOdd(tessOuterLo[2]) + OsdRoundUpOdd(tessOuterHi[2]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
    if (tessOuterHi[3] > 0) {
        tessLevelOuter[3] =
            OsdRoundUpOdd(tessOuterLo[3]) + OsdRoundUpOdd(tessOuterHi[3]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
#else //OSD_FRACTIONAL_ODD_SPACING
    // Round equally spaced transition edge levels before combining.
    tessOuterLo = round(tessOuterLo);
    tessOuterHi = round(tessOuterHi);
    float4 combinedOuter = tessOuterLo + tessOuterHi;
    tessLevelOuter = combinedOuter;
#endif //OSD_FRACTIONAL_ODD_SPACING
    // Inner levels are the averages the corresponding outer levels.
    tessLevelInner[0] = (combinedOuter[1] + combinedOuter[3]) * 0.5;
    tessLevelInner[1] = (combinedOuter[0] + combinedOuter[2]) * 0.5;
static float OsdComputeTessLevel(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix, float3 p0, float3 p1)
    // Adaptive factor can be any computation that depends only on arg values.
    // Project the diameter of the edge's bounding sphere instead of using the
    // length of the projected edge itself to avoid problems near silhouettes.
    float3 center = (p0 + p1) / 2.0;
    float diameter = distance(p0, p1);
    float projLength = OsdComputePostProjectionSphereExtent(OsdProjectionMatrix, center, diameter);
    float tessLevel = max(1.0, OsdTessLevel * projLength);
    // We restrict adaptive tessellation levels to half of the device
    // supported maximum because transition edges are split into two
    // halfs and the sum of the two corresponding levels must not exceed
    // the device maximum. We impose this limit even for non-transition
    // edges because a non-transition edge must be able to match up with
    // one half of the transition edge of an adjacent transition patch.
    return min(tessLevel, (float)(OSD_MAX_TESS_LEVEL / 2));
static void OsdGetTessLevelsUniform(const float OsdTessLevel, int3 patchParam,
                        thread float4& tessOuterLo, thread float4& tessOuterHi)
    // Uniform factors are simple powers of two for each level.
    // The maximum here can be increased if we know the maximum
    // refinement level of the mesh:
    //     min(OSD_MAX_TESS_LEVEL, pow(2, MaximumRefinementLevel-1)
    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);
    float tessLevel = min(OsdTessLevel, ((float)OSD_MAX_TESS_LEVEL / 2)) /
                        pow(2, refinementLevel - 1.0f);
//    float tessLevel = min(OsdTessLevel, (float)OSD_MAX_TESS_LEVEL);
//    if(refinementLevel != 0)
//         tessLevel /= (1 << (refinementLevel - 1));
//    else
//    {
//        tessLevel /= pow(2.0, (0 - 1));
//        tessLevel /= pow(2.0, (refinementLevel - 1));
//    }
    // tessLevels of transition edge should be clamped to 2.
    int transitionMask = OsdGetPatchTransitionMask(patchParam);
    float4 tessLevelMin = float4(1)
    + float4(((transitionMask & 8) >> 3),
             ((transitionMask & 1) >> 0),
             ((transitionMask & 2) >> 1),
             ((transitionMask & 4) >> 2));
//    tessLevelMin =  (tessLevelMin - 1.0) * 2.0f + 1.0;
//    tessLevelMin = float4(OsdTessLevel);
    tessOuterLo = max(float4(tessLevel,tessLevel,tessLevel,tessLevel),
                      tessLevelMin);
    tessOuterHi = float4(0,0,0,0);
//    tessOuterLo.x = refinementLevel;
static void OsdGetTessLevelsRefinedPoints(const float OsdTessLevel,
                              const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                              float3 cp[16], int3 patchParam,
                              thread float4& tessOuterLo, thread float4& tessOuterHi)
    // Each edge of a transition patch is adjacent to one or two patches
    // at the next refined level of subdivision. We compute the corresponding
    // vertex-vertex and edge-vertex refined points along the edges of the
    // patch using Catmull-Clark subdivision stencil weights.
    // For simplicity, we let the optimizer discard unused computation.
    float3 vv0 = (cp[0] + cp[2] + cp[8] + cp[10]) * 0.015625 +
    (cp[1] + cp[4] + cp[6] + cp[9]) * 0.09375 + cp[5] * 0.5625;
    float3 ev01 = (cp[1] + cp[2] + cp[9] + cp[10]) * 0.0625 +
    (cp[5] + cp[6]) * 0.375;
    float3 vv1 = (cp[1] + cp[3] + cp[9] + cp[11]) * 0.015625 +
    (cp[2] + cp[5] + cp[7] + cp[10]) * 0.09375 + cp[6] * 0.5625;
    float3 ev12 = (cp[5] + cp[7] + cp[9] + cp[11]) * 0.0625 +
    (cp[6] + cp[10]) * 0.375;
    float3 vv2 = (cp[5] + cp[7] + cp[13] + cp[15]) * 0.015625 +
    (cp[6] + cp[9] + cp[11] + cp[14]) * 0.09375 + cp[10] * 0.5625;
    float3 ev23 = (cp[5] + cp[6] + cp[13] + cp[14]) * 0.0625 +
    (cp[9] + cp[10]) * 0.375;
    float3 vv3 = (cp[4] + cp[6] + cp[12] + cp[14]) * 0.015625 +
    (cp[5] + cp[8] + cp[10] + cp[13]) * 0.09375 + cp[9] * 0.5625;
    float3 ev03 = (cp[4] + cp[6] + cp[8] + cp[10]) * 0.0625 +
    (cp[5] + cp[9]) * 0.375;
    tessOuterLo = float4(0,0,0,0);
    tessOuterHi = float4(0,0,0,0);
    int transitionMask = OsdGetPatchTransitionMask(patchParam);
    if ((transitionMask & 8) != 0) {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv0, ev03);
        tessOuterHi[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv3, ev03);
    } else {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[5], cp[9]);
    }
    if ((transitionMask & 1) != 0) {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv0, ev01);
        tessOuterHi[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv1, ev01);
    } else {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[5], cp[6]);
    }
    if ((transitionMask & 2) != 0) {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv1, ev12);
        tessOuterHi[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv2, ev12);
    } else {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[6], cp[10]);
    }
    if ((transitionMask & 4) != 0) {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv3, ev23);
        tessOuterHi[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv2, ev23);
    } else {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[9], cp[10]);
    }
static float3 miniMul(float4x4 a, float3 b)
    float3 r;
    r.x = a[0][0] * b[0] + a[1][0] * b[1] + a[2][0] * b[2] + a[3][0];
    r.y = a[0][1] * b[0] + a[1][1] * b[1] + a[2][1] * b[2] + a[3][1];
    r.z = a[0][2] * b[0] + a[1][2] * b[1] + a[2][2] * b[2] + a[3][2];
    return r;
static void OsdGetTessLevelsLimitPoints(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                            device OsdPerPatchVertexBezier* cpBezier,
                            int3 patchParam, thread float4& tessOuterLo, thread float4& tessOuterHi)
    // Each edge of a transition patch is adjacent to one or two patches
    // at the next refined level of subdivision. When the patch control
    // points have been converted to the Bezier basis, the control points
    // at the four corners are on the limit surface (since a Bezier patch
    // interpolates its corner control points). We can compute an adaptive
    // tessellation level for transition edges on the limit surface by
    // evaluating a limit position at the mid point of each transition edge.
    tessOuterLo = float4(0,0,0,0);
    tessOuterHi = float4(0,0,0,0);
    int transitionMask = OsdGetPatchTransitionMask(patchParam);
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    // PERFOMANCE: we just need to pick the correct corner points from P, P1, P2
    float3 p0 = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 0.0));
    float3 p3 = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 0.0));
    float3 p12 = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 1.0));
    float3 p15 = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 1.0));
    p0 = miniMul(OsdModelViewMatrix, p0);
    p3 = miniMul(OsdModelViewMatrix, p3);
    p12 = miniMul(OsdModelViewMatrix, p12);
    p15 = miniMul(OsdModelViewMatrix, p15);
    thread float3 * tPt;
    float3 ev;
    if ((transitionMask & 8) != 0) { // EVO3
        ev = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 0.5));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p12, ev);
    } else {
        tPt = &p12;
    }
    tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p0, *tPt);
    
    if ((transitionMask & 1) != 0) { // EV01
        ev = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 0.0));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p3, ev);
    } else {
        tPt = &p3;
    }
    tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p0, *tPt);
    
    if ((transitionMask & 2) != 0) { // EV12
        ev = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 0.5));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p15, ev);
    } else {
        tPt = &p15;
    }
    tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p3, *tPt);
    
    if ((transitionMask & 4) != 0) { // EV23
        ev = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 1.0));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p15, ev);
    } else {
        tPt = &p15;
    }
    tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p12, *tPt);
#else // OSD_PATCH_ENABLE_SINGLE_CREASE
    float3 p0 = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 0.5));
    float3 p3 = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 0.0));
    float3 p12 = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 0.5));
    float3 p15 = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 1.0));
    p0 = miniMul(OsdModelViewMatrix, p0);
    p3 = miniMul(OsdModelViewMatrix, p3);
    p12 = miniMul(OsdModelViewMatrix, p12);
    p15 = miniMul(OsdModelViewMatrix, p15);
    float3 c00 = miniMul(OsdModelViewMatrix, float3(cpBezier[0].P));
    float3 c12 = miniMul(OsdModelViewMatrix, float3(cpBezier[12].P));
    float3 c03 = miniMul(OsdModelViewMatrix, float3(cpBezier[3].P));
    float3 c15 = miniMul(OsdModelViewMatrix, float3(cpBezier[15].P));
    
    if ((transitionMask & 8) != 0) {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, p0);
        tessOuterHi[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c12, p0);
    } else {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, c12);
    }
    if ((transitionMask & 1) != 0) {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, p3);
        tessOuterHi[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c03, p3);
    } else {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, c03);
    }
    if ((transitionMask & 2) != 0) {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c03, p12);
        tessOuterHi[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c15, p12);
    } else {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c03, c15);
    }
    if ((transitionMask & 4) != 0) {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c12, p15);
        tessOuterHi[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c15, p15);
    } else {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c12, c15);
    }
#endif
static void OsdGetTessLevelsUniform(const float OsdTessLevel, int3 patchParam,
                        thread float4& tessLevelOuter, thread float2& tessLevelInner,
                        thread float4& tessOuterLo, thread float4& tessOuterHi)
    OsdGetTessLevelsUniform(OsdTessLevel, patchParam, tessOuterLo, tessOuterHi);
    OsdComputeTessLevels(tessOuterLo, tessOuterHi, tessLevelOuter, tessLevelInner);
static void OsdGetTessLevelsAdaptiveRefinedPoints(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                                      float3 cpRefined[16], int3 patchParam,
                                      thread float4& tessLevelOuter, thread float2& tessLevelInner,
                                      thread float4& tessOuterLo, thread float4& tessOuterHi)
    OsdGetTessLevelsRefinedPoints(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cpRefined, patchParam, tessOuterLo, tessOuterHi);
    OsdComputeTessLevels(tessOuterLo, tessOuterHi,
                         tessLevelOuter, tessLevelInner);
static void OsdGetTessLevelsAdaptiveLimitPoints(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                                    device OsdPerPatchVertexBezier* cpBezier,
                                    int3 patchParam,
                                    thread float4& tessLevelOuter, thread float2& tessLevelInner,
                                    thread float4& tessOuterLo, thread float4& tessOuterHi)
    OsdGetTessLevelsLimitPoints(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cpBezier, patchParam, tessOuterLo, tessOuterHi);
    OsdComputeTessLevels(tessOuterLo, tessOuterHi,
                         tessLevelOuter, tessLevelInner);
static void OsdGetTessLevels(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                 float3 cp0, float3 cp1, float3 cp2, float3 cp3,
                 int3 patchParam,
                 thread float4& tessLevelOuter, thread float2& tessLevelInner)
    float4 tessOuterLo = float4(0,0,0,0);
    float4 tessOuterHi = float4(0,0,0,0);
    cp0 = mul(OsdModelViewMatrix, float4(cp0, 1.0)).xyz;
    cp1 = mul(OsdModelViewMatrix, float4(cp1, 1.0)).xyz;
    cp2 = mul(OsdModelViewMatrix, float4(cp2, 1.0)).xyz;
    cp3 = mul(OsdModelViewMatrix, float4(cp3, 1.0)).xyz;
#if OSD_ENABLE_SCREENSPACE_TESSELLATION
    tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp0, cp1);
    tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp0, cp3);
    tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp2, cp3);
    tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp1, cp2);
    tessOuterHi = float4(0,0,0,0);
#else //OSD_ENABLE_SCREENSPACE_TESSELLATION
    OsdGetTessLevelsUniform(OsdTessLevel, patchParam, tessOuterLo, tessOuterHi);
#endif //OSD_ENABLE_SCREENSPACE_TESSELLATION
    OsdComputeTessLevels(tessOuterLo, tessOuterHi,
                         tessLevelOuter, tessLevelInner);
#if OSD_FRACTIONAL_EVEN_SPACING || OSD_FRACTIONAL_ODD_SPACING
static float OsdGetTessFractionalSplit(float t, float level, float levelUp)
    // Fractional tessellation of an edge will produce n segments where n
    // is the tessellation level of the edge (level) rounded up to the
    // nearest even or odd integer (levelUp). There will be n-2 segments of
    // equal length (dx1) and two additional segments of equal length (dx0)
    // that are typically shorter than the other segments. The two additional
    // segments should be placed symmetrically on opposite sides of the
    // edge (offset).
#if OSD_FRACTIONAL_EVEN_SPACING
    if (level <= 2) return t;
    float base = pow(2.0,floor(log2(levelUp)));
    float offset = 1.0/(int(2*base-levelUp)/2 & int(base/2-1));
#elif OSD_FRACTIONAL_ODD_SPACING
    if (level <= 1) return t;
    float base = pow(2.0,floor(log2(levelUp)));
    float offset = 1.0/(((int(2*base-levelUp)/2+1) & int(base/2-1))+1);
#endif //OSD_FRACTIONAL_ODD_SPACING
    float dx0 = (1.0 - (levelUp-level)/2) / levelUp;
    float dx1 = (1.0 - 2.0*dx0) / (levelUp - 2.0*ceil(dx0));
    if (t < 0.5) {
        float x = levelUp/2 - round(t*levelUp);
        return 0.5 - (x*dx1 + int(x*offset > 1) * (dx0 - dx1));
    } else if (t > 0.5) {
        float x = round(t*levelUp) - levelUp/2;
        return 0.5 + (x*dx1 + int(x*offset > 1) * (dx0 - dx1));
    } else {
        return t;
    }
#endif //OSD_FRACTIONAL_EVEN_SPACING || OSD_FRACTIONAL_ODD_SPACING
static float OsdGetTessTransitionSplit(float t, float lo, float hi )
#if OSD_FRACTIONAL_EVEN_SPACING
  float loRoundUp = OsdRoundUpEven(lo);
  float hiRoundUp = OsdRoundUpEven(hi);
  // Convert the parametric t into a segment index along the combined edge.
  float ti = round(t * (loRoundUp + hiRoundUp));
  if (ti <= loRoundUp) {
      float t0 = ti / loRoundUp;
      return OsdGetTessFractionalSplit(t0, lo, loRoundUp) * 0.5;
   } else {
      float t1 = (ti - loRoundUp) / hiRoundUp;
      return OsdGetTessFractionalSplit(t1, hi, hiRoundUp) * 0.5 + 0.5;
    }
#elif OSD_FRACTIONAL_ODD_SPACING
  float loRoundUp = OsdRoundUpOdd(lo);
  float hiRoundUp = OsdRoundUpOdd(hi);
  // Convert the parametric t into a segment index along the combined edge.
  // The +1 below is to account for the extra segment produced by the
  // tessellator since the sum of two odd tess levels will be rounded
  // up by one to the next odd integer tess level.
  float ti = (t * (loRoundUp + hiRoundUp + 1));
  OSD_UV_CORRECTION
  ti = round(ti);
  if (ti <= loRoundUp) {
      float t0 = ti / loRoundUp;
      return OsdGetTessFractionalSplit(t0, lo, loRoundUp) * 0.5;
  } else if (ti > (loRoundUp+1)) {
      float t1 = (ti - (loRoundUp+1)) / hiRoundUp;
      return OsdGetTessFractionalSplit(t1, hi, hiRoundUp) * 0.5 + 0.5;
  } else {
      return 0.5;
#else //OSD_FRACTIONAL_ODD_SPACING
  // Convert the parametric t into a segment index along the combined edge.
  float ti = round(t * (lo + hi));
  if (ti <= lo) {
      return (ti / lo) * 0.5;
  } else {
      return ((ti - lo) / hi) * 0.5 + 0.5;
#endif //OSD_FRACTIONAL_ODD_SPACING
static float2 OsdGetTessParameterization(float2 uv, float4 tessOuterLo, float4 tessOuterHi)
    float2 UV = uv;
if (UV.x == 0 && tessOuterHi[0] > 0)
UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[0], tessOuterHi[0]);
else if (UV.y == 0 && tessOuterHi[1] > 0)
UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[1], tessOuterHi[1]);
else if (UV.x == 1 && tessOuterHi[2] > 0)
UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[2], tessOuterHi[2]);
else if (UV.y == 1 && tessOuterHi[3] > 0)
UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[3], tessOuterHi[3]);
    return UV;
static int4 OsdGetPatchCoord(int3 patchParam)
    int faceId = OsdGetPatchFaceId(patchParam);
    int faceLevel = OsdGetPatchFaceLevel(patchParam);
    int2 faceUV = OsdGetPatchFaceUV(patchParam);
    return int4(faceUV.x, faceUV.y, faceLevel, faceId);
static float4 OsdInterpolatePatchCoord(float2 localUV, int3 patchParam)
    int4 perPrimPatchCoord = OsdGetPatchCoord(patchParam);
    int faceId = perPrimPatchCoord.w;
    int faceLevel = perPrimPatchCoord.z;
    float2 faceUV = float2(perPrimPatchCoord.x, perPrimPatchCoord.y);
    float2 uv = localUV/faceLevel + faceUV/faceLevel;
    // add 0.5 to integer values for more robust interpolation
    return float4(uv.x, uv.y, faceLevel+0.5, faceId+0.5);
// ----------------------------------------------------------------------------
// GregoryBasis
// ----------------------------------------------------------------------------
static void OsdComputePerPatchVertexGregoryBasis(int3 patchParam, int ID, float3 cv,
                                     device OsdPerPatchVertexGregoryBasis& result)
    result.P = cv;
// Regular BSpline to Bezier
constant float4x4 Q(
                    float4(1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f),
                    float4(0.f,     4.f/6.f, 2.f/6.f, 0.f),
                    float4(0.f,     2.f/6.f, 4.f/6.f, 0.f),
                    float4(0.f,     1.f/6.f, 4.f/6.f, 1.f/6.f)
                    );
// Infinitely Sharp (boundary)
constant float4x4 Mi(
                     float4(1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f),
                     float4(0.f,     4.f/6.f, 2.f/6.f, 0.f),
                     float4(0.f,     2.f/6.f, 4.f/6.f, 0.f),
                     float4(0.f,     0.f,     1.f,     0.f)
                     );
    
static float4x4 OsdComputeMs2(float sharpness, float factor)
    float s = exp2(sharpness);
    float s2 = s*s;
    float s3 = s2*s;
    float sx6 = s*6.0;
    float sx6m2 = sx6 - 2;
    float sfrac1 = 1-s;
    float ssub1 = s-1;
    float ssub1_2 = ssub1 * ssub1;
    float div6 = 1.0/6.0;
    
    float4x4 m(
               float4(0, s + 1 + 3*s2 - s3, 7*s - 2 - 6*s2 + 2*s3,    sfrac1 * ssub1_2),
               float4(0,      1 + 2*s + s2,         sx6m2 - 2*s2,             ssub1_2),
               float4(0,               1+s,                sx6m2,              sfrac1),
               float4(0,                 1,                sx6m2,                 1));
    
    m *= factor * (1/sx6);
    
    m[0][0] = div6 * factor;
    
    return m;
// ----------------------------------------------------------------------------
// BSpline
// ----------------------------------------------------------------------------
// convert BSpline cv to Bezier cv
template<typename VertexType> //VertexType should be some type that implements float3 VertexType::GetPosition()
static void OsdComputePerPatchVertexBSpline(int3 patchParam, unsigned ID, threadgroup VertexType* cv, device OsdPerPatchVertexBezier& result)
    int i = ID%4;
    int j = ID/4;
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    float3 P  = float3(0,0,0); // 0 to 1-2^(-Sf)
    float3 P1 = float3(0,0,0); // 1-2^(-Sf) to 1-2^(-Sc)
    float3 P2 = float3(0,0,0); // 1-2^(-Sc) to 1
    float sharpness = OsdGetPatchSharpness(patchParam);
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    if (sharpness > 0 && (boundaryMask & 15))
    {
        float Sf = floor(sharpness);
        float Sc = ceil(sharpness);
        float Sr = fract(sharpness);
        float4x4 Mj = OsdComputeMs2(Sf, 1-Sr);
        float4x4 Ms = Mj;
        Mj += (Sr * Mi);
        Ms += OsdComputeMs2(Sc, Sr);
#if USE_PTVS_SHARPNESS
#else
        float s0 = 1 - exp2(-Sf);
        float s1 = 1 - exp2(-Sc);
        result.vSegments = float2(s0, s1);
#endif
        
        bool isBoundary[2];
        isBoundary[0] = (((boundaryMask & 8) != 0) || ((boundaryMask & 2) != 0)) ? true : false;
        isBoundary[1] = (((boundaryMask & 4) != 0) || ((boundaryMask & 1) != 0)) ? true : false;
        bool needsFlip[2];
        needsFlip[0] = (boundaryMask & 8) ? true : false;
        needsFlip[1] = (boundaryMask & 1) ? true : false;
        float3 Hi[4], Hj[4], Hs[4];
        
        if (isBoundary[0])
        {
            int t[4] = {0,1,2,3};
            int ti = i, step = 1, start = 0;
            if (needsFlip[0]) {
                t[0] = 3; t[1] = 2; t[2] = 1; t[3] = 0;
                ti = 3-i;
                start = 3; step = -1;
            }
            for (int l=0; l<4; ++l) {
                Hi[l] = Hj[l] = Hs[l] = float3(0,0,0);
                for (int k=0, tk = start; k<4; ++k, tk+=step) {
                    float3 p = cv[l*4 + k].GetPosition();
                    Hi[l] += Mi[ti][tk] * p;
                    Hj[l] += Mj[ti][tk] * p;
                    Hs[l] += Ms[ti][tk] * p;
                }
            }
        }
        else
        {
            for (int l=0; l<4; ++l) {
                Hi[l] = Hj[l] = Hs[l] = float3(0,0,0);
                for (int k=0; k<4; ++k) {
                    float3 p = cv[l*4 + k].GetPosition();
                    float3 val = Q[i][k] * p;
                    Hi[l] += val;
                    Hj[l] += val;
                    Hs[l] += val;
                }
            }
        }
        {
            int t[4] = {0,1,2,3};
            int tj = j, step = 1, start = 0;
            if (needsFlip[1]) {
                t[0] = 3; t[1] = 2; t[2] = 1; t[3] = 0;
                tj = 3-j;
                start = 3; step = -1;
            }
            for (int k=0, tk = start; k<4; ++k, tk+=step) {
                if (isBoundary[1])
                {
                    P  += Mi[tj][tk]*Hi[k];
                    P1 += Mj[tj][tk]*Hj[k];
                    P2 += Ms[tj][tk]*Hs[k];
                }
                else
                {
                    P  += Q[j][k]*Hi[k];
                    P1 += Q[j][k]*Hj[k];
                    P2 += Q[j][k]*Hs[k];
                }
            }
        }
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    result.P  = half3(P);
    result.P1 = half3(P1);
    result.P2 = half3(P2);
#else
    result.P  = P;
    result.P1 = P1;
    result.P2 = P2;
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    } else {
#if USE_PTVS_SHARPNESS
#else
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
        result.vSegments = half2(0, 0);
#else
        result.vSegments = float2(0, 0);
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
#endif
        OsdComputeBSplineBoundaryPoints(cv, patchParam);
    float3 Hi[4];
    for (int l=0; l<4; ++l) {
        Hi[l] = float3(0,0,0);
        for (int k=0; k<4; ++k) {
            Hi[l] += Q[i][k] * cv[l*4 + k].GetPosition();
        }
    }
    for (int k=0; k<4; ++k) {
        P += Q[j][k]*Hi[k];
    }
        
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    result.P  = half3(P);
    result.P1 = half3(P);
    result.P2 = half3(P);
#else
    result.P  = P;
    result.P1 = P;
    result.P2 = P;
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
#else
    OsdComputeBSplineBoundaryPoints(cv, patchParam);
    float3 H[4];
    for (int l=0; l<4; ++l) {
        H[l] = float3(0,0,0);
        for(int k=0; k<4; ++k) {
            H[l] += Q[i][k] * (cv + l*4 + k)->GetPosition();
        }
    }
    {
        float3 P = float3(0,0,0);
        for (int k=0; k<4; ++k){
            P += Q[j][k]*H[k];
        }
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
        result.P = half3(P);
#else
        result.P = P;
#endif
    }
#endif
template<typename PerPatchVertexBezier>
static void OsdEvalPatchBezier(int3 patchParam, float2 UV,
                   PerPatchVertexBezier cv,
                   thread float3& P, thread float3& dPu, thread float3& dPv,
                   thread float3& N, thread float3& dNu, thread float3& dNv,
                   thread float2& vSegments)
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    float B[4], D[4], C[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    CUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    OsdUnivar4x4(UV.x, B, D, C);
#else
    float B[4], D[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    OsdUnivar4x4(UV.x, B, D);
#endif
    // ----------------------------------------------------------------
#if OSD_PATCH_ENABLE_SINGLE_CREASE
#if USE_PTVS_SHARPNESS
    float sharpness = OsdGetPatchSharpness(patchParam);
    float Sf = floor(sharpness);
    float Sc = ceil(sharpness);
    float s0 = 1 - exp2(-Sf);
    float s1 = 1 - exp2(-Sc);
    vSegments = float2(s0, s1);
#else //USE_PTVS_SHARPNESS
    vSegments = cv[0].vSegments;
#endif //USE_PTVS_SHARPNESS
    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, UV);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            int k = 4*i + j;
            float3 A = (s <= vSegments.x) ? float3(cv[k].P)
            :   ((s <= vSegments.y) ?  float3(cv[k].P1)
                 :  float3(cv[k].P2));
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
#if OSD_COMPUTE_NORMAL_DERIVATIVES
            CUCP[i] += A * C[j];
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
        }
    }
#else //OSD_PATCH_ENABLE_SINGLE_CREASE
    // ----------------------------------------------------------------
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = float3(cv[4*i + j].P);
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
#if OSD_COMPUTE_NORMAL_DERIVATIVES
            CUCP[i] += A * C[j];
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
        }
    }
#endif //OSD_PATCH_ENABLE_SINGLE_CREASE
    // ----------------------------------------------------------------
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    // used for weingarten term
    OsdUnivar4x4(UV.y, B, D, C);
    P = B[0] * BUCP[0];
    dPu = B[0] * DUCP[0];
    dPv = D[0] * BUCP[0];
    float3 dUU = B[0] * CUCP[0];
    float3 dVV = C[0] * BUCP[0];
    float3 dUV = D[0] * DUCP[0];
    for (int k=1; k<4; ++k) {
        P   += B[k] * BUCP[k];
        dPu += B[k] * DUCP[k];
        dPv += D[k] * BUCP[k];
        dUU += B[k] * CUCP[k];
        dVV += C[k] * BUCP[k];
        dUV += D[k] * DUCP[k];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    dUU *= 6 * level;
    dVV *= 6 * level;
    dUV *= 9 * level;
    float3 n = cross(dPu, dPv);
    float ln = 1.0 / length(n);
    N = ln * n;
    float E = dot(dPu, dPu);
    float F = dot(dPu, dPv);
    float G = dot(dPv, dPv);
    float e = dot(N, dUU);
    float f = dot(N, dUV);
    float g = dot(N, dVV);
    float EGFF = 1.0 / (E*G - F*F);
    dNu = (f*F-e*G) * EGFF * dPu + (e*F-f*E) * EGFF * dPv;
    dNv = (g*F-f*G) * EGFF * dPu + (f*F-g*E) * EGFF * dPv;
    float powrn = 1.0 / powr(dot(n,n), 1.5);
    dNu = dNu * ln - n * (dot(dNu,n) * powrn);
    dNv = dNv * ln - n * (dot(dNv,n) * powrn);
#else //OSD_COMPUTE_NORMAL_DERIVATIVES
    OsdUnivar4x4(UV.y, B, D);
    P = B[0] * BUCP[0];
    dPu = B[0] * DUCP[0];
    dPv = D[0] * BUCP[0];
    for (int k=1; k<4; ++k) {
        P   += B[k] * BUCP[k];
        dPu += B[k] * DUCP[k];
        dPv += D[k] * BUCP[k];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    N = normalize(cross(dPu, dPv));
    dNu = float3(0,0,0);
    dNv = float3(0,0,0);
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
// compute single-crease patch matrix
static float4x4 OsdComputeMs(float sharpness)
    float s = exp2(sharpness);
    float s2 = s*s;
    float s3 = s2*s;
    float4x4 m(
        float4(0, s + 1 + 3*s2 - s3, 7*s - 2 - 6*s2 + 2*s3, (1-s)*(s-1)*(s-1)),
        float4(0,       (1+s)*(1+s),        6*s - 2 - 2*s2,       (s-1)*(s-1)),
        float4(0,               1+s,               6*s - 2,               1-s),
        float4(0,                 1,               6*s - 2,                 1));
    m[0] /= (s*6.0);
    m[1] /= (s*6.0);
    m[2] /= (s*6.0);
    m[3] /= (s*6.0);
    m[0][0] = 1.0/6.0;
    return m;
// flip matrix orientation
static float4x4 OsdFlipMatrix(float4x4 m)
    return float4x4(float4(m[3][3], m[3][2], m[3][1], m[3][0]),
                    float4(m[2][3], m[2][2], m[2][1], m[2][0]),
                    float4(m[1][3], m[1][2], m[1][1], m[1][0]),
                    float4(m[0][3], m[0][2], m[0][1], m[0][0]));
static void OsdFlipMatrix(threadgroup float * src, threadgroup float * dst)
    for (int i = 0; i < 16; i++) dst[i] = src[15-i];
// ----------------------------------------------------------------------------
// Legacy Gregory
// ----------------------------------------------------------------------------
#if OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
#if OSD_MAX_VALENCE<=10
constant float ef[7] = {
    0.813008, 0.500000, 0.363636, 0.287505,
    0.238692, 0.204549, 0.179211
#else
constant float ef[27] = {
    0.812816, 0.500000, 0.363644, 0.287514,
    0.238688, 0.204544, 0.179229, 0.159657,
    0.144042, 0.131276, 0.120632, 0.111614,
    0.103872, 0.09715, 0.0912559, 0.0860444,
    0.0814022, 0.0772401, 0.0734867, 0.0700842,
    0.0669851, 0.0641504, 0.0615475, 0.0591488,
    0.0569311, 0.0548745, 0.0529621
#endif
static float cosfn(int n, int j) {
    return cospi((2.0f * j)/float(n));
static float sinfn(int n, int j) {
    return sinpi((2.0f * j)/float(n));
#ifndef OSD_MAX_VALENCE
#define OSD_MAX_VALENCE 4
#endif
template<typename OsdVertexBuffer>
static float3 OsdReadVertex(int vertexIndex, OsdVertexBuffer osdVertexBuffer)
    int index = (vertexIndex /*+ OsdBaseVertex()*/);
    return osdVertexBuffer[index].position;
template<typename OsdValenceBuffer>
static int OsdReadVertexValence(int vertexID, OsdValenceBuffer osdValenceBuffer)
    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1));
    return osdValenceBuffer[index];
template<typename OsdValenceBuffer>
static int OsdReadVertexIndex(int vertexID, int valenceVertex, OsdValenceBuffer osdValenceBuffer)
    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1) + 1 + valenceVertex);
    return osdValenceBuffer[index];
template<typename OsdQuadOffsetBuffer>
static int OsdReadQuadOffset(int primitiveID, int offsetVertex, OsdQuadOffsetBuffer osdQuadOffsetBuffer)
    int index = int(4*primitiveID + offsetVertex);
    return osdQuadOffsetBuffer[index];
static void OsdComputePerVertexGregory(unsigned vID, float3 P, threadgroup OsdPerVertexGregory& v, OsdPatchParamBufferSet osdBuffers)
    v.clipFlag = short3(0,0,0);
    int ivalence = OsdReadVertexValence(vID, osdBuffers.valenceBuffer);
    v.valence = ivalence;
    int valence = abs(ivalence);
    float3 f[OSD_MAX_VALENCE];
    float3 pos = P;
    float3 opos = float3(0,0,0);
#if OSD_PATCH_GREGORY_BOUNDARY
    v.org = pos;
    int boundaryEdgeNeighbors[2];
    int currNeighbor = 0;
    int ibefore = 0;
    int zerothNeighbor = 0;
#endif
    for (int i=0; i<valence; ++i) {
        int im = (i+valence-1)%valence;
        int ip = (i+1)%valence;
        int idx_neighbor = OsdReadVertexIndex(vID, 2*i, osdBuffers.valenceBuffer);
#if OSD_PATCH_GREGORY_BOUNDARY
        bool isBoundaryNeighbor = false;
        int valenceNeighbor = OsdReadVertexValence(idx_neighbor, osdBuffers.valenceBuffer);
        if (valenceNeighbor < 0) {
            isBoundaryNeighbor = true;
            if (currNeighbor<2) {
                boundaryEdgeNeighbors[currNeighbor] = idx_neighbor;
            }
            currNeighbor++;
            if (currNeighbor == 1) {
                ibefore = i;
                zerothNeighbor = i;
            } else {
                if (i-ibefore == 1) {
                    int tmp = boundaryEdgeNeighbors[0];
                    boundaryEdgeNeighbors[0] = boundaryEdgeNeighbors[1];
                    boundaryEdgeNeighbors[1] = tmp;
                    zerothNeighbor = i;
                }
            }
        }
#endif
        float3 neighbor = OsdReadVertex(idx_neighbor, osdBuffers.vertexBuffer);
        int idx_diagonal = OsdReadVertexIndex(vID, 2*i + 1, osdBuffers.valenceBuffer);
        float3 diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);
        int idx_neighbor_p = OsdReadVertexIndex(vID, 2*ip, osdBuffers.valenceBuffer);
        float3 neighbor_p = OsdReadVertex(idx_neighbor_p, osdBuffers.vertexBuffer);
        int idx_neighbor_m = OsdReadVertexIndex(vID, 2*im, osdBuffers.valenceBuffer);
        float3 neighbor_m = OsdReadVertex(idx_neighbor_m, osdBuffers.vertexBuffer);
        int idx_diagonal_m = OsdReadVertexIndex(vID, 2*im + 1, osdBuffers.valenceBuffer);
        float3 diagonal_m = OsdReadVertex(idx_diagonal_m, osdBuffers.vertexBuffer);
        f[i] = (pos * float(valence) + (neighbor_p + neighbor)*2.0f + diagonal) / (float(valence)+5.0f);
        opos += f[i];
        v.r[i] = (neighbor_p-neighbor_m)/3.0f + (diagonal - diagonal_m)/6.0f;
    }
    opos /= valence;
    v.P = float4(opos, 1.0f).xyz;
    float3 e;
    v.e0 = float3(0,0,0);
    v.e1 = float3(0,0,0);
    for(int i=0; i<valence; ++i) {
        int im = (i + valence -1) % valence;
        e = 0.5f * (f[i] + f[im]);
        v.e0 += cosfn(valence, i)*e;
        v.e1 += sinfn(valence, i)*e;
    }
    v.e0 *= ef[valence - 3];
    v.e1 *= ef[valence - 3];
#if OSD_PATCH_GREGORY_BOUNDARY
    v.zerothNeighbor = zerothNeighbor;
    if (currNeighbor == 1) {
        boundaryEdgeNeighbors[1] = boundaryEdgeNeighbors[0];
    }
    if (ivalence < 0) {
        if (valence > 2) {
            v.P = (OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) +
                   OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer) +
                   4.0f * pos)/6.0f;
        } else {
            v.P = pos;
        }
        v.e0 = (OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) -
                OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer))/6.0;
        float k = float(float(valence) - 1.0f);    //k is the number of faces
        float c = cospi(1.0/k);
        float s = sinpi(1.0/k);
        float gamma = -(4.0f*s)/(3.0f*k+c);
        float alpha_0k = -((1.0f+2.0f*c)*sqrt(1.0f+c))/((3.0f*k+c)*sqrt(1.0f-c));
        float beta_0 = s/(3.0f*k + c);
        int idx_diagonal = OsdReadVertexIndex(vID, 2*zerothNeighbor + 1, osdBuffers.valenceBuffer);
        float3 diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);
        v.e1 = gamma * pos +
            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) +
            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer) +
            beta_0 * diagonal;
        for (int x=1; x<valence - 1; ++x) {
            int curri = ((x + zerothNeighbor)%valence);
            float alpha = (4.0f*sinpi((float(x))/k))/(3.0f*k+c);
            float beta = (sinpi((float(x))/k) + sinpi((float(x+1))/k))/(3.0f*k+c);
            int idx_neighbor = OsdReadVertexIndex(vID, 2*curri, osdBuffers.valenceBuffer);
            float3 neighbor = OsdReadVertex(idx_neighbor, osdBuffers.vertexBuffer);
            idx_diagonal = OsdReadVertexIndex(vID, 2*curri + 1, osdBuffers.valenceBuffer);
            diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);
            v.e1 += alpha * neighbor + beta * diagonal;
        }
        v.e1 /= 3.0f;
    }
#endif
static void OsdComputePerPatchVertexGregory(int3 patchParam, unsigned ID, unsigned primitiveID,
                                threadgroup OsdPerVertexGregory* v,
                                device OsdPerPatchVertexGregory& result,
                                OsdPatchParamBufferSet osdBuffers)
    result.P = v[ID].P;
    int i = ID;
    int ip = (i+1)%4;
    int im = (i+3)%4;
    int valence = abs(v[i].valence);
    int n = valence;
    int start = OsdReadQuadOffset(primitiveID, i, osdBuffers.quadOffsetBuffer) & 0xff;
    int prev = (OsdReadQuadOffset(primitiveID, i, osdBuffers.quadOffsetBuffer) >> 8) & 0xff;
    int start_m = OsdReadQuadOffset(primitiveID, im, osdBuffers.quadOffsetBuffer) & 0xff;
    int prev_p = (OsdReadQuadOffset(primitiveID, ip, osdBuffers.quadOffsetBuffer) >> 8) & 0xff;
    int np = abs(v[ip].valence);
    int nm = abs(v[im].valence);
    // Control Vertices based on :
    // "Approximating Subdivision Surfaces with Gregory Patches
    //  for Hardware Tessellation"
    // Loop, Schaefer, Ni, Castano (ACM ToG Siggraph Asia 2009)
    //
    //  P3         e3-      e2+         P2
    //     O--------O--------O--------O
    //     |        |        |        |
    //     |        |        |        |
    //     |        | f3-    | f2+    |
    //     |        O        O        |
    // e3+ O------O            O------O e2-
    //     |     f3+          f2-     |
    //     |                          |
    //     |                          |
    //     |      f0-         f1+     |
    // e0- O------O            O------O e1+
    //     |        O        O        |
    //     |        | f0+    | f1-    |
    //     |        |        |        |
    //     |        |        |        |
    //     O--------O--------O--------O
    //  P0         e0+      e1-         P1
    //
#if OSD_PATCH_GREGORY_BOUNDARY
    float3 Em_ip;
    if (v[ip].valence < -2) {
        int j = (np + prev_p - v[ip].zerothNeighbor) % np;
        Em_ip = v[ip].P + cospi(j/float(np-1))*v[ip].e0 + sinpi(j/float(np-1))*v[ip].e1;
    } else {
        Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p) + v[ip].e1*sinfn(np, prev_p);
    }
    float3 Ep_im;
    if (v[im].valence < -2) {
        int j = (nm + start_m - v[im].zerothNeighbor) % nm;
        Ep_im = v[im].P + cospi(j/float(nm-1))*v[im].e0 + sinpi(j/float(nm-1))*v[im].e1;
    } else {
        Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);
    }
    if (v[i].valence < 0) {
        n = (n-1)*2;
    }
    if (v[im].valence < 0) {
        nm = (nm-1)*2;
    }
    if (v[ip].valence < 0) {
        np = (np-1)*2;
    }
    if (v[i].valence > 2) {
        result.Ep = v[i].P + (v[i].e0*cosfn(n, start) + v[i].e1*sinfn(n, start));
        result.Em = v[i].P + (v[i].e0*cosfn(n, prev) +  v[i].e1*sinfn(n, prev));
        float s1=3-2*cosfn(n,1)-cosfn(np,1);
        float s2=2*cosfn(n,1);
        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
        s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));
        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;
    } else if (v[i].valence < -2) {
        int j = (valence + start - v[i].zerothNeighbor) % valence;
        result.Ep = v[i].P + cospi(j/float(valence-1))*v[i].e0 + sinpi(j/float(valence-1))*v[i].e1;
        j = (valence + prev - v[i].zerothNeighbor) % valence;
        result.Em = v[i].P + cospi(j/float(valence-1))*v[i].e0 + sinpi(j/float(valence-1))*v[i].e1;
        float3 Rp = ((-2.0f * v[i].org - 1.0f * v[im].org) + (2.0f * v[ip].org + 1.0f * v[(i+2)%4].org))/3.0f;
        float3 Rm = ((-2.0f * v[i].org - 1.0f * v[ip].org) + (2.0f * v[im].org + 1.0f * v[(i+2)%4].org))/3.0f;
        float s1 = 3-2*cosfn(n,1)-cosfn(np,1);
        float s2 = 2*cosfn(n,1);
        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
        s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));
        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;
        if (v[im].valence < 0) {
            s1 = 3-2*cosfn(n,1)-cosfn(np,1);
            result.Fp = result.Fm = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
        } else if (v[ip].valence < 0) {
            s1 = 3.0f-2.0f*cospi(2.0f/n)-cospi(2.0f/nm);
            result.Fm = result.Fp = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;
        }
    } else if (v[i].valence == -2) {
        result.Ep = (2.0f * v[i].org + v[ip].org)/3.0f;
        result.Em = (2.0f * v[i].org + v[im].org)/3.0f;
        result.Fp = result.Fm = (4.0f * v[i].org + v[(i+2)%n].org + 2.0f * v[ip].org + 2.0f * v[im].org)/9.0f;
    }
#else // not OSD_PATCH_GREGORY_BOUNDARY
    result.Ep = v[i].P + v[i].e0 * cosfn(n, start) + v[i].e1*sinfn(n, start);
    result.Em = v[i].P + v[i].e0 * cosfn(n, prev ) + v[i].e1*sinfn(n, prev );
    float3 Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p) + v[ip].e1*sinfn(np, prev_p);
    float3 Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);
    float s1 = 3-2*cosfn(n,1)-cosfn(np,1);
    float s2 = 2*cosfn(n,1);
    result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
    s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));
    result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em +s2*Ep_im - v[i].r[prev])/3.0f;
#endif
#endif  // OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
//   Copyright 2016 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
#ifndef OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H
#define OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H
#if defined(OSD_PATCH_BASIS_GLSL)
    #define OSD_FUNCTION_STORAGE_CLASS
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT out
    #define OSD_INOUT inout
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             elementType[](a0,a1,a2,a3,a4,a5,a6,a7)
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             elementType[](a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)
#elif defined(OSD_PATCH_BASIS_HLSL)
    #define OSD_FUNCTION_STORAGE_CLASS
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT out
    #define OSD_INOUT inout
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#elif defined(OSD_PATCH_BASIS_CUDA)
    #define OSD_FUNCTION_STORAGE_CLASS __device__
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#elif defined(OSD_PATCH_BASIS_OPENCL)
    #define OSD_FUNCTION_STORAGE_CLASS static
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#elif defined(OSD_PATCH_BASIS_METAL)
    #define OSD_FUNCTION_STORAGE_CLASS static
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) thread elementType* identifier
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#else
    #define OSD_FUNCTION_STORAGE_CLASS static inline
    #define OSD_DATA_STORAGE_CLASS static
    #define OSD_OPTIONAL(a) (a)
    #define OSD_OPTIONAL_INIT(a,b) (a ? b : 0)
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#endif
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBezierWeights(
    float t, OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP2, 4)) {
    // The four uniform cubic Bezier basis functions (in terms of t and its
    // complement tC) evaluated at t:
    float t2 = t*t;
    float tC = 1.0f - t;
    float tC2 = tC * tC;
    wP[0] = tC2 * tC;
    wP[1] = tC2 * t * 3.0f;
    wP[2] = t2 * tC * 3.0f;
    wP[3] = t2 * t;
    // Derivatives of the above four basis functions at t:
    if (OSD_OPTIONAL(wDP)) {
       wDP[0] = -3.0f * tC2;
       wDP[1] =  9.0f * t2 - 12.0f * t + 3.0f;
       wDP[2] = -9.0f * t2 +  6.0f * t;
       wDP[3] =  3.0f * t2;
    }
    // Second derivatives of the basis functions at t:
    if (OSD_OPTIONAL(wDP2)) {
        wDP2[0] =   6.0f * tC;
        wDP2[1] =  18.0f * t - 12.0f;
        wDP2[2] = -18.0f * t +  6.0f;
        wDP2[3] =   6.0f * t;
    }
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBSplineWeights(
    float t, OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP2, 4)) {
    // The four uniform cubic B-Spline basis functions evaluated at t:
    const float one6th = 1.0f / 6.0f;
    float t2 = t * t;
    float t3 = t * t2;
    wP[0] = one6th * (1.0f - 3.0f*(t -      t2) -      t3);
    wP[1] = one6th * (4.0f           - 6.0f*t2  + 3.0f*t3);
    wP[2] = one6th * (1.0f + 3.0f*(t +      t2  -      t3));
    wP[3] = one6th * (                                 t3);
    // Derivatives of the above four basis functions at t:
    if (OSD_OPTIONAL(wDP)) {
        wDP[0] = -0.5f*t2 +      t - 0.5f;
        wDP[1] =  1.5f*t2 - 2.0f*t;
        wDP[2] = -1.5f*t2 +      t + 0.5f;
        wDP[3] =  0.5f*t2;
    }
    // Second derivatives of the basis functions at t:
    if (OSD_OPTIONAL(wDP2)) {
        wDP2[0] = -       t + 1.0f;
        wDP2[1] =  3.0f * t - 2.0f;
        wDP2[2] = -3.0f * t + 1.0f;
        wDP2[3] =         t;
    }
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBoxSplineWeights(float v, float w, OSD_TYPE_ARRAY(OSD_OUT float, wP, 12)) {
    float u = 1.0f - v - w;
    //
    //  The 12 basis functions of the quartic box spline (unscaled by their common
    //  factor of 1/12 until later, and formatted to make it easy to spot any
    //  typing errors):
    //
    //      15 terms for the 3 points above the triangle corners
    //       9 terms for the 3 points on faces opposite the triangle edges
    //       2 terms for the 6 points on faces opposite the triangle corners
    //
    //  Powers of each variable for notational convenience:
    float u2 = u*u;
    float u3 = u*u2;
    float u4 = u*u3;
    float v2 = v*v;
    float v3 = v*v2;
    float v4 = v*v3;
    float w2 = w*w;
    float w3 = w*w2;
    float w4 = w*w3;
    //  And now the basis functions:
    wP[ 0] = u4 + 2.0f*u3*v;
    wP[ 1] = u4 + 2.0f*u3*w;
    wP[ 8] = w4 + 2.0f*w3*u;
    wP[11] = w4 + 2.0f*w3*v;
    wP[ 9] = v4 + 2.0f*v3*w;
    wP[ 5] = v4 + 2.0f*v3*u;
    wP[ 2] = u4 + 2.0f*u3*w + 6.0f*u3*v + 6.0f*u2*v*w + 12.0f*u2*v2 +
                v4 + 2.0f*v3*w + 6.0f*v3*u + 6.0f*v2*u*w;
    wP[ 4] = w4 + 2.0f*w3*v + 6.0f*w3*u + 6.0f*w2*u*v + 12.0f*w2*u2 +
                u4 + 2.0f*u3*v + 6.0f*u3*w + 6.0f*u2*v*w;
    wP[10] = v4 + 2.0f*v3*u + 6.0f*v3*w + 6.0f*v2*w*u + 12.0f*v2*w2 +
                w4 + 2.0f*w3*u + 6.0f*w3*v + 6.0f*w3*u*v;
    wP[ 3] = v4 + 6*v3*w + 8*v3*u + 36*v2*w*u + 24*v2*u2 + 24*v*u3 +
                w4 + 6*w3*v + 8*w3*u + 36*w2*v*u + 24*w2*u2 + 24*w*u3 + 6*u4 + 60*u2*v*w + 12*v2*w2;
    wP[ 6] = w4 + 6*w3*u + 8*w3*v + 36*w2*u*v + 24*w2*v2 + 24*w*v3 +
                u4 + 6*u3*w + 8*u3*v + 36*u2*v*w + 24*u2*v2 + 24*u*v3 + 6*v4 + 60*v2*w*u + 12*w2*u2;
    wP[ 7] = u4 + 6*u3*v + 8*u3*w + 36*u2*v*w + 24*u2*w2 + 24*u*w3 +
                v4 + 6*v3*u + 8*v3*w + 36*v2*u*w + 24*v2*w2 + 24*v*w3 + 6*w4 + 60*w2*u*v + 12*u2*v2;
    for (int i = 0; i < 12; ++i) {
        wP[i] *= 1.0f / 12.0f;
    }
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBilinearPatchWeights(
        float s, float t, float dScale,
        OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 4),
        OSD_TYPE_ARRAY(OSD_OUT float, wDss, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 4)) {
    float sC = 1.0f - s,
          tC = 1.0f - t;
    if (OSD_OPTIONAL(wP)) {
        wP[0] = sC * tC;
        wP[1] =  s * tC;
        wP[2] =  s * t;
        wP[3] = sC * t;
    }
    if (OSD_OPTIONAL(derivS && derivT)) {
        wDs[0] = -tC * dScale;
        wDs[1] =  tC * dScale;
        wDs[2] =   t * dScale;
        wDs[3] =  -t * dScale;
        wDt[0] = -sC * dScale;
        wDt[1] =  -s * dScale;
        wDt[2] =   s * dScale;
        wDt[3] =  sC * dScale;
        if (OSD_OPTIONAL(derivSS && derivST && derivTT)) {
            float d2Scale = dScale * dScale;
            for(int i=0;i<4;i++) {
                wDss[i] = 0;
                wDtt[i] = 0;
            }
            wDst[0] =  d2Scale;
            wDst[1] = -d2Scale;
            wDst[2] = -d2Scale;
            wDst[3] =  d2Scale;
        }
    }
OSD_FUNCTION_STORAGE_CLASS
void OsdAdjustBoundaryWeights(
        int boundary,
        OSD_TYPE_ARRAY(OSD_INOUT float, sWeights, 4), OSD_TYPE_ARRAY(OSD_INOUT float, tWeights, 4)) {
    if ((boundary & 1) != 0) {
        tWeights[2] -= tWeights[0];
        tWeights[1] += 2*tWeights[0];
        tWeights[0] = 0;
    }
    if ((boundary & 2) != 0) {
        sWeights[1] -= sWeights[3];
        sWeights[2] += 2*sWeights[3];
        sWeights[3] = 0;
    }
    if ((boundary & 4) != 0) {
        tWeights[1] -= tWeights[3];
        tWeights[2] += 2*tWeights[3];
        tWeights[3] = 0;
    }
    if ((boundary & 8) != 0) {
        sWeights[2] -= sWeights[0];
        sWeights[1] += 2*sWeights[0];
        sWeights[0] = 0;
    }
OSD_FUNCTION_STORAGE_CLASS
void OsdComputeTensorProductPatchWeights(float dScale, int boundary,
    OSD_TYPE_ARRAY(float, sWeights, 4), OSD_TYPE_ARRAY(float, tWeights, 4),
    OSD_TYPE_ARRAY(float, dsWeights, 4), OSD_TYPE_ARRAY(float, dtWeights, 4),
    OSD_TYPE_ARRAY(float, dssWeights, 4), OSD_TYPE_ARRAY(float, dttWeights, 4),
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 16),
    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 16)) {
    if (OSD_OPTIONAL(wP)) {
        // Compute the tensor product weight of the (s,t) basis function
        // corresponding to each control vertex:
        OsdAdjustBoundaryWeights(boundary, sWeights, tWeights);
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                wP[4*i+j] = sWeights[j] * tWeights[i];
            }
        }
    }
    if (OSD_OPTIONAL(derivS && derivT)) {
        // Compute the tensor product weight of the differentiated (s,t) basis
        // function corresponding to each control vertex (scaled accordingly):
        OsdAdjustBoundaryWeights(boundary, dsWeights, dtWeights);
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                wDs[4*i+j] = dsWeights[j] * tWeights[i] * dScale;
                wDt[4*i+j] = sWeights[j] * dtWeights[i] * dScale;
            }
        }
        if (OSD_OPTIONAL(derivSS && derivST && derivTT)) {
            // Compute the tensor product weight of appropriate differentiated
            // (s,t) basis functions for each control vertex (scaled accordingly):
            float d2Scale = dScale * dScale;
            OsdAdjustBoundaryWeights(boundary, dssWeights, dttWeights);
            for (int i = 0; i < 4; ++i) {
                for (int j = 0; j < 4; ++j) {
                    wDss[4*i+j] = dssWeights[j] * tWeights[i] * d2Scale;
                    wDst[4*i+j] = dsWeights[j] * dtWeights[i] * d2Scale;
                    wDtt[4*i+j] = sWeights[j] * dttWeights[i] * d2Scale;
                }
            }
        }
    }
OSD_FUNCTION_STORAGE_CLASS
void OsdGetBezierPatchWeights(
    float s, float t, float dScale,
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDS, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDT, 16),
    OSD_TYPE_ARRAY(OSD_OUT float, wDSS, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDST, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDTT, 16)) {
    float sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];
    OsdGetBezierWeights(s, OSD_OPTIONAL_INIT(wP, sWeights), OSD_OPTIONAL_INIT(wDS, dsWeights), OSD_OPTIONAL_INIT(wDSS, dssWeights));
    OsdGetBezierWeights(t, OSD_OPTIONAL_INIT(wP, tWeights), OSD_OPTIONAL_INIT(wDT, dtWeights), OSD_OPTIONAL_INIT(wDTT, dttWeights));
    OsdComputeTensorProductPatchWeights(dScale, /*boundary=*/0, sWeights, tWeights, dsWeights, dtWeights, dssWeights, dttWeights, wP, wDS, wDT, wDSS, wDST, wDTT);
OSD_FUNCTION_STORAGE_CLASS
void OsdGetBSplinePatchWeights(
    float s, float t, float dScale, int boundary,
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 16),
    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 16)) {
    float sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];
    OsdGetBSplineWeights(s, sWeights, OSD_OPTIONAL_INIT(wDS, dsWeights), OSD_OPTIONAL_INIT(wDSS, dssWeights));
    OsdGetBSplineWeights(t, tWeights, OSD_OPTIONAL_INIT(wDT, dtWeights), OSD_OPTIONAL_INIT(wDTT, dttWeights));
    OsdComputeTensorProductPatchWeights(dScale, boundary, sWeights, tWeights, dsWeights, dtWeights, dssWeights, dttWeights, wP, wDs, wDt, wDss, wDst, wDtt);
OSD_FUNCTION_STORAGE_CLASS
void OsdGetGregoryPatchWeights(
    float s, float t, float dScale,
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 20),
    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 20)) {
    //
    //  P3         e3-      e2+         P2
    //     15------17-------11--------10
    //     |        |        |        |
    //     |        |        |        |
    //     |        | f3-    | f2+    |
    //     |       19       13        |
    // e3+ 16-----18           14-----12 e2-
    //     |     f3+          f2-     |
    //     |                          |
    //     |                          |
    //     |      f0-         f1+     |
    // e0- 2------4            8------6 e1+
    //     |        3        9        |
    //     |        | f0+    | f1-    |
    //     |        |        |        |
    //     |        |        |        |
    //     O--------1--------7--------5
    //  P0         e0+      e1-         P1
    //
    //  Indices of boundary and interior points and their corresponding Bezier points
    //  (this can be reduced with more direct indexing and unrolling of loops):
    //
    OSD_DATA_STORAGE_CLASS const int boundaryGregory[12] = OSD_ARRAY_12(int, 0, 1, 7, 5, 2, 6, 16, 12, 15, 17, 11, 10 );
    OSD_DATA_STORAGE_CLASS const int boundaryBezSCol[12] = OSD_ARRAY_12(int, 0, 1, 2, 3, 0, 3,  0,  3,  0,  1,  2,  3 );
    OSD_DATA_STORAGE_CLASS const int boundaryBezTRow[12] = OSD_ARRAY_12(int, 0, 0, 0, 0, 1, 1,  2,  2,  3,  3,  3,  3 );
    OSD_DATA_STORAGE_CLASS const int interiorGregory[8] = OSD_ARRAY_8(int, 3, 4,  8, 9,  13, 14,  18, 19 );
    OSD_DATA_STORAGE_CLASS const int interiorBezSCol[8] = OSD_ARRAY_8(int, 1, 1,  2, 2,   2,  2,   1,  1 );
    OSD_DATA_STORAGE_CLASS const int interiorBezTRow[8] = OSD_ARRAY_8(int, 1, 1,  1, 1,   2,  2,   2,  2 );
    //
    //  Bezier basis functions are denoted with B while the rational multipliers for the
    //  interior points will be denoted G -- so we have B(s), B(t) and G(s,t):
    //
    //  Directional Bezier basis functions B at s and t:
    float Bs[4], Bds[4], Bdss[4];
    float Bt[4], Bdt[4], Bdtt[4];
    OsdGetBezierWeights(s, Bs, OSD_OPTIONAL_INIT(wDs, Bds), OSD_OPTIONAL_INIT(wDss, Bdss));
    OsdGetBezierWeights(t, Bt, OSD_OPTIONAL_INIT(wDt, Bdt), OSD_OPTIONAL_INIT(wDtt, Bdtt));
    //  Rational multipliers G at s and t:
    float sC = 1.0f - s;
    float tC = 1.0f - t;
    //  Use <= here to avoid compiler warnings -- the sums should always be non-negative:
    float df0 = s  + t;   df0 = (df0 <= 0.0f) ? 1.0f : (1.0f / df0);
    float df1 = sC + t;   df1 = (df1 <= 0.0f) ? 1.0f : (1.0f / df1);
    float df2 = sC + tC;  df2 = (df2 <= 0.0f) ? 1.0f : (1.0f / df2);
    float df3 = s  + tC;  df3 = (df3 <= 0.0f) ? 1.0f : (1.0f / df3);
    float G[8] = OSD_ARRAY_8(float, s*df0, t*df0,  t*df1, sC*df1,  sC*df2, tC*df2,  tC*df3, s*df3 );
    //  Combined weights for boundary and interior points:
    for (int i = 0; i < 12; ++i) {
        wP[boundaryGregory[i]] = Bs[boundaryBezSCol[i]] * Bt[boundaryBezTRow[i]];
    }
    for (int i = 0; i < 8; ++i) {
        wP[interiorGregory[i]] = Bs[interiorBezSCol[i]] * Bt[interiorBezTRow[i]] * G[i];
    }
    //
    //  For derivatives, the basis functions for the interior points are rational and ideally
    //  require appropriate differentiation, i.e. product rule for the combination of B and G
    //  and the quotient rule for the rational G itself.  As initially proposed by Loop et al
    //  though, the approximation using the 16 Bezier points arising from the G(s,t) has
    //  proved adequate (and is what the GPU shaders use) so we continue to use that here.
    //
    //  An implementation of the true derivatives is provided for future reference -- it is
    //  unclear if the approximations will hold up under surface analysis involving higher
    //  order differentiation.
    //
    if (OSD_OPTIONAL(wDs && wDt)) {
        bool find_second_partials = OSD_OPTIONAL(wDs && wDst && wDtt);
        //  Remember to include derivative scaling in all assignments below:
        float d2Scale = dScale * dScale;
        //  Combined weights for boundary points -- simple (scaled) tensor products:
        for (int i = 0; i < 12; ++i) {
            int iDst = boundaryGregory[i];
            int tRow = boundaryBezTRow[i];
            int sCol = boundaryBezSCol[i];
            wDs[iDst] = Bds[sCol] * Bt[tRow] * dScale;
            wDt[iDst] = Bdt[tRow] * Bs[sCol] * dScale;
            if (find_second_partials) {
                wDss[iDst] = Bdss[sCol] * Bt[tRow] * d2Scale;
                wDst[iDst] = Bds[sCol] * Bdt[tRow] * d2Scale;
                wDtt[iDst] = Bs[sCol] * Bdtt[tRow] * d2Scale;
            }
        }
        // dclyde's note: skipping half of the product rule like this does seem to change the result a lot in my tests.
        // This is not a runtime bottleneck for cloth sims anyway so I'm just using the accurate version.
#ifndef OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES
        //  Approximation to the true Gregory derivatives by differentiating the Bezier patch
        //  unique to the given (s,t), i.e. having F = (g^+ * f^+) + (g^- * f^-) as its four
        //  interior points:
        //
        //  Combined weights for interior points -- (scaled) tensor products with G+ or G-:
        for (int i = 0; i < 8; ++i) {
            int iDst = interiorGregory[i];
            int tRow = interiorBezTRow[i];
            int sCol = interiorBezSCol[i];
            wDs[iDst] = Bds[sCol] * Bt[tRow] * G[i] * dScale;
            wDt[iDst] = Bdt[tRow] * Bs[sCol] * G[i] * dScale;
            if (find_second_partials) {
                wDss[iDst] = Bdss[sCol] * Bt[tRow] * G[i] * d2Scale;
                wDst[iDst] = Bds[sCol] * Bdt[tRow] * G[i] * d2Scale;
                wDtt[iDst] = Bs[sCol] * Bdtt[tRow] * G[i] * d2Scale;
            }
        }
#else
        //  True Gregory derivatives using appropriate differentiation of composite functions:
        //
        //  Note that for G(s,t) = N(s,t) / D(s,t), all N' and D' are trivial constants (which
        //  simplifies things for higher order derivatives).  And while each pair of functions
        //  G (i.e. the G+ and G- corresponding to points f+ and f-) must sum to 1 to ensure
        //  Bezier equivalence (when f+ = f-), the pairs of G' must similarly sum to 0.  So we
        //  can potentially compute only one of the pair and negate the result for the other
        //  (and with 4 or 8 computations involving these constants, this is all very SIMD
        //  friendly...) but for now we treat all 8 independently for simplicity.
        //
        //float N[8] = OSD_ARRAY_8(float,    s,     t,      t,     sC,      sC,     tC,      tC,     s );
        float D[8] = OSD_ARRAY_8(float,  df0,   df0,    df1,    df1,     df2,    df2,     df3,   df3 );
        OSD_DATA_STORAGE_CLASS const float Nds[8] = OSD_ARRAY_8(float, 1.0f, 0.0f,  0.0f, -1.0f, -1.0f,  0.0f,  0.0f,  1.0f );
        OSD_DATA_STORAGE_CLASS const float Ndt[8] = OSD_ARRAY_8(float, 0.0f, 1.0f,  1.0f,  0.0f,  0.0f, -1.0f, -1.0f,  0.0f );
        OSD_DATA_STORAGE_CLASS const float Dds[8] = OSD_ARRAY_8(float, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f );
        OSD_DATA_STORAGE_CLASS const float Ddt[8] = OSD_ARRAY_8(float, 1.0f, 1.0f,  1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f );
        //  Combined weights for interior points -- (scaled) combinations of B, B', G and G':
        for (int i = 0; i < 8; ++i) {
            int iDst = interiorGregory[i];
            int tRow = interiorBezTRow[i];
            int sCol = interiorBezSCol[i];
            //  Quotient rule for G' (re-expressed in terms of G to simplify (and D = 1/D)):
            float Gds = (Nds[i] - Dds[i] * G[i]) * D[i];
            float Gdt = (Ndt[i] - Ddt[i] * G[i]) * D[i];
            //  Product rule combining B and B' with G and G' (and scaled):
            wDs[iDst] = (Bds[sCol] * G[i] + Bs[sCol] * Gds) * Bt[tRow] * dScale;
            wDt[iDst] = (Bdt[tRow] * G[i] + Bt[tRow] * Gdt) * Bs[sCol] * dScale;
            if (find_second_partials) {
                float Dsqr_inv = D[i]*D[i];
                float Gdss = 2.0f * Dds[i] * Dsqr_inv * (G[i] * Dds[i] - Nds[i]);
                float Gdst = Dsqr_inv * (2.0f * G[i] * Dds[i] * Ddt[i] - Nds[i] * Ddt[i] - Ndt[i] * Dds[i]);
                float Gdtt = 2.0f * Ddt[i] * Dsqr_inv * (G[i] * Ddt[i] - Ndt[i]);
                wDss[iDst] = (Bdss[sCol] * G[i] + 2.0f * Bds[sCol] * Gds + Bs[sCol] * Gdss) * Bt[tRow] * d2Scale;
                wDst[iDst] = (Bt[tRow] * (Bs[sCol] * Gdst + Bds[sCol] * Gdt) + Bdt[tRow] * (Bds[sCol] * G[i] + Bs[sCol] * Gds)) * d2Scale;
                wDtt[iDst] = (Bdtt[tRow] * G[i] + 2.0f * Bdt[tRow] * Gdt + Bt[tRow] * Gdtt) * Bs[sCol] * d2Scale;
            }
        }
#endif
    }
#endif /* OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H */
#define OSD_PATCH_LINES 1
#define OSD_PATCH_TRIANGLES 1
#define OSD_PATCH_QUADS 1
#define OSD_PATCH_BSPLINE 1
#define OSD_PATCH_REGULAR 1
#define OSD_PATCH_GREGORY 1
#define OSD_PATCH_GREGORY_BOUNDARY 1
#define OSD_PATCH_GREGORY_BASIS 1
GetPatchTypeDefine
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/osd/mtlPatchShaderSource.mm
"Unknown Far::PatchDescriptor::Type" && 0
GetPatchTypeSource
#line 0 "osd/mtlPatchBSpline.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.BSpline.Hull
//----------------------------------------------------------
static void OsdComputePerVertex(
float4 vertexPosition,
    threadgroup HullVertex& hullVertex,
    int vertexId,
    float4x4 ModelViewProjectionMatrix,
    OsdPatchParamBufferSet osdBuffers
    )
    hullVertex.position = vertexPosition;
#if OSD_ENABLE_PATCH_CULL
    float4 clipPos = mul(ModelViewProjectionMatrix, vertexPosition);   
    short3 clip0 = short3(clipPos.x < clipPos.w,                    
    clipPos.y < clipPos.w,                    
    clipPos.z < clipPos.w);                   
    short3 clip1 = short3(clipPos.x > -clipPos.w,                   
    clipPos.y > -clipPos.w,                   
    clipPos.z > -clipPos.w);                  
    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);              
#endif
    
    OSD_USER_VARYING_PER_CONTROL_POINT(osdBuffers.vertexBuffer[vertexId], hullVertex);
//----------------------------------------------------------
// Patches.BSpline.Factors
//----------------------------------------------------------
static void OsdComputePerPatchBSplineFactors(
    int3 patchParam,
    float tessLevel,
    float4x4 projectionMatrix,
    float4x4 modelViewMatrix,
    device OsdPerPatchVertexBezier* patch
#if !USE_PTVS_FACTORS
    ,device OsdPerPatchTessFactors& patchFactors
#endif
    ,device MTLQuadTessellationFactorsHalf& quadFactors
    float4 tessLevelOuter = float4(0,0,0,0);
    float2 tessLevelInner = float2(0,0);
    float4 tessOuterLo = float4(0,0,0,0);
    float4 tessOuterHi = float4(0,0,0,0);
#if OSD_ENABLE_SCREENSPACE_TESSELLATION
    OsdGetTessLevelsAdaptiveLimitPoints(
        tessLevel, 
        projectionMatrix, 
        modelViewMatrix,
        patch,
        patchParam,
        tessLevelOuter,
        tessLevelInner,
        tessOuterLo,
        tessOuterHi
        );
#else
    OsdGetTessLevelsUniform(
        tessLevel, 
        patchParam, 
        tessLevelOuter,
        tessLevelInner,
        tessOuterLo,
        tessOuterHi
        );
#endif
    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];
    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];
    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];
    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];
    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];
    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];
#if !USE_PTVS_FACTORS
    patchFactors.tessOuterLo = tessOuterLo;
    patchFactors.tessOuterHi = tessOuterHi;
#endif
static void OsdComputePerPatchFactors(
int3 patchParam,
float tessLevel,
unsigned patchID,
float4x4 projectionMatrix,
float4x4 modelViewMatrix,
OsdPatchParamBufferSet osdBuffer,
threadgroup PatchVertexType* patchVertices,
device MTLQuadTessellationFactorsHalf& quadFactors
OsdComputePerPatchBSplineFactors(
patchParam, 
tessLevel, 
projectionMatrix, 
modelViewMatrix, 
osdBuffer.perPatchVertexBuffer + patchID * CONTROL_POINTS_PER_PATCH,
#if !USE_PTVS_FACTORS
osdBuffer.patchTessBuffer[patchID],
#endif
quadFactors
//----------------------------------------------------------
// Patches.BSpline.Vertex
//----------------------------------------------------------
static void OsdComputePerPatchVertex(
int3 patchParam, 
unsigned ID, 
unsigned PrimitiveID, 
unsigned ControlID,
threadgroup PatchVertexType* patchVertices,
OsdPatchParamBufferSet osdBuffers
OsdComputePerPatchVertexBSpline(patchParam, ID, patchVertices, osdBuffers.perPatchVertexBuffer[ControlID]);
    
    OSD_USER_VARYING_PER_VERTEX(patchVertices[ID], osdBuffers.perPatchVertexBuffer[ControlID]);
//----------------------------------------------------------
// Patches.BSpline.Domain
//----------------------------------------------------------
template<typename PerPatchVertexBezier>
static OsdPatchVertex ds_regular_patches(
    const float TessLevel,
#if !USE_PTVS_FACTORS
    float4 tessOuterHi,
    float4 tessOuterLo,
#endif
    PerPatchVertexBezier cv,
    int3 patchParam,
    float2 domainCoord)
    OsdPatchVertex output;
    float3 P, dPu, dPv;
    float3 N, dNu, dNv;
    float2 vSegments;
#if !USE_PTVS_FACTORS
    float2 UV = OsdGetTessParameterization(domainCoord,
                                           tessOuterLo,
                                           tessOuterHi);
#else
    auto transitionMask = OsdGetPatchTransitionMask(patchParam);
    float4 tessLevelMin = float4(1)
    + float4(((transitionMask & 8) >> 3),
             ((transitionMask & 1) >> 0),
             ((transitionMask & 2) >> 1),
             ((transitionMask & 4) >> 2));
    float2 UV = OsdGetTessParameterization(domainCoord,
                                           tessLevelMin,
                                           float4(0));
#endif
    OsdEvalPatchBezier(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv, vSegments);
    output.normal = N;
    output.tangent = dPu;
    output.bitangent = dPv;
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    output.Nu = dNu;
    output.Nv = dNv;
#endif
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    output.vSegments = vSegments;
#endif
    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);
    output.position = P;
    
    OSD_USER_VARYING_PER_EVAL_POINT(UV, cv[5], cv[6], cv[9], cv[10], output);
    
    return output;
#if USE_STAGE_IN
template<typename PerPatchVertexBezier>
#endif
static OsdPatchVertex OsdComputePatch(
float tessLevel,
float2 domainCoord,
unsigned patchID,
#if USE_STAGE_IN
PerPatchVertexBezier osdPatch
#else
OsdVertexBufferSet osdBuffers
#endif
return ds_regular_patches(
tessLevel,
#if !USE_PTVS_FACTORS
#if USE_STAGE_IN
osdPatch.tessOuterHi,
osdPatch.tessOuterLo,
#else
osdBuffers.patchTessBuffer[patchID].tessOuterHi,
osdBuffers.patchTessBuffer[patchID].tessOuterLo,
#endif
#endif
#if USE_STAGE_IN
osdPatch.cv,
osdPatch.patchParam,
#else
osdBuffers.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,
osdBuffers.patchParamBuffer[patchID],
#endif
domainCoord
#line 0 "osd/mtlPatchGregory.metal"
//   Copyright 2013 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.Gregory.Hull
//----------------------------------------------------------
void OsdComputePerVertex(
float4 position,
    threadgroup OsdPerVertexGregory& hullVertex,
    int vertexId,
    float4x4 modelViewProjectionMatrix,
    OsdPatchParamBufferSet osdBuffers
    )
OsdComputePerVertexGregory(vertexId, position.xyz, hullVertex, osdBuffers);
#if OSD_ENABLE_PATCH_CULL
    float4 clipPos = mul(modelViewProjectionMatrix, position);    
    short3 clip0 = short3(clipPos.x < clipPos.w,                    
    clipPos.y < clipPos.w,                    
    clipPos.z < clipPos.w);                   
    short3 clip1 = short3(clipPos.x > -clipPos.w,                   
    clipPos.y > -clipPos.w,                   
    clipPos.z > -clipPos.w);                  
    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);
#endif
    
    OSD_USER_VARYING_PER_CONTROL_POINT(osdBuffers.vertexBuffer[vertexId], hullVertex);
//----------------------------------------------------------
// Patches.Gregory.Factors
//----------------------------------------------------------
void OsdComputePerPatchFactors(
int3 patchParam,
float tessLevel,
unsigned patchID,
float4x4 projectionMatrix,
float4x4 modelViewMatrix,
OsdPatchParamBufferSet osdBuffer,
threadgroup PatchVertexType* patchVertices,
device MTLQuadTessellationFactorsHalf& quadFactors
    float4 tessLevelOuter = float4(0,0,0,0);
    float2 tessLevelInner = float2(0,0);
OsdGetTessLevels(
tessLevel, 
projectionMatrix, 
modelViewMatrix,
patchVertices[0].P, 
patchVertices[3].P, 
patchVertices[2].P, 
patchVertices[1].P,
patchParam, 
tessLevelOuter, 
tessLevelInner
    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];
    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];
    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];
    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];
    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];
    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];
//----------------------------------------------------------
// Patches.Gregory.Vertex
//----------------------------------------------------------
void OsdComputePerPatchVertex(
int3 patchParam, 
unsigned ID, 
unsigned PrimitiveID, 
unsigned ControlID,
threadgroup PatchVertexType* patchVertices,
OsdPatchParamBufferSet osdBuffers
OsdComputePerPatchVertexGregory(
patchParam,
PrimitiveID,
patchVertices,
osdBuffers.perPatchVertexBuffer[ControlID],
osdBuffers);
    
    OSD_USER_VARYING_PER_VERTEX(patchVertices[ID], osdBuffers.perPatchVertexBuffer[ControlID]);
//----------------------------------------------------------
// Patches.Gregory.Domain
//----------------------------------------------------------
template<typename PerPatchVertexGregory>
static OsdPatchVertex ds_gregory_patches(
                     PerPatchVertexGregory patch,
                     int3 patchParam,
                     float2 UV
                    )
    OsdPatchVertex output;
    
    float3 P = float3(0,0,0), dPu = float3(0,0,0), dPv = float3(0,0,0);
    float3 N = float3(0,0,0), dNu = float3(0,0,0), dNv = float3(0,0,0);
    
    float3 cv[20];
    cv[0] = patch[0].P;
    cv[1] = patch[0].Ep;
    cv[2] = patch[0].Em;
    cv[3] = patch[0].Fp;
    cv[4] = patch[0].Fm;
    
    cv[5] = patch[1].P;
    cv[6] = patch[1].Ep;
    cv[7] = patch[1].Em;
    cv[8] = patch[1].Fp;
    cv[9] = patch[1].Fm;
    
    cv[10] = patch[2].P;
    cv[11] = patch[2].Ep;
    cv[12] = patch[2].Em;
    cv[13] = patch[2].Fp;
    cv[14] = patch[2].Fm;
    
    cv[15] = patch[3].P;
    cv[16] = patch[3].Ep;
    cv[17] = patch[3].Em;
    cv[18] = patch[3].Fp;
    cv[19] = patch[3].Fm;
    
    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);
    
    // all code below here is client code
    output.position = P;
    output.normal = N;
    output.tangent = dPu;
    output.bitangent = dPv;
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    output.Nu = dNu;
    output.Nv = dNv;
#endif
    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);
    
    OSD_USER_VARYING_PER_EVAL_POINT(UV, patch[0], patch[1], patch[3], patch[2], output);
    return output;
#if USE_STAGE_IN
template<typename PerPatchVertexGregoryBasis>
#endif
static OsdPatchVertex OsdComputePatch(
float tessLevel,
float2 domainCoord,
unsigned patchID,
#if USE_STAGE_IN
PerPatchVertexGregoryBasis osdPatch
#else
    OsdVertexBufferSet osdBuffers
#endif
return ds_gregory_patches(
#if USE_STAGE_IN
osdPatch.cv,
osdPatch.patchParam,
#else
        osdBuffers.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,
        osdBuffers.patchParamBuffer[patchID],
#endif
domainCoord);
#line 0 "osd/mtlPatchGregoryBasis.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.GregoryBasis.Hull
//----------------------------------------------------------
void OsdComputePerVertex(
float4 position,
    threadgroup HullVertex& hullVertex,
    int vertexId,
    float4x4 modelViewProjectionMatrix,
    OsdPatchParamBufferSet osdBuffers
    )
hullVertex.position = position;
#if OSD_ENABLE_PATCH_CULL
    float4 clipPos = mul(modelViewProjectionMatrix, position);    
    short3 clip0 = short3(clipPos.x < clipPos.w,                    
    clipPos.y < clipPos.w,                    
    clipPos.z < clipPos.w);                   
    short3 clip1 = short3(clipPos.x > -clipPos.w,                   
    clipPos.y > -clipPos.w,                   
    clipPos.z > -clipPos.w);                  
    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);              
#endif
    
    OSD_USER_VARYING_PER_CONTROL_POINT(osdBuffers.vertexBuffer[vertexId], hullVertex);
//----------------------------------------------------------
// Patches.GregoryBasis.Factors
//----------------------------------------------------------
void OsdComputePerPatchFactors(
int3 patchParam,
float tessLevel,
unsigned patchID,
float4x4 projectionMatrix,
float4x4 modelViewMatrix,
OsdPatchParamBufferSet osdBuffer,
threadgroup PatchVertexType* patchVertices,
device MTLQuadTessellationFactorsHalf& quadFactors
    float4 tessLevelOuter = float4(0,0,0,0);
    float2 tessLevelInner = float2(0,0);
OsdGetTessLevels(
tessLevel, 
projectionMatrix, 
modelViewMatrix,
patchVertices[0].position.xyz, 
patchVertices[3].position.xyz, 
patchVertices[2].position.xyz, 
patchVertices[1].position.xyz,
patchParam, 
tessLevelOuter, 
tessLevelInner
    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];
    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];
    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];
    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];
    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];
    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];
//----------------------------------------------------------
// Patches.GregoryBasis.Vertex
//----------------------------------------------------------
void OsdComputePerPatchVertex(
int3 patchParam, 
unsigned ID, 
unsigned PrimitiveID, 
unsigned ControlID,
threadgroup PatchVertexType* patchVertices,
OsdPatchParamBufferSet osdBuffers
//Does nothing, all transforms are in the PTVS
    OSD_USER_VARYING_PER_VERTEX(patchVertices[ID], osdBuffers.perPatchVertexBuffer[ControlID]);
//----------------------------------------------------------
// Patches.GregoryBasis.Domain
//----------------------------------------------------------
#define USE_128BIT_GREGORY_BASIS_INDICES_READ 1
#if USE_STAGE_IN
template<typename PerPatchVertexGregoryBasis>
#endif
static OsdPatchVertex ds_gregory_basis_patches(
#if USE_STAGE_IN
                     PerPatchVertexGregoryBasis patch,
#else
                     const device OsdInputVertexType* patch,
                     const device unsigned* patchIndices,
#endif
                     int3 patchParam,
                     float2 UV
                     )
    OsdPatchVertex output;
    float3 P = float3(0,0,0), dPu = float3(0,0,0), dPv = float3(0,0,0);
    float3 N = float3(0,0,0), dNu = float3(0,0,0), dNv = float3(0,0,0);
#if USE_STAGE_IN
    float3 cv[20];
    for(int i = 0; i < 20; i++)
        cv[i] = patch[i].position;
#else   
#if USE_128BIT_GREGORY_BASIS_INDICES_READ
    float3 cv[20];
    for(int i = 0; i < 5; i++) {
        int4 indices = ((device int4*)patchIndices)[i];
        
        int n = i * 4;
        cv[n + 0] = (patch + indices[0])->position;
        cv[n + 1] = (patch + indices[1])->position;
        cv[n + 2] = (patch + indices[2])->position;
        cv[n + 3] = (patch + indices[3])->position;
    }
#else
    float3 cv[20];
    for (int i = 0; i < 20; ++i) {
        cv[i] = patch[patchIndices[i]].position;
    }
#endif
#endif
    
    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);
    
    output.position = P;
    output.normal = N;
    output.tangent = dPu;
    output.bitangent = dPv;
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    output.Nu = dNu;
    output.Nv = dNv;
#endif
    
    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);
    
#if USE_STAGE_IN
    OSD_USER_VARYING_PER_EVAL_POINT(UV, patch[0], patch[5], patch[15], patch[10], output);
#else
    OSD_USER_VARYING_PER_EVAL_POINT(UV, patch[patchIndices[0]], patch[patchIndices[5]], patch[patchIndices[15]], patch[patchIndices[10]], output);
#endif
    
    return output;
#if USE_STAGE_IN
template<typename PerPatchVertexGregoryBasis>
#endif
static OsdPatchVertex OsdComputePatch(
float tessLevel,
float2 domainCoord,
unsigned patchID,
#if USE_STAGE_IN
PerPatchVertexGregoryBasis osdPatch
#else
OsdVertexBufferSet osdBuffers
#endif
return ds_gregory_basis_patches(
#if USE_STAGE_IN
osdPatch.cv,
osdPatch.patchParam,
#else
osdBuffers.vertexBuffer,
osdBuffers.indexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,
osdBuffers.patchParamBuffer[patchID],
#endif
domainCoord
EndCapBSplineBasisPatchFactory
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/endCapBSplineBasisPatchFactory.cpp
computeLimitStencils
(ringSize & 1) == 0
start > -1 && prev > -1
AddWithWeight
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/../far/gregoryBasis.h
_size < (int)_stencils.GetSize()
operator=
_size <= (int)_stencils.GetSize()
EndCapGregoryBasisPatchFactory
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/endCapGregoryBasisPatchFactory.cpp
GetPatchPoints
fedges.size()==4
aedge!=Vtr::INDEX_INVALID
adjPatchIndex>=0 && adjPatchIndex<(int)_levelAndFaceIndices.size()
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/vtr/quadRefinement.cpp
_splitType == Sdc::SPLIT_TO_QUADS
initializeInventory
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/topologyRefiner.cpp
_levels.size() == 1
Failure in TopologyRefiner::RefineUniform() -- base level is uninitialized.
Failure in TopologyRefiner::RefineUniform() -- previous refinements already applied.
Failure in TopologyRefiner::RefineAdaptive() -- base level is uninitialized.
Failure in TopologyRefiner::RefineAdaptive() -- previous refinements already applied.
Failure in TopologyRefiner::RefineAdaptive() -- currently only supported for Catmark scheme.
doesFaceHaveDistinctFaceVaryingFeatures
!level.doesFaceFVarTopologyMatch(face, fvarChannel)
getQuadOffsets
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/libOsd/sources/opensubdiv/far/endCapLegacyGregoryPatchFactory.cpp
thisFaceInVFaces != -1
Edge %d specified to be sharp does not exist (%d, %d)
Vertex %d specified to be sharp does not exist
OSD VertexBuffer
getInfo
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/AnimCodec/private/AnimDecoder.cpp
headerSizeInBytes == HeaderSizeInBytes
incrementNeighborCount
/Library/Caches/com.apple.xbs/Sources/SceneKit_Sim/SceneKit-556/lib/AnimCodec/public/AnimCodec.h
i < int32_t(_neighborCount.size())
addNeighbor
_neighborCount[i] < maxNeighborCount(i)
maxNeighborCount
neighborsStartIndex
neighborsEndIndex
Error: C3DMeshCreateTextFrame: C3DTextFrameRef object is NULL, will create NULL mesh
Error: type for key %@ is switching from %@ to %@, this will lead to improper animation
Error: unabled to create a read stream at %@
Error: failed to load %@ - unknown file format.
Error: COLLADA files are not supported on this platform.
Error: no file found at URL %@
Error: ParticleSystem: mismatch in meshes and meshElements
Error: Color deserialize: could not read the float array
Error: Color deserialize: no color or no deserialized data
Error: Geometry deserialization: cannot find the mesh ID
Error: Geometry deserialization: cannot find the specified mesh
Error: Geometry deserialization: cannot find the specified material
Warning: _C3DGeometryFinalizeDeserialization - material ID of 0 is unexpected
Error: cannot generate points : mismatch between vertices and normals count
Error: Cannot use volume generation on a generic mesh. fallbacking on surface
Error: Could not deserialize the property %@ in the serialized effect %@
Error: C3DImageToMDLTexture not supported for image 3D
Warning: Failed to create cubemap from Model I/O texture
Warning: Warning: unable to flip non-float2 texture coordinates, skipping
Error: unknown MKGeometryType
Error: a MDLObject has more than 1 child mesh - not supported
Error: failed to find MKMaterial corresponding SCNMaterial
Error: Unknown Model I/O semantic %@
Error: No point of view set for tone mapping pass
Error: No camera set for tone mapping pass
Error: C3DMeshElementCreateByMergingElements - strip not supported
Error: C3DMeshElementCreateByMergingElements - merging elements with different byte per index
Warning: %s does not support non-renderable topologies.
Error: C3DMeshElementGetIndexCount:primitive type not handled
Error: unexpected vertex count
Error: Mesh element deserialization: no faces count
Error: Mesh element deserialization: no mesh element type
Error: Mesh element deserialization: no bytes per index
Error: Could not read the indexes
Error: Mesh element deserialization: no serialized indices
Warning: Unknown mesh element type %@, assuming triangles array.
Error: C3DMeshElementSetPrimitives invalid index buffer size
Error: __readIndexInBuffer - index (%u) out of bounds (%lu)
Warning: unlock not locked ressource
Error: C3DMeshSubdivide inconsistency
Warning: try to preload a geometry with no mesh
Error: WARNING: NULL data in mesh source (warming geometry)
Error: Cannot generate tangents without valid positions
Error: Cannot generate valid tangents without valid texture coordinates
Error: Cannot generate valid tangents without valid normals
Error: invalid geometry detected - skip C3DCreateTangentsWithGeometryOptimized
Error: target mesh has a different number of vertices (%d != %d)
Error: Cannot generate tangents without positions
Error: Cannot generate tangents without texture coordinates
Error: error in C3DMeshCreateTangentsIfNeeded
Warning: Cannot create an interleaved copy, count mismatch
Error: Given sources must be of the same length for interval list creation
Warning: __MergeMeshSources unknown source type
Error: C3DSourceAccessorCopyDataToAccessor failed
Warning: C3DUnifyNormalsFromGeometry can only process triangles and polygons
Warning: C3DUnifyNormalsFromGeometry empty indices
Error: DeferredShadowPass Setup - no light
Error: _willExecuteDeferredShadows - no light
Error: failed to load audio source at %@
Error: can't archive audio data directly
Error: OSD_MAX_VALENCE is set to %d and current mesh has a max valence of %d
Error: SCNTextureCoreAnimationSource::textureProxy -> no layer
Error: inconsistency in lru list
Error: inconsistency in lru list (2)
Welcome to SceneKit 557.1 (Oct  7 2020 02:26:12)
Warning: Mesh malformed : missing semantic "%@" in morph target "%@" of "%@"
Assertion failed [sparseVertexCount == tgt->vectorCount] target buffer is incorrectly sized
Error: Skinned mesh has vertex count == 0
Error: _metalMeshForGPUComputeSkinMorph: was unable to generate tangents
Error: can't share a SCNPhysicsField is already attached to a SCNNode
Error: object %@ doesn't conform to the copying protocol
Error: invalid ref count for entity %@
Error: didAddToPhysicsWorld - can't share a physics behavior to multiple world
Error: Authoring pass can't find input depth pass.
Error: Unsupported draw instruction kC3DFXDrawGeometry
Error: Unsupported draw instruction kC3DFXDrawMetalCustom
Error: C3DEngineContextRenderTechnique - unknown draw instruction
Error: SCNTextureSpriteKitSource::textureProxy -> no scene
Warning: SCNTextureSource unexpected SKScene
Error: Morph: target vertex count do not match base vertex count (%d != %d)
Error: MeshSource packing only supports non interleaved float sources
Error: Conversion from other types than float is not supported
Error: Conversion of an interleaved source is not supported, please convert your sources before interleaving
Error: C3DMeshSourceCreateCopyWithComponentsBaseType: unsupported type
Error: Conversion from %@ to %@ to is not supported
Error: no meshSource deserialize => semantic in mesh source
Error: _C3DMeshSourceCopyPropertyList unsupported semantic
Warning: fail to setup the animation - won't be added to the animation stack
Error: Binding: Unable to resolve destination keypath: %@(%@)
Error: Binding: Trying to bind two incompatible keypaths: %@(%@) -> %@(%@)
Error: _resolveAnimationGroupTargets - can't find common ancessor
Error: C3DKeyframeControllerSetKeyframeAtIndex - time is NaN
Error: C3DKeyframeControllerRef - index out of bounds
Warning: can't simplify keyframes because of cubic interpolation
Warning: can't simplify keyframes because of tcb values
Warning: can't simplify keyframes because of timing functions
Error: failed to deserialize animation data
Error: _C3DKeyframeControllerFlattenKeyframeData unexpected value
Error: _C3DKeyframeControllerCreateKeyframeArray unknown key type
Warning: _C3DKeyDistance - can't compute key distance for type %d
Error: SCNMTLResourceManager initWithDevice : cannot create a command queue. Bailing out.
Error: missing value for attachment "%@" [vertex: %d fragment: %d]
Error: incorrect buffer size  for attachments vertex [%d] fragments [%d]. Expected:%d Provided:%d
Error: Argument '%@' : failed to write value to Metal buffer (%@)
Error: Argument '%@' : mismatch between the NSData and the buffer size %ld != %ld
Error: Argument '%@' : only NSData and NSValue are supported for shadable value storage. Please make sure that your custom shader modifier uniform types match the custom properties of the shadable object
Warning: Missing texture value for %@
Error: format %@ not convertible to MTLVertexFormat
Error: Can't add dependency %s on %s
Error: ** Cycle detected ** involving pass %s and input pass %s
Error: Pass %s has an unresolved dependency on input port %d with pass %s. Pass %s will be ignored
Error: Pass %s has an unresolved dependency from output port %d of pass %s. Pass %s will be ignored
Error: Pass %s has an unresolved dependency with pass %s. Pass %s will be ignored
Error: Pass %s is not linked to the rendering graph and will be ignored check it's input/output
Error: ReadWrite pass %s require input %zu:%s with load mode set to "Load", forcing it.
Error: ReadWrite pass %s must have compatible input/output.
Error: Input %s doesn't match output %s.
Error: Invalid output texture sampleCount %d for pass %s %d:%s, if no multisample needed, set it to 0
Error: Invalid input texture sampleCount %d for pass %s %d:%s, if no multisample needed, set it to 0
Error: Invalid output parameter for pass %s
Error: Invalid output parameters for port %d: %s
Error: Invalid input parameter for pass %s
Error: Buffer input parameters for port %d: %s
Error: Compatibility missmatch between %s and %s
Error: Output buffer parameters for port %d isn't compatible with input port %d
Error: Output descriptor of pass %s at port %d: %s
Error: Input descriptor of pass %s at port %d: %s
Error: Unresolved dependency between %s and %s
Error: ReadWrite pass %s can't be the present on first stage since it will load it's input.
Error: Resource allocated for output index %d:%s but resource is tagged as "used internally"
Error: Dependency issue between source %s[%d]:%s and destination %s[%d]:%s
Error: Types missmatch %s <-> %s
Error: Texture width missmatch %hu <-> %hu
Error: Texture height missmatch %hu <-> %hu
Error: Texture depth missmatch %hu <-> %hu
Error: Texture type missmatch %@ <-> %@
Error: Texture storage mode missmatch %@ <-> %@
Error: Texture CPU cache mode missmatch %@ <-> %@
Error: Texture pixel format missmatch %@ <-> %@
Error: Texture mipmap count missmatch %d <-> %d
Error: Buffers have different length %lu <-> %lu
Info: |%s%s|width|height|depth|        pixelFormat      |arrayLength|storageMode|usage|cpuCacheMo|mipmapCount|sampleCount|usedForRes|         textureType      |
Info: |%s%s|%5d|%6d|%5d|%25s|%11d|%11d|%5d|%10d|%11d|%11d|%10d|%26s|
Info: |%s%slength : %lu
Info: |%stype : INVALID
Info: |%s%s|type|clearColor R|   G|   B|   A|attachmentType|loadMode|dispatchToOutput|usedInternally|registerTexture|registerResolveT|specificClearCol|readWrite|persistent|
Info: |%s%s|%4hhu|%12.1f|%4.1f|%4.1f|%4.1f|%14hhu|%8hhu|%16d|%14d|%15d|%16d|%16d|%9d|%10d|
Info: ###########################################################################################################
Info: ################################################ NEW FRAME ################################################
Info: ###########################################################################################################
Info: ######################################## STAGE %d ########################################
Info: |---------------------------  %s ---------------------------
Info: |---- %d INPUTS ---- 
Info: |
Info: |---- %d OUTPUTS ---- 
Info: |-> %s ( %s )
Info: |----------------------------%s----------------------------
Info: 
Info: 
Error: C3DFXTechniqueAppendPass out of capacity
Error: C3DFXTechniqueSetValueForSymbol - expect an image for paramName %@
Error: C3DFXTechniqueSetValueForSymbol - unknown param named %@
Error: C3DFXTechniqueGetValueForSymbol - unknown param named %@
Error: invalue description for input named %@ - expect a dictionary
Error: C3DFXTechniqueCompile - invalid description (sequence missing or empty) %@
Info: pass named %@ appears to be useless - skipping
Warning: Unknown render buffer format %hhu
Error: C3DES2SlotToAttachmentID : unknown slot
Error: _C3DKeyframedAnimationInitWithPropertyList serializedData invalid
Error: _C3DKeyframedAnimationInitWithPropertyList plist invalid
Error: can't set a property (%s::%d) on the presentation instance %@ - ignoring
Error: attempt to add a null animation player on %@
Error: attempt to add a null animation on %@
Error: _applyCIFilter can't fint render target named SceneKit-CI-nodetree-color
Warning: CIFilter should have been clipped by the culling
Warning: CIFilter should have been clipped by the culling (2)
Warning: changing the content of a physics shape is not expected
Info: Non triangle list element type not yet supported in physics shape generation
Error: vertex format not supported for physics shape creation (%d)
Warning: Cannot create convex hull for entity %@
Error: Compound shapes cannot be created without shapes
Warning: SCNPhysicsShape does not support a SCNCone with TopRadius != 0.0
Warning: Physics shape construction does not support meshes with positions value type different from double or float. (%d)
Error: Failed to create Metal pixel format for %@ [%d components, %d bits per component, bitmap info: %u (%@|%@), float components: %@, color space: %@]
Warning: unsupported texture type %d
Warning: C3DValueWriteToMTLData - Unsupported data type %@
Warning: value unsupported %d of member %@
Error: Unexpected pixel format %lu
Error: Cannot build cubemap from array of images because image at index %d is NULL
Error: Cannot build cubemap from array of images because image at index %d is not square: %fx%f
Error: Cannot build cubemap from array of images because image at index %d (%fx%f) does not have the expected size (%zux%zu)
Error: Cannot build cubemap from array of images because conversion to CGImageRef of image at index %d failed
Error: Cannot build column cubemap from non-cubemap image
Warning: Failed to create bitmap context for CG image %@
Error: failed to map image data for image inside %@
Error: failed to resolve image inside %@
Error: failed to create a CGBitmapContext from a CGImage for %@
Info: FixIncorrectPremultiply %@ time %u x %u : %fms
Error: Unknown cubemap image type
Error: Cannot support rotation layout for compressed texture
Error: Unknown Texture3D image type
Error: failed to load image with description: %@
Error: _C3DImageCopyPropertyList error retrieving path
Error: Failed to load %@
Error: unable to get a CGImageRef from image
Warning: While reading a texture sampler: could not read %@ (serializedData: %@), using the default value %d instead
Error: Could not serialize an integer
Info: Reload Shaders
Warning: Character should already have a body
Warning: KTX file seems too small or is not a KTX
Error: Only big endian ktx are supported
Error: Only compressed ktx are supported
Error: Unsupported format in KTX file
Warning: Compression type %d not supported
Error: overflow reading slice[%d] / mip[%d] (%d > %d)
Error: C3DRendererContextSetupResidentMeshSourceAtLocation - double not supported
Error: C3DRendererContextSetupResidentMeshSourceAtLocation:not handling type, using float as default
Error: C3DRendererContextCreateProgramObjectForProgram : missing vertex shader
Error: C3DRendererContextCreateProgramObjectForProgram : missing fragment shader
Error: C3DRendererContextCreateProgramObjectForProgram metal program unsupported
Error: C3DRendererContextCreateProgramObjectForProgram unsupported program
Warning: Trying to delete an empty or already released VBO
Error: image copy did fail: %@
Error: C3DRendererContextSetupFramebuffer invoked twice on a Framebuffer
Warning: C3DRendererContextInferTextureTargetForImageTypeAndTextureSampler: called with kC3DTextureUntype type should be resolved before calling it, using GL_TEXTURE_2D as fallback
Error: Physically based lighting model is not supported by the OpenGL renderer, using Phong instead
Error: C3DRendererContextCreateBufferObjectForMeshSource - mesh source has no data
Error: C3DRendererContextBindMeshElement unsupported byte per index (%d)
Error: __FillProgramObjectLocations uniform index out of bounds
Error: Cannot load image %@.
Error: For best performance when using OpenGL, consider adding the `SCNDisableLinearSpaceRendering` and `SCNDisableWideGamut` keys with a bool value of `YES` to your app's Info.plist
Error: C3DRendererCreateTextureWithImage : error while getting bitmap bytes
Error: _createTextureForRenderTarget - fbo size is zero
Error: _createRBOForRenderTargetDescription - fbo size is zero
Error: Max number of texture unit (%d) is reached - can't bind a new texture
Error: We do not handle property %d to get the program attribute enum for the texture (using default: diffuse)
Error: __CreateMeshElement unexpected byte per index
Error: ParticleSystem shaders missing : %@
Error: unsupported conversion %@ -> float4
Error: inconsistency - material count doesn't match - can't diff reference node
Error: inconsistency - material has custom properties - can't diff reference node
Error: inconsistency - hierarchy doesn't match - can't diff reference node
Error: inconsistency - hierarchy changed - can't diff reference node
Error: failed to parse key path %@ - missing '['
Error: failed to parse key path %@ - missing ']'
Error: failed to evaluate key path %@ - material index %d out of bounds (%d)
Error: failed to locate scene reference %@
Error: failed to resolve referenced scene (%@) cycle detected
Error: referenced animations can't be resolved without a SCNAssetCatalog
Error: referenced actions can't be resolved without a SCNAssetCatalog
Error: SCNMTLRenderContext initWithDevice : device should not be nil
Error: SCNMTLRenderContext initWithDevice : cannot create a command queue. Bailing out.
Warning: Failed getting a valid drawable. Skipping this frame.
Error: cannot renderMesh without a vaid passDescriptor
Error: can not render without programs, using default
Error: _executeProgram - no pipeline state
Error: pass has no storage for input %@
Error: binding is broken : neither block or semantic
Error: AnimCodec - Failed to compress mesh
Error: AnimCodec - Failed to parse header
Error: AnimCodec - Failed to decompress animation
Error: AnimCodec - Can't decode metadata
Warning: Subdivision process might lead to gaps in surface because vertex welding is disabled when subdividing on the GPU
Error: Position must be float3 to be subdivided. Actual type is %d
Error: C3DResourceManagerMakeProgramResident failed to compile program - fallback on default program
Error: rendererContext is not tracked by the resource manager
Error: __ResourceManagerDeleteTexture: texture to be deleted not found, bail out
Error: _C3DResourceManagerDeleteTexture source does not match to any stored texture (no texture samplers associated)
Error: _C3DResourceManagerDeleteTexture can't find image source
Error: Failed to load texture named %@ : %@
Info: [SCNView] Using separate work group
Warning: Warning _lightNodes not NULL in C3DEnginePipelineSetup
Error: unexpected renderer element with no material/technique/program
Warning: C3DTriangle3BarycentricCoordinates: unable to solve the equation
Error: format %lu not supported for SH generation
Error: C3DRendererContextSetValueUniformAtLocation not implemented for this type (%d) yet
Error: uniform has incorrect type
Error: unable to create the shader cache folder at %@ (%@)
Error: C3DBaseTypeForCFNumberType: Type not supported
Error: C3DConvertToPlatformIndependentData - archiving pointers makes no sense
Error: C3DConvertToPlatformIndependentData - Type not supported
Error: C3DConvertFromPlatformIndependentData: Not enough room for the specified count & stride to read
Error: C3DConvertFromPlatformIndependentData: Not enough room for the specified count & stride to write
Error: C3DConvertFromPlatformIndependentData - Type not supported
Warning: C3DBaseTypeFromDescription - signed/unsigned ambiguity
Error: C3DBaseTypeFromDescription - Type not supported
Error: C3DAddBaseType - type %d can't be added
Error: C3DAddBaseType - addition of half float not supported
Error: C3DAddBaseType - unknown type
Error: C3DSubBaseType - type %d can't be substracted
Error: C3DSubBaseType - substraction of half float not supported
Error: C3DSubBaseType - unknown type
Error: Conversion to C string failed
Warning: C3DParseVersionNumber - No version found
Error: failed to load resource named %@
Error: failed to load dictionary named %@
Error: failed to load json named %@
Error: failed to load json named %@ (reason: %@)
Warning: C3DDataFromMTLBuffer - can't read private MTL buffer
Info: linear rendering forced to %d
Error: Could not deserialize a number array (nil buffer or serialized data)
Error: Could not deserialize a number (%@) in a number array
Error: Could not deserialize a number array (unexpected type)
Warning: C3DBaseTypeFromGLSLString: unknown type name '%@'
Warning: C3DBaseTypeFromMetalString: unknown type name '%@'
Error: unsupported SH order
Error: SH order unsupported : %d
Error: _buildTetrahedrons - failed with first tetrahedron
Error: tetrahedrisation: index out of bounds
Error: Invalid index size (%d bytes per index)
Error: No function %@ in the common profile %@
Error: Could not deserialize the color %@
Error: C3DEffectCommonProfile DeserializeColor: No property for the key %@
Error: Common profile deserialization: could not read the property %@
Error: Common profile deserialization: property found for the key %@
Error: Could not deserialize the texture sampler %@
Error: Cannot find the specified image
Error: Cannot find the image ID for the key %@ in the dictionary %@
Error: orphan effect common profile detected
Warning: __OpacityFromColorSlot:unexpected transparency mode %d
Error: C3DMeshSourceAppendVector3 - Type not supported
Error: C3DMeshSourceAppendVector2 - Type not supported
Error: C3DMeshSourceCreate: unsupported type
Error: C3DMeshElementEditorCreateWithMeshElement: mesh element is not a triangle array
Error: _C3DMeshElementEditorSetIndex unknown bytes per index
Error: C3DMeshElementEditorSubdivideTriangleAtIndex: triangleIndex out of bounds
Error: set transform not implemented on %@
Error: set world transform not implemented on %@
Error: set position not implemented on %@
Error: Index %ld out of range bounds [0...%ld]
Error: Index %ld out of bounds [0...%ld]
Error: unable to update the physics shape of %@
Warning: cannot change collision bit masks without physics world
Error: cannot apply force on a body that is not attached to a SCNNode
Error: cannot clear forces on a body that is not attached to a SCNNode
Error: cannot attach a body to a null node %p
Error: Failed to deserialize an animation because it is of an unknown type (%@)
Error: C3DSimpleAnimationEvaluate - invalid evaluation function
Error: _C3DSimpleAnimationInitWithPropertyList - no base type
Error: Failed to load IES profile : %@
Error: While deserializing a light: could not decode the number for the key %@ (serializedData : %@)
Error: While deserializing a light: no value for the key %@ (serializedData : %@)
Error: While deserializing a light: could not decode the color
Error: While deserializing a light: could not decode the shadowcolor
Info: invalid zNear value (0) set to camera
Error: C3DProjectionInfosUnproject : invalid viewport dimension
Error: error in C3DProjectionInfosUnproject
Info: loaded camera has an invalid zNear value (0)
Warning: C3DNodeGetWorldMatrix - no transform tree
Error: inconsistency in scene graph found in C3DNode finalize
Error: Could not read a matrix (serializedData: %@)
Error: Could not read a quaternion
Error: Could not read Euler
Error: Could not read the axis angle
Error: Could not read a matrix
Error: No data present to deserialize a rotation (serialized data : %@)
Error: Could not read a transform, position, scale and rotation have to be present (serializedData: %@)
Error: loading pivot from compressed collada file is not supported anymore - use SCN file format instead
Error: Node deserialization: cannot retrieve the object ID
Warning: Node<->attribute inconsistency finalizing deserialization
Error: Node deserialization: cannot retrieve the lightmap image ID
Error: Node deserialization: cannot retrieve the lightmap image
Warning: Mesh '%@' : sources of redundant semantic '%@' will be ignored in rendering
Error: Mesh deserialization: cannot find the sources in %@
Info: Mesh deserialization: Skipped a source that will be recreated at runtime : %@
Error: Mesh deserialization: cannot find the specified source
Error: Mesh deserialization: cannot deserialize a source
Error: Mesh deserialization: cannot init a mesh element
Warning: Can only convert to lines or points element type
Warning: Can only convert from triangle array to another element type
Error: Cannot find the specified primary source
Error: Cannot find the specified source
Error: Could not deserialize a source locator in %@
Warning: Can't add two position sources
Error: __C3DMeshCopy - unable to resolve interleaved mesh
Warning: Could not deserialize an effect
Warning: C3DSceneSetRootNode - old root node seems to be already connected to another scene
Warning: RootNode is not retained by the scene
Error: Could not read the animations manager
Error: C3DSceneRef _copySerializedHierarchy: lib entry not found
Warning: Some nodes failed to be deserialized
Error: ... and we do not even have a root node, so bailing out
Error: Scene deserialization : cannot finalize the deserialization of the animation manager
Error: Library could not remap the ID %@
Error: _deserializeHierarchy: could not find the specified node in the library
Error: _deserializeHierarchy: no nodeID specified!
Error: convexSweep only works with convex shapes
Warning: PhysicsWarn: %s
Error: failed to create a GL context
Warning: SCNCreateGLContext - failed to share our context with SpriteKit - fallback on a private context
Error: FATAL ERROR : can't load library without a path
Error: FATAL ERROR : failed to load Metal shaders library %@, %@
Error: Failed to load common profile chache library : %@
Error: Compilation failed %@
Error: Only metal program are supported %@
Error: Failed to find pre-compiled combination %@ + %@
Error: Failed to collect shader: %@
Error: Failed to collect shader: additional file "%@" is not always the same
Error: FATAL ERROR : failed compiling shader:
%d: %@
Warning: Should not register a node without light to the light system
Error: Node is already registered to the light system
Error: Invalid runtime light index
Error: The shadow node is not registered
Error: Too many shadow caster lights at once. Limit is %d
Error: Too many effective lights at once. Limit is %d
Error: Missing shadow %@
Warning: can't prepare shadable animation with path %@
Error: Material : %@ is not an animatable path
Error: referenced particle systems can't be resolved without a SCNAssetCatalog
Error: particle reference name is nil
Error: animation class %@ is not supported for particle systems
Error: Can't introspect type of property %@
Error: unknown particle controller input mode
Error: Could not create texture with descriptor : %@
Error: attempt to add a parent node as a child node
Error: removeChildNodeAtIndex - index out of bounds
Error: error in removeFromParentNode : inconsistent tree
Error: removing the root node of a scene from its scene is not allowed
Error: Error: physicsBody %@ 's owner (%@) should be %@
Error: attempt to add a null particle system on %@
Error: attempt to add a null audio player on %@
Error: error while transposing skeleton or morph target
Error: error while transposing animations to cloned tree
Error: [SCNScene root] is deprecated, use rootNode instead
Error: _subnodeFromIndexPath - invalid keypath
Error: %@ is not in a scene yet
Warning: failed to load scene at %@
Error: failed to unarchive SCNScene - (secureCoding compliance issue?)
Error: SCNRenderer::init - no engine context
Warning: _deleteGLFramebuffer - No context!
Warning: _prepareGLRenderTarget - No context!
Error: Failed to bind EAGLDrawable: %@ to GL_RENDERBUFFER
Error: failed to create a framebuffer
Error: framebuffer width must be > 0
Error: framebuffer width (%d) exceeds device's limit (%d), clamping
Error: framebuffer height must be > 0
Error: framebuffer height (%d) exceeds device's limit (%d), clamping
Error: autoenablesDefaultLighting: renderer has no context
Error: setAutoenablesDefaultLighting: renderer has no context
Error: SCNRenderer::setTechnique - no engine available yet - ignoring
Error: prepareObject:shouldAbortBlock renderer has no GL context
Error: glError before rendering SceneKit contents: %x
Error: Starting iOS 13.0 and macOS 10.15, SceneKit uses reverseZ depth buffer to achieve better precision. You must clear your depth to 0.0 or everything will be discarded. To opt out of this new behavior you can set the SCNDisableReverseZ key to a boolean value of YES in your app's Info.plist file.
Error: Render pass descriptor misconfigured - missing drawable texture
Warning: createSnapshot: no GL context
Error: Can only update lightProbe
Error: Can only update 'baked' lightProbes
Error: unknown light type %@
Error: SCNEncodeAnimations unknown animation: %@
Error: SCNEncodeAnimations failed to encode animation: %@
Error: SCNEncodeAnimations unknown animation type: %@
Error: can't deserialize animation %@
Error: failed to deserialize animation %@
Error: SCNDecodemage: invalid archive
Warning: CGPath archiving: unknown path element type
Warning: unable to infer the type of a basic animation: %@
Warning: unable to infer the type of a keyframed animation: %@
Error: animating between instances is not supported
Error: CAKeyframeAnimationToC3DAnimation :: too large value to animate : %d bytes
Error: CAKeyframeAnimation has no keyframe - skipping conversion
Error: can't add a NULL animation to %@
Error: can't encode an animation that has never been attached to any target
Error: Loading animation %@ failed with %@
Error: failed to convert CAAnimation to SCNAnimation
Warning: default duration is zero - using default transaction duration
Error: This animation can't be changed to additive. To make this animation additive first convert it to a CAAnimation, set it to additive and convert back to SCNAnimation
Error: This animation can't be changed to cumulative. To make this animation cumulative first convert it to a CAAnimation, set it to cumulative and convert back to SCNAnimation
Warning: failed to optimize keyframes
Error: unknown fill mode
Error: Unsupported CAPropertyAnimation subclass (%@)
Error: Unsupported CAAnimation class (%@)
Error: sub-animation %@ of %@ has no keyPath - ignoring
Error: C3DAnimationToCAAnimation: unsupported animation
Warning: SCNAnimationGroupToCAAnimationGroup - no target path
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert startValue
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert endValue
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert byValue
Error: entryWithUID:withClass: object with uid %@ exists but is not a geometry
Error: entryWithUID:withClass: object with uid %@ exists but is not a material
Error: entryWithUID:withClass: object with uid %@ exists but is not an animation
Error: entryWithUID:withClass: object with uid %@ exists but is not a node
Error: entryWithUID:withClass: object with uid %@ exists but is not a light
Error: entryWithUID:withClass: object with uid %@ exists but is not a camera
Error: entryWithUID:withClass: object with uid %@ exists but is not a scene
Error: entryWithUID:withClass: object with uid %@ exists but is not a skinner
Error: entryWithUID:withClass: object with uid %@ exists but is not a morpher
Error: entryWithUID:withClass: object with uid %@ exists but is not an image
Error: entrieswithClass: class %@ is not a known C3D class
Error: light node already has an authoring node - skip
Error: particle node already has an authoring node - skip
Error: camera node already has an authoring node - skip
Error: physicsField node already has an authoring node - skip
Error: Too many properties added to this ParticleSystem
Error: Cannot animate this particle semantic : %@
Error: Try to parametrize with a variable property not present : %@
Error: Unknown controller mode : %@
Error: Try to set a controller on a property not present : %@
Error: C3DLibraryCreateEntryIdentifier - unknown type
Error: _remapInfos does not contain an entry %@
Error: library does not contain an entry %d with kind %d
Error: Library: could not deserialize the substorage for the type %@
Error: type %d is not serializable
Error: Library deserialization: could not finalize the deserialization of a substorage
Error: Library Deserialization: cannot finalize the deserialization of %@
Warning: C3DLibraryGetMemoryUsageForKind found an image with no sampler
Warning: %@: zNear of 0 is not allowed
Error: slotName %d not found
Error: array for material property contents must have 6 elements
Warning: copyC3DImageFromImage: invalid sub-image
Error: SKTexture not found - missing linkage with SpriteKit?
Error: unknown material property type for archiving
Error: unknown archived material property type
Error: leaking materials array
Error: Cannot set edge creases element because its primitive type is not SCNGeometryPrimitiveTypeLine
Error: Cannot set edge creases source because its semantic is not SCNGeometrySourceSemanticEdgeCrease
Warning: Found elements with different channel counts in the same geometry
Error: Missing channel for source at index %u
Error: Invalid channel (%d) for source at index %u
Error: C3DProgramHashCodeStoreRegisterProgramForRendererElement - index out of capacity (%d > %d)
Warning: failed to transpose skeleton
Error: SCNSkinner setBaseGeometry is deprecated on iOS10 and OS X 10.12 and has no effect
Error: SCNSkinner: there must be the same number of bone weights and bone indices
Error: SCNSkinner: bone weights must be of type `float`
Error: SCNSkinner: bone indices must be uint8 or uint16 (maximum of 2 bytes)
Error: SCNSkinner: bone indices stride must be equal to componentsPerVector * bytesPerComponent
Error: SCNSkinner: bone weights stride must be equal to componentsPerVector * bytesPerComponent
Error: skinner: invalid index (%d)
Error: mismatch between the vertex count and the number of bones per vertex
Error: can't create a skinner with no bones
Error: can't create a skinner with no base geometry
Error: bones count and bind transform count don't match
Error: number of transforms (%d) doesn't match the number of joints (%d)
Error: Bones index too large for compressed representation : %d
Warning: C3DSkinnerTransposeSkeleton - unable to transpose every joints
Warning: Cannot update the joints using node names: unammed joint found
Warning: Cannot update the joints using node names: can't find node named %@
Warning: _C3DSkinnerUpdateBoundingBox - skinned node has no geometry
Error: We did not succeed in locating all the joints, so do not update the geometry as it might be worse if we use the wrong bones.
Error: C3DSkinnerUpdateJointsAndBoundingBox skinner has no mesh
Error: C3DSkinner serialization: lib entry not found
Warning: Skinner deserialization: cannot find the specified skeleton
Error: Skinner deserialization: cannot find a joint
Error: Skinner deserialization: cannot find the skin
Error: C3DSkinner deserialization: lib entry not found
Error: C3DSkinner deserialization: Could not get a valid number value
Error: Unsupported skin weight format
Error: invalid skin indices
Info: Too many influencing joints (%ld > %d) on the vertex #%u, will cap to %d and renormalize
Error: No jointsCount in the skin %@
Error: Unable to read the jointsCount in the skin %@
Warning: No maxInfluences in the skin %@, defaulting to 4. Please re-convert your assets.
Warning: Unable to read the maxInfluences in the skin %@, defaulting to 4. Please re-convert your assets.
Error: No inverseBindMatrices in the skin %@
Error: No defaultShapeMatrix in the skin %@
Error: A vertex weight index does not fit on an int
Error: Skin: Could not remap the ID for geometry %d
Error: Skin deserialization: no weightsCount in %@
Error: Skin deserialization: no jointsForVertexWeights in %@
Error: Skin deserialization: no vertexWeights in %@
Error: Skin deserialization: invalid vertexWeights
Error: GenericSource deserialize => no data type
Error: GenericSource deserialize => no count, bailing out
Error: GenericSource deserialize => no comp/value, bailing out
Error: GenericSource deserialize => no padding, bailing out
Error: Could not serialize the accessor's type
Error: accessor->_count too big
Error: accessor->_offset too big
Error: accessor->_padding too big
Error: Accessor serialization failed
Error: Accessor deserialization: Could not find the source ID
Error: Accessor deserialization: Could not find a valid source type
Error: Accessor deserialization: Could not remap the ID for source %d
Error: Accessor deserialization: : no serialized data
Error: C3DSourceAccessorGetValuePtrAtIndex - index out of bounds : %d > %d
Error: C3DSourceAccessorGetValuePtrAtIndex - no data
Error: C3DSourceAccessorGetMutableValuePtrAtIndex - index out of bounds : %d > %d
Error: C3DSourceAccessorGetVolatileValuePtrAtIndex - index out of bounds : %d > %d
Error: The destination does not have enough room to copy this data
Error: error in C3DSourceAccessorCopyDataToAccessor
Error: ERROR: GenericSource deserialize => no data type, bailing out
Error: ERROR: GenericSource deserialize => no count, bailing out
Error: ERROR: GenericSource deserialize => no stride, bailing out
Error: Could not deserialize an accessor
Error: Could not serialize an accessor
Error: Cannot finalize the deserialization of mesh source: accessor data missing
Warning: Cannot duplicate a Metal Buffer source. Create an empty data instead.
Error: setGimbalLockVector is deprecated
Warning: _computeTranslationOrigin3DFromPoint: invalid zRange
Warning: Warning: no C3DIntersectionRay3Plane
Error: Animation group deserialization: could not deserialize the animation
Error: Could not deserialize an animation
Error: Could not deserialize a keyframe animation
Error: Could not deserialize an animation: animation not found in %@
Error: Could not deserialize an animation: targetPath not found in %@
Error: _C3DAnimationChannelCopyPropertyList - no target path
Error: attaching a single wheel to multiple vehicle is not supported
Error: SCNAction: Custom actions can not be properly encoded, Objective-C blocks do not support NSSecureCoding.
Error: SCNAction: Custom actions can not be properly decoded, Objective-C blocks do not support NSCoding.
Error: Failed to load image with error %@
Error: Cannot load image %@. Using dummy texture.
Error: unknown compression format
Error: Cannot load image %@. Texture will be garbage.
Info: Generate IES texture %@ time %u x %u : %fms
Error: C3DGLSLProfileBindProfileInputs - profile has no technique
Error: wrong location returned for input named %@
Error: can't find input named %@
Warning: the same program is shared by two passes but indexed in a different manner
Error: failed to find texture target named %@
Error: declared type doesn't match the uniform named %@
Info: SCNSceneSourceConvertUnitsToMetersKey and SCNSceneSourceConvertToYUpKey have no effect on compressed assets. Use Xcode's compression options instead
Warning: Safe mode enabled, denying the download of a network URL %@
Warning: light_map uv_set:%d is pointing to an invalid uv_set(no corresponding source) and was reset to 1
Warning: invalid zRange detected (whole scene clipped)
Error: Point of view has custom projection.
Error: can't serize plist :%@
Error: Could not get the data for the serialized property list
Error: Could not zip the serialized property list
Error: This file cannot be opened (version is too old)
Error: This file cannot be opened (version of this c3d is too recent for this version of the framework)
Error: Could not find the zipped data
Error: Could not unzip the zipped data
Error: Error loading the unzipped data: %@
Error: cannot initialize library
Error: Cannot get the library in the serialized data
Error: cannot initialize scene
Error: cannot finalize scene deserialization
Warning: cannot finalize library deserialization
Warning: adding a node that was just removed %p
Error: unknown notification name
Warning: Slider can only process triangles.
Warning: Occluder can only process triangles.
Warning: overflow the max batch size boundary
Error: Could not load UsdKit
Info: PrefersOpenGL key is set in the plist but Metal is requested programmatically. GL will be used
Error: switchToCameraNamed: no camera named %@
Error: display link thread seems stuck
Error: _initializeRenderFromLightPass - no light
Error: _initializeDeferredShadows - no light
Error: _setupDeferredShadows - no light
Error: C3DTransformGetValue - unexpected semantic
Error: C3DTransformSetValue unexptected component index %d
Error: C3DTransformSetValue - unexpected semantic
Error: Could not create morph intervals : Target %d is useless
Error: No morphingType in the morph %@
Error: Unable to read the morphingType in the morph %@
Error: Could not remap the ID for mesh %d
Error: Could not remap the ID for weights source %d
Error: Morpher has %d targets weights, but has %d top-level morph targets (note: there are %d in-between morph targets)
Error: Internal consitency error. There should be %d runtime morph target weights, but we the current morph weight index is %d.
Error: Morpher deserialization: cannot find the morph
Error: C3DMorpher deserialization: lib entry not found
Error: C3DMorpher deserialization: Could not get a valid number value
Warning: C3DFXContextGetFirstPassInstanceWithGroupID: failed to find pass instance with name (%@)
Error: _C3DFXSetupPasses : no context
Error: shadows are only supported by spot lights and directional lights
Error: failed to bind program for pass %@
Error: pass %@ has no program set
Error: C3DFXRenderPassWillExecute: invalid framebuffer
Warning: Failed to create program for hashcode %@: %@
Error: C3DCommonProfileProgramReleaseHashCode can't find cache for tracked resource
Warning: C3DIO(warn) _writeAnimationChannel: animation not supported - won't be exported
Error: can't find index of animated buffer component
Error: can't mix affine and matrices animations
Error: %@
Warning: _writeSource - shared source detected (not supported)
Warning: _writeSource - shared accessor detected (not supported)
Warning: _writeArrayWithWriterFunc: infinite double encountered
Warning: _writeArrayWithWriterFunc: infinite float encountered
Error: failed to generate a path for an image
Error: found a texture with no sampler
Warning: geometry is partially double sided - not supported at export
Warning: failed to find source of morph
Warning: invalid light map info - not exported
Error: Physically based lighting model is not supported by the OpenGL renderer, using Phong instead (3)
Error: cannot handle more than one lighting modifier
Error: failed to load vertex uber shader.
Error: failed to load fragment uber shader.
Error: Physically based lighting model is not supported by the OpenGL renderer, using Phong instead (2)
Error: Invalid shader modifier : no code provided
Error: DOF pass: no point of view
Error: DOF pass: no camera
Warning: arguments named %@ is reserved for type %d
Warning: unknown member in scn automated buffer : %@
Warning: struct member does not match pass description : %@
Error: %@ setWeight:forTargetAtIndex:%d - index out of bounds (%d)
Error: Too many uniform custom samplers given (Max is %d)
Error: invalid custom texture slot.
Error: [SCNAction sequence:] invoked with nil
Error: Unflushed transaction present.
Error: Transaction stack contains an uncommited transaction.
Warning: invalid keypath: %@ sent to object %@
Error: C3DTransactionCommit - transaction already committed
Error: Scene %@ is modified within a rendering callback of another scene (%@). This is not allowed and may lead to crash
Error: C3DTransactionRemoveChild - inconsistency
Error: unexpected transaction commit (missing being ?)
Error: geometrySourceWithData: interleaved buffers as doubles are not supported
Error: geometrySourceWithBuffer - invalid vertex format
Error: _geometrySourceWithSource - invalid vertex format
Error: Could not create mesh source
Error: Failed to decompress data because vImageDecodeVectorHalf is not available
Error: _geometrySourceWithSource - Conversion failed
Error: SCNGeometryElement initialization - Invalid index size (%ld bytes)
Error: SCNGeometryElement initialization - Invalid polygon edge count (%ld)
Error: Cannot append manipulator vertex data because we encountered an overflow and we are not allowed to flush
Warning: ring buffer is full [%d/%d]
Error: Unable to create context
Warning: _beginTranslateAtLocation: invalid zRange
Error: only support one modifier per entrypoint (count=%d). 
Error: Unable to resolve URL %@
Error: SCNTextureSource abstract method invoked %@
Error: SCNImageSource astract method invoked %@
Error: SCNTextureDelegateSource::textureProxy -> no delegate
Error: AVAssetWriter can't create a movie at %@ (error:%@)
Error: appendImage: failed to get a pixelBuffer from CVPixelBufferPoolRef
Error: append pixel buffer failed
Error: error while exporting movie: %@
Error: program failed to build:
Error: Cannot compile empty shader %@
Error: %3d: %@
Error: failed to link program: %s
Error: C3DParticleModifier_PhysicsField - no aether
Error: [SCNAction group:] invoked with nil
Warning: MappingChannel %d needed but not available
Error: C3DRenderBufferGetSlotForOutputBufferType : unsupported type %d
Error: modifier without code is invalid
Error: unexpected value (%@)
Warning: SCNDefaultValueWithBaseType - unknwon base type %d
Error: unexpected returned value for property %@ of object %@
Error: can't generate implementation for property of type %d
Error: syntax error in the uniform declaration : %@
Error: C3DConstraintApplyIK leef is not a child of root
Error: C3DConstraintApplyIK root and leaf nodes are the same node
Error: Can't create a vehicle with this chassis because it is not in the scene yet
Warning: Chassis should already have a body
Warning: unsupported ease out for contraint applied on base type %d
Error: C3DModelPathResolveCommonProfileProperty unknown path %@
Error: _C3DModelPathResolverRegistryResolvePathWithClassName unknown path %@
Error: _C3DModelPathResolveColor4 unknown path %@
Error: _C3DModelPathResolveCommonProfileTexture unknown path %@
Error: _C3DModelPathResolveMatrix unknown path %@
Error: _C3DModelPathResolveTransform unknown path %@
Error: _C3DModelPathResolveRotation unknown path %@
Error: _C3DModelPathResolveVector3 unknown path %@
Error: _C3DModelPathResolveVector4 unknown path %@
Error: _C3DModelPathResolveNode unknown path %@
Error: _C3DModelPathResolveDynamicParameter unknown path %@
Error: _C3DModelPathResolveCommonProfile unknown path %@
Error: _C3DModelPathResolveMorpher unknown path %@
Warning: _C3DCreateAnimationTargetFromPath: can't resolve a path (null model)
Warning: _C3DCreateAnimationTargetFromPath: can't resolve a path
Error: Metal renderer does not support nil vertex function name
Error: Missing vertex function `%@`, error: %@
Error: Missing fragment function `%@`, error: %@
Error: Missing vertex function `%@`
Error: Missing fragment function `%@`
Info: Shaders without a vertex function are not allowed
Error: Compiler error while building render pipeline state for node %@:
Error: Failed to create compute function '%@', error: %@
Error: Failed to find compute function '%@'
Error: Failed creating ComputePipelineState, error: %@
Error: indexstore::_getNextFreeIndex - no more free index
Error: Failed to build renderable data for mesh %p
Warning: Mesh element %p of mesh %p has %d channels but they all define the same topology
Warning: Mesh %p has multiple channels but deindexing didn't have any effect
Warning: Deindexing - Vertex at index %u of %u is not used by any geometry element
Error: Deindexer failed - Source %p (%@) has no original data at index %u
Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)
Error: %s - Invalid polygon edge count (%u)
Error: __C3DMeshElementCreateRenderablePrimitiveTypeCopy - polygon %u (%u vertices, indices [%u, %u]) does not fit in index buffer (%u elements)
Error: Inconsistent index count after triangulation.
Error: C3DAllocatorDelete - unknown address
Error: repeatAction: invoked with a nil action
Error: repeatActionForever: invoked with a nil action
Error: technique should not be null
Error: Could not get pixel buffer (CVPixelBufferRef)
Error: CVMetalTextureCacheCreateTextureFromImage failed with status %d
Error: too many blend states: max render target is %d
Warning: can't create a fbo description for pass %@ - can't find pass description with name %@
Error: failed to load program %@
Warning: Unable to find metal library named %@ in bundle %@
Warning: Technique for pass "%@" has a custom Metal library, but the "%@" fragment function is missing
Warning: Technique for pass "%@" has a custom Metal library, but the "%@" vertex function is missing
Warning: Technique for pass "%@" has a custom Metal library, but the "%@" and "%@" vertex and fragment functions are missing
Error: failed to load program %@ %@
Error: unknown cull mode named %@
Error: unknown depth comparison function named %@
Error: unknown blend factor named %@
Error: unknown blend op named %@
Error: _bufferTypeFromName - unknown output type: %@
Warning: unknown texture format : %@
Error: description for input named %@ is missing
Error: 'type' is required for symbol %@
Warning: symbol named %@ should be in "targets" not "symbols"
Warning: _convertOutputsDescriptionToOutputs - can't find output named %@
Error: _convertOutputsDescriptionToOutputs - unknown output type: %@
Error: Cannot use a program because shader modifiers are set
Error: ShaderModifiers - unkwnown supporting class '%@'
Error: Cannot use shader modifiers because a program is set
Warning: _updateC3DProgramInput can't find input named %@
Error: ShaderModifiers - unkwnown entrypoint '%@'
Error: RendererElementStore does not support span of more than %d
Warning: Unknown alignment mode %@
Warning: Unknown truncation mode %@
SCNActionHide
/////////$2@
SCNModelIO
MDLMorphDeformerComponent
MDLComponent
NSObject
MDLSkinDeformerComponent
SceneKitAdditions
SCNAudioPlayer
SCNAudioSource
NSCopying
NSSecureCoding
NSCoding
SCNCoreAnimationSource
SCNTextureCoreAnimationSource
SCNMTLMorph
SCNMTLSkin
SCNPhysicsField
SCNPhysicsLinearGravityField
SCNPhysicsRadialGravityField
SCNPhysicsSpringField
SCNPhysicsMagneticField
SCNPhysicsElectricField
SCNPhysicsDragField
SCNPhysicsCustomField
SCNPhysicsVortexField
SCNPhysicsNoiseField
SCNPhysicsTurbulenceField
SCNJitterer
SCNPhysicsHingeJoint
SCNManipulator
SCNSpriteKitSource
SCNTextureSpriteKitSource
SCNPhysicsContact
SCNWeakPointer
C3DAnimationBinding
SCNMTLTessellator
SCNActionRunBlock
SCNExtensions
SCNMTLShadableKey
SCNMetalWireframeResource
MTLBuffer
MTLResource
SCNMTLResourceManager
SCNRenderTarget
SCNActionPlaySound
MTLTexture
SCNTechnique
SCNAnimatable
SCNPassContext
SCNPass
SCNPhysicsShape
SCNActionWait
SCNPhysicsCharacter
SCNReferenceNode
SCNNodeReference
SCNAnimationReference
SCNActionReference
SCNMTLRenderContext
SCNBufferStream
SCNPhysicsBehavior
SCN_DisplayLinkExtensions
SCNDisplayLink
SCNMTLBufferAllocatorSubBuffer
SCNFixedSizePage
SCNMTLBufferAllocator
SCNPhysicsConeTwistJoint
SCNStatisticsProvider
SCNKeyedUnarchiver
SCNKeyedArchiver
SCNMTLBuffer
SCNMTLResourceBinding
SCNMTLSemanticResourceBinding
SCNMTLPassResourceBinding
SCNMTLShadable
SCNMTLRenderPipeline
SCNMTLComputePipeline
SCNMTLMesh
SCNMTLMeshElement
SCNActionPerformSelector
SCNAction
Internal
SCNActionTargetState
SCNSpriteKitEventHandler
SCNActionJavaScript
SCNManipulableItem
SCNNodeManipulableItem
SCNPhysicsBody
SCNActionRunAction
SCNActionFade
SCNPhysicsWorld
SCNAdditions
Core3DKitAdditions
SCNLight
SCNMTLLibrary
3$0"0 0
SCNMTLLibraryManager
SCNMaterial
SCNShadable
SCNParticleSystem
SCNNode
SCNActionable
SCNBoundingVolume
UIFocusItem
UIFocusEnvironment
Transforms
SIMD
SCNScene
SCNRendererViewPoint
SCNRendererEvents
SCNRendererTransitionContext
SCNRenderer
SCNSceneRenderer
SCNTechniqueSupport
SCNOffscreenRenderer
SCNDeepCopy
SCNOrderedDictionary
SCNRecursiveLock
SCN_CAKeyframeAnimation
SCNAnimationEvent
SCNAddition
SCNTimingFunction
SCNAnimation
SCNAnimationPlayer
SCNSceneSource
NSKeyedUnarchiverDelegate
SCNMetalLayer
SCNHitTestResult
SCNMaterialPropertyTextureProviderSource
SCNMaterialPropertyTextureProviderHelper
SCNAuthoringEnvironment2
SCNFloor
SCNCamera
SCNMaterialAttachment
SCNMaterialPropertyTextureProvider
SCNMaterialProperty
SCNGeometry
SCNMutableGeometry
SCNAssetCatalogCacheEntry
SCNAssetCatalog
SCNSceneDatabase
SCNSceneLookUpUnarchiver
SCNParticlePropertyController
SCNSkinner
C3DIONSZipFileArchive
SCNCameraNavigationController
SCNEventHandler
SCNCameraControlConfiguration
SCNCameraControllerDelegate
SCNPhysicsBallSocketJoint
SCNUtils
SCNPhysicsVehicleWheel
C3DBinding
SCNPlane
SCNBox
SCNPyramid
SCNSphere
SCNCylinder
SCNCone
SCNTube
SCNCapsule
SCNTorus
SCNActionCustom
Textures
SCNCameraController
C3DEngineNotificationQueueTransientWrapper
USKHelper
USKToken_helper
USKObjectPath_helper
USKData_helper
SCNView
SCNCommonProfileProgramCache
SCNCommonProfileProgramGenerator
SCNCommonProfileProgramGeneratorGL
_C3DProgressDebugger
SCNMTLArgumentBinder
SCNMTLShaderBindingsGenerator
SCNMorpher
SCNBoundingBox
SCNBoundingSphere
SCNActionSequence
_SCNUIKitSourceRegistry
_SCNUIApplicationObserver
_SCNSnapshotWindow
SCNUIKitSource
SCNTextureUIKitSource
SCNActionMove
SCNTransaction
SCNGeometrySource
SCNMutableGeometrySource
SCNGeometryElement
AVAudio3DMixing
SCNAuthoringEnvironment
SCNCameraControlEventHandler
SCNActionRotate
SCNCommonProfileProgramGeneratorMetal
SCNTextureSource
SCNImageSource
SCNTextureOffscreenRenderingSource
SCNSourceRendererRegistry
SCNDelegateSource
SCNTextureDelegateSource
SCNMovieExport
SCNExportAddition
SCNExportOperation
_SCNExportOperation
SCNMovieExportOperation
SCNPhysicsSliderJoint
SCNNodeComponent
SCNNodeWeakComponent
SCN_DTAdditions
SCNLowLatencyMetalLayer
SCNActionScale
SCNActionGroup
SCNGeometryTessellator
SCNJSLayerJSExport
JSExport
SCN_JSSupport
SCNJSImageJSExport
SCNJSImage
SCNJSValueSExport
SCNJSValue
SCNJSExtensions
SCNJSValueTmpImp
SCNMaterialPropertyJSExport
SCNBoundingBoxJSExport
SCNBoundingSphereJSExport
SCNTransactionJSExport
SCNColorJSExport
SCNJSBasicAnimationJSExport
SCNJSAnimationGroupJSExport
SCNJSKeyframeAnimationJSExport
SCNViewJSExport
SCNMetalLayerJSExport
SCNPhysicsBehaviorJSExport
SCNParticlePropertyControllerJSExport
SCNPhysicsHingeJointJSExport
SCNPhysicsContactJSExport
SCNProgramJSExport
SCNTorusJSExport
SCNMorpherJSExport
SCNCapsuleJSExport
SCNLevelOfDetailJSExport
SCNRendererJSExport
SCNCylinderJSExport
SCNFloorJSExport
SCNNodeJSExport
SCNPlaneJSExport
SCNPhysicsBallSocketJointJSExport
SCNConeJSExport
SCNSphereJSExport
SCNGeometryJSExport
SCNConstraintJSExport
SCNPhysicsSliderJointJSExport
SCNLightJSExport
SCNMaterialJSExport
SCNParticleSystemJSExport
SCNHitTestResultJSExport
SCNPhysicsVehicleJSExport
SCNTubeJSExport
SCNLookAtConstraintJSExport
SCNPhysicsShapeJSExport
SCNGeometryElementJSExport
SCNGeometrySourceJSExport
SCNShapeJSExport
SCNSceneSourceJSExport
SCNPyramidJSExport
SCNCameraJSExport
SCNIKConstraintJSExport
SCNTechniqueJSExport
SCNPhysicsWorldJSExport
SCNPhysicsBodyJSExport
SCNBoxJSExport
SCNTransformConstraintJSExport
SCNAnimationEventJSExport
SCNActionJSExport
SCNSceneJSExport
SCNPhysicsVehicleWheelJSExport
SCNPhysicsFieldJSExport
SCNTextJSExport
SCNJSMediaTimingFunctionJSExport
SCNActionRemove
SCNPhysicsVehicle
SCNConstraint
SCNLookAtConstraint
SCNDistanceConstraint
SCNReplicatorConstraint
SCNAccelerationConstraint
SCNSliderConstraint
SCNAvoidOccluderConstraint
SCNBillboardConstraint
SCNConstantScaleConstraint
SCNTransformConstraint
SCNIKJoint
SCNIKConstraint
SCNDeferredProgramGeneratorMetal
1$0"0 1/#4
6%0"0 1/#4
3$0"0 1/#4
Compilation
SCNActionRepeat
SCNAVPlayerSource
SCNBufferBinding
SCNProgramSemanticInfo
SCNProgram
SCNShadableHelper
_SCNShadableCompilationIssue
SCNText
SCNShape
SCNLevelOfDetail
enumerateKeysAndObjectsUsingBlock:
count
allKeys
compare:
sortedArrayUsingSelector:
countByEnumeratingWithState:objects:count:
objectForKeyedSubscript:
mipmapLevelCount
resourceManager
newComputePipelineStateWithFunctionName:
width
height
depth
textureType
pixelFormat
newTextureViewWithPixelFormat:textureType:levels:slices:
state
libraryManager
frameworkLibrary
newRenderPipelineStateWithDesc:
arrayLength
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
setComputePipelineState:
threadExecutionWidth
maxTotalThreadsPerThreadgroup
dispatchThreads:threadsPerThreadgroup:
dispatchThreadgroups:threadsPerThreadgroup:
setTextures:withRange:
setTexture:atIndex:
setBuffers:offsets:withRange:
setBuffer:offset:atIndex:
setRenderPipelineState:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawPrimitives:vertexStart:vertexCount:
setVertexTextures:withRange:
setVertexTexture:atIndex:
setFragmentTextures:withRange:
setFragmentTexture:atIndex:
setFrontFacingWinding:
setTriangleFillMode:
setCullMode:
setDepthClipMode:
UTF8String
stringWithFormat:
stringWithUTF8String:
setString:
init
caction
setCppAction:
initWithCoder:
decodeBoolForKey:
encodeWithCoder:
encodeBool:forKey:
setDuration:
copyWithZone:
duration
numberWithInt:
arrayWithObjects:count:
supportsSecureCoding
hide
unhide
reversedAction
parameters
_mycaction
setHidden:
mapVolatileMesh:verticesCount:
unmapVolatileMesh:modifiedVerticesCount:
drawRenderElement:withPass:
screenTransform
setVertexBuffer:offset:atIndex:
setVertexBufferOffset:atIndex:
setFragmentBuffer:offset:atIndex:
setFragmentBufferOffset:atIndex:
dataWithBytes:length:
initWithData:topLeftOrigin:name:dimensions:rowStride:channelCount:channelEncoding:isCube:
imageFromTexture
isCube
transformAnimation
animationWithCAAnimation:
animationWithMDLTransform:
transform
matrix
initWithMatrix:
setTransform:
addObject:
children
boolValue
initThroughSCNKitBridgeWithURL:preserveTopology:error:
valueForKey:
pathExtension
lowercaseString
isEqualToString:
loadTextures
currentThread
threadDictionary
resolver
setValue:forKey:
sceneWithMDLAsset:options:
objectWithSCNNode:
jointPaths
removeAllObjects
jointBindTransforms
bytes
length
meshBindTransform
valueWithSCNMatrix4:
arrayWithCapacity:
numberWithDouble:
numberWithFloat:
animationWithKeyPath:
setValues:
setKeyTimes:
setBeginTime:
setAdditive:
setRemovedOnCompletion:
animation
setAnimations:
shapeSetTargetCounts
targetShapes
objectAtIndexedSubscript:
geometryWithMDLMesh:
name
setName:
setEdgeCreasesSource:
setEdgeCreasesElement:
initWithCapacity:
unsignedIntegerValue
shapeSetTargetWeights
setTargets:withInBetweenTargetCounts:inBetweenWeights:
setTargets:
weights
elementCount
keyTimes
doubleValue
getFloatArray:maxCount:atTime:
setWeights:
morpher
isAnimated
timeSampleCount
getTimes:maxCount:
getFloatArray:maxCount:
setUsesSceneTimeBase:
setRepeatCount:
addAnimation:forKey:
upAxis
valueWithSCNVector3:
setAttribute:forKey:
nodeWithMDLObject:masterObjects:sceneNodes:skinnedMeshes:skelNodesMap:asset:options:
rootNode
addChildNode:
path
_addSkinnerWithMDLMesh:sceneNodes:
animations
setObject:forKeyedSubscript:
_resetSceneTimeRange
startTime
setStartTime:
endTime
setEndTime:
sceneWithMDLAsset:
assetWithSCNNode:
assetWithSCNNode:bufferAllocator:
initWithBufferAllocator:
objectWithSCNNode:bufferAllocator:
assetWithSCNScene:
assetWithSCNScene:bufferAllocator:
setMatrix:
camera
cameraWithSCNCamera:
addChild:
light
type
lightProbeWithSCNLight:node:
lightWithSCNLight:
geometry
meshWithSCNGeometry:bufferAllocator:
childNodes
indicesChannelCount
data
bytesPerIndex
hasInterleavedIndicesChannels
primitiveCount
primitiveType
subdataWithRange:
initWithBytesNoCopy:length:
dataStride
dataOffset
isMemberOfClass:
flush
geometrySourceChannels
geometrySources
semantic
vectorCount
indexOfObjectPassingTest:
geometrySourcesForSemantic:
geometryElements
attributes
setFormat:
setBufferIndex:
newBuffer:type:
setOffset:
layouts
setStride:
newBufferWithData:type:
firstMaterial
multiply
contents
mappingChannel
selfIllumination
format
offset
bufferIndex
stride
componentsPerVector
geometryElementCount
materials
geometryElementAtIndex:
submeshWithSCNGeometryElement:bufferAllocator:positionSourceChannel:
submeshWithUniquedIndexData:andSCNGeometryElement:bufferAllocator:
materialWithSCNMaterial:
setMaterial:
initWithVertexBuffers:vertexCount:descriptor:submeshes:
meshWithSCNGeometry:
newSubmeshWithSCNGeometryElement:bufferAllocator:
newSubmeshWithSCNGeometryElement:bufferAllocator:positionSourceChannel:
newSubmeshWithUniquedIndexData:andSCNGeometryElement:bufferAllocator:
dataWithLength:
mutableBytes
initWithName:indexBuffer:indexCount:indexType:geometryType:material:topology:
initWithType:data:
setFaceCount:
setFaceTopology:
newSubmeshWithGeometryData:indexBufferLength:interleaved:channelCount:channelIdx:bytesPerIndex:indexType:geometryType:allocator:indexCount:topology:
submeshWithSCNGeometryElement:
submeshWithSCNGeometryElement:bufferAllocator:
initWithName:scatteringFunction:
ambient
diffuse
specular
reflective
transparent
metalness
roughness
ambientOcclusion
displacement
normal
isDoubleSided
setMaterialFace:
setColorSpace:
color
CGColor
setColor:
attenuationStartDistance
setAttenuationStartDistance:
attenuationEndDistance
setAttenuationEndDistance:
attenuationFalloffExponent
setAttenuationFalloffExponent:
spotInnerAngle
setInnerConeAngle:
spotOuterAngle
setOuterConeAngle:
setLightType:
focusDistance
setFocusDistance:
sensorHeight
setSensorVerticalAperture:
apertureBladeCount
setApertureBladeCount:
useLegacyFov
yFov
fieldOfView
setFieldOfView:
aspectRatio
setSensorAspect:
zNear
setNearVisibilityDistance:
zFar
setFarVisibilityDistance:
focalBlurRadius
setMaximumCircleOfConfusion:
fStop
setFStop:
usesOrthographicProjection
setProjection:
nodeWithMDLObject:
node
submeshes
faceIndexing
geometryType
geometryWithMDLMesh:submesh:
setGeometry:
lightWithMDLLight:
setLight:
lightWithMDLLightProbe:
cameraWithMDLCamera:
setCamera:
beginTime
objectForKey:
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
componentConformingToProtocol:
setMorpher:
copyJointBindTransformsInto:maxCount:
subdivisionScheme
setSubdivisionLevel:
setWantsAdaptiveSubdivision:
setTessellator:
setObject:forKey:
instance
hidden
skinnerWithBaseGeometry:bones:boneInverseBindTransforms:boneWeights:boneIndices:
setSkinner:
UUID
UUIDString
stringByAppendingPathComponent:
generateAmbientOcclusionVertexColorsWithQuality:attenuationFactor:objectsToConsider:vertexAttributeNamed:
generateAmbientOcclusionTextureWithQuality:attenuationFactor:objectsToConsider:vertexAttributeNamed:materialPropertyNamed:
generateLightMapVertexColorsWithLightsToConsider:objectsToConsider:vertexAttributeNamed:
generateLightMapTextureWithQuality:lightsToConsider:objectsToConsider:vertexAttributeNamed:materialPropertyNamed:
_updateAssociatedSCNNodeWithGeometrySetter:texturePathProvider:vertexAttributeNamed:materialPropertyNamed:
_associatedMDLObject
_bakeNodes:folderPath:inVertex:bakeAO:quality:attenuation:geomSetter:terminateSetter:
nodeWithMDLAsset:
vertexDescriptor
containsString:
vertexBuffers
geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:
setMkSemantic:
geometrySourceWithMDLVertexAttribute:mesh:
indexCount
geometryElementWithMDLSubmesh:
material
materialWithMDLMaterial:
geometryWithSources:elements:
setMaterials:
topology
unsignedLongValue
integerValue
numberWithUnsignedInteger:
geometryWithSources:elements:sourceChannels:
morpherWithMDLMesh:
faceTopology
indexBuffer
indexType
faceCount
setLength:
appendBytes:length:
geometryElementWithData:primitiveType:primitiveCount:bytesPerIndex:
propertyNamed:
textureSamplerValue
texture
fileURLWithPath:
writeToURL:
mkSemantic
setMappingChannel:
setContents:
scatteringFunction
setLightingModelName:
emission
materialFace
setDoubleSided:
propertyWithSemantic:
floatValue
setShininess:
_integrateModelKitComputedMaps:withGeometry:node:texturePathProvider:vertexAttributeNamed:materialPropertyNamed:filePath:
colorWithCGColor:
innerConeAngle
setSpotInnerAngle:
outerConeAngle
setSpotOuterAngle:
colorWithRed:green:blue:alpha:
lightType
setType:
focalLength
setFocalLength:
sensorVerticalAperture
setSensorHeight:
sensorAspect
setAspectRatio:
nearVisibilityDistance
setZNear:
farVisibilityDistance
setZFar:
setFocalBlurRadius:
projection
setUsesOrthographicProjection:
focalLengthAnimation
isSubclassOfClass:
values
objectAtIndex:
setKeyPath:
focalDistanceAnimation
fStopAnimation
array
initWithString:
copy
_associatedSCNNode
translations
rotations
scales
getFloat3Array:maxCount:
getFloatQuaternionArray:maxCount:
maximumTime
minimumTime
setFillMode:
rangeOfString:options:
substringFromIndex:
valueWithSCNVector4:
geometryBindTransform
setBaseGeometryBindTransform:
setSkeleton:
jointAnimation
skeleton
numberWithUnsignedInt:
getDouble4x4Array:maxCount:
substringToIndex:
rangeOfString:
initWithName:semantic:
scn_C3DColorIgnoringColorSpace:success:
intensity
setFloat3Value:
setFloatValue:
getC3DImageRef
contentsTransform
setTexture:
setTextureSamplerValue:
setURLValue:
setStringValue:
jointRestTransforms
getFloat4x4Array:maxCount:
parentNode
vertexCount
vertexAttributeDataForAttributeNamed:
dataStart
edgeCreases
edgeCreaseIndices
edgeCreaseCount
vertexCreases
vertexCreaseIndices
vertexCreaseCount
hasSuffix:
attributeNamed:
URLValue
stringValue
resolveInsideArchiveWithAssetNamed:
initWithURL:resolvingAgainstBaseURL:
intValue
setQuery:
absoluteString
_setImagePath:withResolvedPath:
setContentsTransform:
float4Value
float3Value
setWrapS:
setWrapT:
textureComponents
setTextureComponents:
hardwareFilter
sWrapMode
tWrapMode
minFilter
setMinificationFilter:
magFilter
setMagnificationFilter:
mipFilter
setMipFilter:
unsignedIntValue
geometryElementWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:
setConstantValue:type:withName:
renderResourceForMesh:dataKind:
waitForShadersCompilation
contentScaleFactor
textureForEffectSlot:
enableARMode
shouldDelegateARCompositing
renderingAlgorithm
setRenderingAlgorithm:
rate
setRate:
volume
setVolume:
reverbBlend
setReverbBlend:
initWithAVAudioNode:
setWillStartPlayback:
setDidFinishPlayback:
anyObject
removeObject:
initWithSource:
dealloc
audioBuffer
didFinishPlayback
setCompleted:
shouldStream
recycle
reset
postCommandWithContext:object:applyBlock:
loops
scheduleBuffer:atTime:options:completionHandler:
audioFile
play
scheduleFile:atTime:completionHandler:
willStartPlayback
audioBufferFormat
audioPlayerWithAVAudioNode:
audioPlayerWithSource:
setNodeRef:
nodeRef
__CFObject
audioNode
audioPlayer
audioSource
scene
completed
customAudioNode
_audioNode
_audioPlayer
_audioSource
_nodeRef
_scene
_customAudioNode
_completed
_shouldRecycle
initWithAVAudioPCMBuffer:
setPositional:
isPositional
stringByDeletingPathExtension
URLForResource:withExtension:
_loadURLWithBundle:
mainBundle
initWithFileNamed:inBundle:
dictionary
initWithFileNamed:
_load
initForReading:error:
processingFormat
initWithPCMFormat:frameCapacity:
readIntoBuffer:error:
currentHandler
localizedDescription
handleFailureInMethod:object:file:lineNumber:description:
load
loadIfNeeded
frameLength
fileFormat
sampleRate
audioSourceNamed:
initWithURL:
audioSourceWithAVAudioPCMBuffer:
setLoops:
setShouldStream:
encodeObject:forKey:
encodeFloat:forKey:
decodeObjectOfClass:forKey:
decodeFloatForKey:
_customEncodingOfSCNAudioSource:
_customDecodingOfSCNAudioSource:
fileName
_audioFile
_audioBuffer
_audioURL
_audioName
_loops
_shouldStream
_loaded
positional
commandBuffer
blitCommandEncoder
computeCommandEncoder
device
endEncoding
enqueue
commit
initForReadingWithData:
decodeInt32ForKey:
containsValueForKey:
decodeObjectForKey:
computePipelineStateForKernel:
finishDecoding
stringWithCString:encoding:
numberWithBool:
numberWithUnsignedShort:
numberWithUnsignedLong:
numberWithUnsignedChar:
commandQueue
pushDebugGroup:
setBytes:length:atIndex:
popDebugGroup
setBufferOffset:atIndex:
renderEncoder
storageMode
newBufferWithLength:options:
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
stringByAppendingString:
decodeBytesForKey:returnedLength:
stringByAppendingFormat:
setLanguageVersion:
setFastMathEnabled:
setPreprocessorMacros:
setAdditionalCompilerArguments:
initWithFormat:
replaceOccurrencesOfString:withString:options:range:
libraryForSourceCode:options:
newComputePipelineStateWithFunctionName:library:
newBufferWithBytes:length:options:
initForWritingWithMutableData:
encodeInt32:forKey:
computeFunction
waitUntilCompleted
finishEncoding
encodeBytes:length:forKey:
addCompletedHandler:
setTessellationFactorScale:
setTessellationFactorBuffer:offset:instanceStride:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:
layer
setLayer:
isOpaque
textureSource
_layer
metalTextureWithEngineContext:textureSampler:nextFrameTime:
_drawFullScreenTexture:over:
sharedRegistry
sourceRendererForEngineContext:source:textureSource:targetTexture:
__renderLayer:withCARenderer:engineContext:viewport:atTime:forceUpdate:didUpdate:
requiresMainThreadUpdates
begin
layerToFocusForRenderedLayer:
setAnchorPoint:
setPosition:
shouldFlip
anchorPoint
bounds
setBounds:
_resizeLayer:toSize:updateLayer:updateTransform:caRenderer:
beginFrameAtTime:timeStamp:
updateBounds
nextFrameTime
endFrame
addUpdateRect:
render
rendererContextForTextureSourceWithEngineContext:
setCurrentContext:
clearValue
_bindFramebuffer:
renderPassDescriptor
colorAttachments
setLoadAction:
setClearColor:
renderCommandEncoderWithDescriptor:
__renderLayerUsingMetal:withCARenderer:engineContext:viewport:atTime:forceUpdate:didUpdate:
_unbindFramebuffer:
_buildMipmaps:
cleanup:
contentsScale
layerSizeInPixels
_textureWithEngineContext:textureSampler:nextFrameTime:
__prepareFramebufferWithSize:withEngineContext:textureSampler:needsStencil:
__updateTextureWithLayer:texture:engineContext:sampler:
supportsMetal
MTLTextureCache
texture2DDescriptorWithPixelFormat:width:height:mipmapped:
setStorageMode:
setUsage:
newTextureWithDescriptor:
setMTLTextureCache:
prefersGL3
renderWithEngineContext:textureSampler:nextFrameTime:
layerContentsScaleFactor
textureWithEngineContext:textureSampler:nextFrameTime:
_lastUpdate
_nextUpdateDate
initWithFormat:arguments:
sparseIndexSize
_prepareTargetDataForIndex:morph:baseMesh:
newBufferWithLength:
_writeSources:dstTypes:sourcesCount:inBuffer:stride:length:sparse:positionScale:
isEqualToArray:
resourceComputeEncoder
setStepFunction:
newComputePipelineStateForKernel:withStageDescriptor:constants:constantsHash:
initWithMorph:baseGeometry:resourceManager:
isCompatibleWithMorph:
morphIncrementallyForMorpher:renderContext:positionBuffer:normalBuffer:
unifyMeshWithRenderContext:positionBuffer:normalBuffer:
morphSparseMorpher:renderContext:positionBuffer:normalBuffer:
_resourceManager
_baseBuffer
_baseVertexCount
_baseBufferTypes
_baseBufferTypesCount
_baseBufferStride
_targetBufferTypes
_targetBufferTypesCount
_targetBufferStride
_dstSemanticUsageMask
_srcSemanticUsageMask
_bufferPool
_unifyPostMorphNormals
_shouldMorphNormals
_dataKindForMorphing
_splatProvokingVertices
_postUnifyInfo
_targets
_targetCount
_originalTargets
_copyCPS
_blendCPS
_blendSparseCPS
_splatCPS
bufferForAttribute:
stageDescriptor
buffers
getObjects:range:
initWithSkinner:baseMesh:baseGeometry:resourceManager:
skinMesh:with:skinner:renderContext:
_vertexCount
_needNormal
_needTangent
_vertexWeightIndicesBuffer
_boneIndicesBuffer
_boneWeightsBuffer
_computePS
_computeStageDesc
renderResourceForMorph:baseGeometry:
currentFrameIndex
renderResourceForSkinner:baseMesh:baseGeometry:
setStageInRegion:
engineContext
_commonInit
_removeOwner
field
setBlock:
setSmoothness:
setAnimationSpeed:
doesNotRecognizeSelector:
archivedDataWithRootObject:requiringSecureCoding:error:
unarchiveObjectWithData:
physicsWorld
_postCommandWithBlock:
_aetherHandle
isExclusive
_removeFieldFromWorld:
_createField
_setupCommonProperties
_addFieldToWorld:
encodeDouble:forKey:
encodeInteger:forKey:
immediateMode
setImmediateMode:
setHalfExtent:
decodeDoubleForKey:
setStrength:
setFalloffExponent:
setMinimumDistance:
setActive:
decodeIntegerForKey:
setScope:
setUsesEllipsoidalExtent:
setExclusive:
setDirection:
dragField
customFieldWithEvaluationBlock:
vortexField
radialGravityField
linearGravityField
noiseFieldWithSmoothness:animationSpeed:
turbulenceFieldWithSmoothness:animationSpeed:
springField
electricField
magneticField
_setDisplayScaleFactor:
_displayScaleFactor
strength
categoryBitMask
setCategoryBitMask:
falloffExponent
minimumDistance
isActive
scope
halfExtent
usesEllipsoidalExtent
exclusive
direction
supportsDirection
supportsOffset
_willRemoveFromPhysicsWorld
_setOwner:
_setWorld:
_owner
_handle
evalAtLocation:
_halfExtent
_strength
_falloffExponent
_minimumDistance
_active
_scope
_usesEllipsoidalExtent
_exclusive
_offset
_direction
_categoryBitMask
_world
_node
_field
gravity
block
_block
axis
valueForUndefinedKey:
setValue:forUndefinedKey:
smoothness
animationSpeed
_smoothness
_animationSpeed
setDepthBias:slopeScale:clamp:
update
restart
stopIfNeeded
_canJitter
jitter
loadDelegate
renderer
_jitterAtStep:updateMainFramebuffer:redisplay:jitterer:
initialize
initWithDelegate:
delegateWillDie
setEnabled:
isEnabled
isAborting
_enabled
_state
_iteration
_restartSourceIsSuspended
_delegate
_restartSource
initWithBodyA:axisA:anchorA:bodyB:axisB:anchorB:
initWithBody:axis:anchor:
jointWithBodyA:axisA:anchorA:bodyB:axisB:anchorB:
jointWithBody:axis:anchor:
bodyA
bodyB
axisA
setAxisA:
axisB
setAxisB:
anchorA
setAnchorA:
anchorB
setAnchorB:
_addToPhysicsWorld:
_willRemoveFromPhysicsWorld:
_definition
_constraint
initWithDevice:sigma:
setEdgeMode:
encodeToCommandBuffer:sourceTexture:destinationTexture:
textureTarget
layerTarget
drawableSize
overlaySKScene
showsStatistics
showsAuthoringEnvironment
authoringDisplayMask
authoringEnvironment
orderedSetWithCapacity:
component
parentItem
updateManipulatorNode
firstObject
orderedSetWithObject:
indexSet
_deleteOriginalData
removeFromParentNode
target
setTarget:
editingSpace
setupNode
scn_colorWithC3DColor:
setEulerAngles:
setRenderingOrder:
billboardConstraint
setPreserveScale:
sphereWithRadius:
setGeodesic:
setSegmentCount:
setColorBufferWriteMask:
nodeWithGeometry:
setOpacity:
boxWithWidth:height:length:chamferRadius:
updateManipulatorComponents
setSimdWorldTransform:
setScale:
effectiveEditingSpace
authoringOverlayLayer
manipulatorNode
_effectiveFeatures
blackColor
whiteColor
enumerateHierarchyUsingBlock:
opacity
isHidden
hitTest:options:
hitTest:
unhighlightSelectedNode
orangeColor
_updateActionWithEvent:
worldTransform
setWorldTransform:
enumerateObjectsUsingBlock:
setDisableActions:
gridUnit
shouldSnapToAlign
_snapPositionToAlign:original:unit:axisMove:rayStart:rayDir:didSnap:snapIndexes:
shouldSnapOnGrid
addIndex:
updateItemsPosition
viewMatrix
updateItemsRotation:
updateItemsScale:
removeAllIndexes
_updateCloneStateWithEvent:
_applyWithEvent:
readonly
_saveOriginalData
clearSnapIndexes
validateClones
delegate
authoringEnvironment:didMoveItems:fromTransform:
mouseMoved:
sceneRenderer
removeItemsFromScene:
addItems:toScene:
authoringEnvironment:didCloneSelection:
validateClone
orderedSet
cloneForManipulators
childNodesPassingTest:
targets
getBoundingBoxMin:max:
convertPosition:toNode:
_prepareSnapToAlignData:minOffset:maxOffset:
sceneRef
lock
prepareSnapToAlignData
unlock
prepareSnapToAlignDataIfNeeded
_setAuthoringEnvironment:
isDragging
updateManipulatorPosition:
editingSpaceChanged
setFeatures:
setAlternateMode:
setReadonly:
features
lockLayout
unlockLayout
mouseDragged:
mouseDown:
mouseUp:
removeClonesFromScene
addClonesToScene
setupClones
snapGuideIndexesOnAxis:
snapInfoAtIndex:axis:
xAlignment
setXAlignment:
yAlignment
setYAlignment:
zAlignment
setZAlignment:
_authoringEnvironment
_xAxisToZAxisTransform
_yAxisToZAxisTransform
_xyPlaneToYZPlaneTransform
_xyPlaneToXZPlaneTransform
_selectedAxis
_actionData
_isMouseDown
_readonly
_action
_originalMouseLocation
_originalData
_originalDataCount
_worldInitialMatrix
_worldMatrix
_snapToAlignCount
_snapToAlignOnX
_snapToAlignOnY
_snapToAlignOnZ
_snapXIndexes
_snapYIndexes
_snapZIndexes
_xAlignment
_yAlignment
_zAlignment
_planarTranslationHandleXY
_planarTranslationHandleYZ
_planarTranslationHandleXZ
_planarTranslationHandles
_axis
_arcHandleXY
_arcHandleYZ
_arcHandleXZ
_arcHandles
_scaleNode
_screenSpaceRotation
_highlightNode
_planarTranslationLayout
_layoutLocked
_zArrow
_rotationHandles
_occluder
_translateHandles
_billboard
_cloneSet
_cloning
_features
_alternateMode
containsObject:
cylinderWithRadius:height:
coneWithTopRadius:bottomRadius:height:
flattenedCopy
clone
setAuthoringEnvironmentNode:
planeWithWidth:height:
torusWithRingRadius:pipeRadius:
setPipeSegmentCount:
setRingSegmentCount:
setTransparency:
setRadialSpan:
setHittable:
setRingRadius:
setScene:
backgroundColor
_isDirty
_notifyNextDirtyState
renderSKSceneWithRenderer:overlay:atTime:
__renderSKScene:withSKSCNRenderer:engineContext:viewport:atTime:
updateAtTime:
renderToFramebuffer:shouldClear:
size
__updateTextureWithSKScene:engineContext:sampler:
newTextureViewWithPixelFormat:
renderToTexture:commandQueue:
appendFormat:
appendString:
_setupWithManifold:index:point:
_contactWithManifold:index:
_fillNodeA:nodeB:contactPoint:collisionImpulse:distance:hitFraction:
_fillNodeA:nodeB:
nodeA
nodeB
contactPoint
contactNormal
collisionImpulse
penetrationDistance
sweepTestFraction
_prepareUpdate
_shouldPostUpdate
_nodeA
_nodeB
_contactPoint
_contactNormal
_collisionImpulse
_distance
_fraction
_updateCount
weakRef
copyWeakRef
setWeakRef:
.cxx_destruct
renderResourcesForEffectSlot:withEngineContext:
cubeArrayTypeIfSupported
setTextureType:
setArrayLength:
setPixelFormat:
setWidth:
setHeight:
usage
setMipmapLevelCount:
defaultLightingEnvironmentRadianceTexture
userAnimation
_source
_destination
_valueTransformer
indexesOfObjectsPassingTest:
removeObjectsAtIndexes:
mutableCopy
replaceObjectAtIndex:withObject:
_pipelineStateHashForMeshElement:patchType:
setTessellationPartitionMode:
setTessellationFactorStepFunction:
setTessellationControlPointIndexType:
setTessellationFactorScaleEnabled:
setTessellationFactorFormat:
setTessellationOutputWindingOrder:
featureProfile
setMaxTessellationFactor:
updateUniformTessellator:
updateScreenSpaceAdaptiveTessellator:parameters:
updateConstrainedEdgeLengthTessellator:parameters:
updateSubdivisionSurfaceTessellator:parameters:
uniformTessellationDrawMeshElement:forMesh:instanceCount:renderContext:
screenSpaceAdaptiveTessellationDrawMeshElement:forMesh:instanceCount:renderContext:
constrainedEdgeLengthTessellationDrawMeshElement:forMesh:instanceCount:renderContext:
subdivisionSurfaceTessellationDraw:
_drawPatchForMeshElement:instanceCount:
elements
buffer
sharedIndexBufferOffset
indexOfObject:
initWithGeometry:resourceManager:
pipelineStateHashForMeshElement:patchType:
newPipelineStateConfiguratorForMeshElement:patchType:device:
update:
draw:
_geometry
_cachedTessellator
_tessellationFactorBuffer
finished
runBlock:queue:
isCustom
updateWithTarget:forTime:
_queue
allValues
SCN_safeHash
_material
_pipeline
program
programHashCode
weakToStrongObjectsMapTable
allocateRegistry
registerBindings
initWithDevice:
removeObjectForKey:
newCommandQueue
setLabel:
_setEngineStats:
initWithDevice:fixedSizeElement:buffersize:name:
null
defaultCenter
_meshSourceWillDie:
addObserver:selector:name:object:
_meshElementWillDie:
_meshWillDie:
_imageWillDie:
_imageProxyWillDie:
_programWillDie:
_passWillDie:
_materialWillDie:
_geometryWillDie:
_morphWillDie:
_skinWillDie:
_programHashCodeWillDie:
removeObserver:
unregisterManagerForDevice:
object
decrementUsedCount
dataSource
_removeMatchingProgram:pass:
clearCompiledLibraries
setDepthCompareFunction:
setDepthWriteEnabled:
frontFaceStencil
setStencilCompareFunction:
setStencilFailureOperation:
setDepthFailureOperation:
setDepthStencilPassOperation:
setReadMask:
setWriteMask:
backFaceStencil
newDepthStencilStateWithDescriptor:
incrementUsedCount
setBuffer:
setDataSource:
renderResourceForMeshElement:
setIndexBuffer:
setIndexCount:
setSharedIndexBufferOffset:
setInstanceCount:
setupWithElement:
_bufferForMTLBuffer:
_bufferForData:bytesPerIndex:
mutabilityTimestamp
setMutabilityTimestamp:
__updateMutableMesh:withMetalMesh:
verticesCount
setVerticesCount:
renderResourceForMeshSource:
setVertexDescriptor:
setBuffers:
setVolatileStride:
setElements:
objectEnumerator
reverseZ
materialModificationCount
geometryModificationCount
setMaterialModificationCount:
setGeometryModificationCount:
shadableBufferBindings
needsRenderResource
newSubBufferWithBytes:length:renderContext:
newConstantBufferWithLength:options:
argumentEncoder
encodedLength
setArgumentBuffer:offset:
usedResources
renderResourceForSampler:
setSamplerState:atIndex:
constantDataAtIndex:
argument
bufferDataSize
setPurgeableState:
makeAliasable
isAliasable
label
cpuCacheMode
hazardTrackingMode
resourceOptions
heap
heapOffset
allocatedSize
didModifyRange:
newTextureWithDescriptor:offset:bytesPerRow:
addDebugMarker:range:
removeAllDebugMarkers
bufferDataType
bufferStructType
members
setResource:ofType:atIndices:
setMinFilter:
setMagFilter:
setSAddressMode:
setTAddressMode:
setRAddressMode:
setMaxAnisotropy:
newSamplerStateWithDescriptor:
resourceManagerForDevice:
_rasterizerStateDidDie:
removeAllShaders
resetRasterizerStates
renderResourceForRasterizerState:reverseZ:
renderResourceForTessellatedGeometry:
wireframeResourceForRendererElement:engineContext:passInstance:hashPass:
newIndexBufferWithLength:options:
renderResourceForMaterial:geometry:renderPipeline:engineContext:
dispatchForTexture:computeEncoder:pipelineState:
dispatchForCubemap:computeEncoder:pipelineState:
stats
depthAndStencilStateWithReadWriteDepthDisabled
setLibraryManager:
_device
_commandQueue
__engineStats
_libraryManager
_bindingsGenerator
_availablePipelineStates
_availablePipelineStatesLock
_commonProfileBuffersAllocator
_availableLightingSystemReflectionProbeTextures
_availableIrradianceTextures
_availableRadianceTextures
_availableImages
_availableImageProxy
_availableSamplers
_availableIESTextures
_availableBuffers
_availableMeshes
_availableMeshSources
_availableMeshElements
_availableRasterizerStates
_availableMorphs
_availableSkins
_availableComputePipelines
_availableComputePipelinesWithStageDescriptor
_availableTessellators
_availableWireframeMaterials
_availableShadables
_availableShadablesSearchKey
_availableStageDescriptors
_stageDescriptorsLock
_nullStageDescriptor
_areaLightPrecomputedDataTexture
_specularDFGTexture
_defaultProgram
_defaultProgramForTessellation
_isolateProgram
_depthAndStencilStateWithReadWriteDepthDisabled
_defaultTexture
_defaultTexture3D
_defaultCubeTexture
_defaultLightingEnvironmentIrradianceTexture
_defaultLightingEnvironmentRadianceTexture
_mtkTextureLoader
setBlendingEnabled:
setSourceRGBBlendFactor:
setDestinationRGBBlendFactor:
setRgbBlendOperation:
setSourceAlphaBlendFactor:
setDestinationAlphaBlendFactor:
setAlphaBlendOperation:
initWithKeyOptions:valueOptions:capacity:
setStepRate:
isFramebufferOnly
sampleCount
setSampleCount:
setResolveTexture:
depthAttachment
stencilAttachment
_finalRenderTexture
setStoreAction:
setFramebufferOnly:
clientRenderPassDescriptor
setSlice:
setLevel:
resolveTexture
setResolveSlice:
loadAction
frameConstantBufferPool
currentCommandBuffer
clientRenderCommandEncoder
clientCommandBuffer
beginRenderPass:renderEncoder:parameters:
endRenderPass
setObject:atIndexedSubscript:
storeAction
setDepthAttachment:
setDepthResolveFilter:
setClearDepth:
setStencilAttachment:
numberWithInteger:
arrayWithObjects:
frameTexturePool
defaultCStringEncoding
cStringUsingEncoding:
setViewport:
setScissorRect:
setStencilReferenceValue:
setFragmentSamplerState:atIndex:
initWithMTLTexture:options:
initWithDescription:size:arrayLength:
viewportDependant
renderBufferFormat
matchesDescription:size:arrayLength:
textureForSliceIndex:
ciImage
referenceCount
setReferenceCount:
timeStamp
setTimeStamp:
_description
_size
_arrayLength
_ciImage
_sliceTextures
_texture
_name
_referenceCount
_timeStamp
addObjectsFromArray:
addEntriesFromDictionary:
dictionaryWithObjects:forKeys:count:
newComputePipelineStateWithFunctionName:constantValues:
_setupDuration
playAudioSource:waitForCompletion:
addAudioPlayer:
audioPlayers
removeAudioPlayer:
invalidate
initWithTechniqueRef:
techniqueRef
_symbolsAssignedValues
dictionaryRepresentation
techniqueWithDictionary:
setValue:forSymbolNamed:
effectSlot
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
getBytes:bytesPerRow:fromRegion:mipmapLevel:
replaceRegion:mipmapLevel:withBytes:bytesPerRow:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:
rootResource
parentTexture
parentRelativeLevel
parentRelativeSlice
bufferOffset
bufferBytesPerRow
iosurface
iosurfacePlane
allowGPUOptimizedContents
swizzle
copyC3DImageFromImage:
postCommandWithContext:object:keyPath:applyBlock:
prepareWithTarget:implicitDuration:
animationPlayerWithSCNAnimation:
addAnimationPlayer:forKey:
_scnAnimationForKey:
animationWithSCNAnimation:
animationKeys
animationPlayerForKey:
animationManager
_pauseAnimation:forKey:pausedByNode:
removeAnimationForKey:blendOutDuration:
setSourceObject:
setKeyPathDst:
setKeyPathSrc:
setOptions:
initPresentationTechniqueWithTechniqueRef:
initWithFXPass:technique:
_setupPasses
decodeObjectOfClasses:forKey:
_customEncodingOfSCNTechnique:
_customDecodingOfSCNTechnique:
techniqueBySequencingTechniques:
techniqueWithTechniqueRef:
removeAllAnimations
removeAnimationForKey:
removeAnimationForKey:fadeOutDuration:
animationForKey:
pauseAnimationForKey:
resumeAnimationForKey:
setSpeed:forAnimationKey:
isAnimationForKeyPaused:
handleBindingOfSymbol:usingBlock:
valueForSymbolNamed:
setLibrary:
library
__removeAnimation:forKey:
addAnimation:
_syncObjCAnimations
_copyAnimationsFrom:
_scnBindings
bindAnimatablePath:toObject:withKeyPath:options:
unbindAnimatablePath:
removeAllBindings
copyAnimationChannelForKeyPath:animation:
isPausedOrPausedByInheritance
presentationInstance
passAtIndex:
_didInstallInEngineContext:
_isPresentationInstance
_technique
_valueForSymbol
_animations
_bindings
_library
_passes
time
inputTextureWithName:
outputTextureWithName:
_context
setInitializationHandler:
initializationHandler
setExecutionHandler:
executionHandler
setValue:forPassPropertyKey:
valueForPassPropertyKey:
_fxPass
contextWithMTLDevice:
contextWithEAGLContext:
numberWithLong:
stringByReplacingOccurrencesOfString:withString:
vectorWithValues:count:
filterWithName:
setDefaults
vectorWithX:Y:Z:W:
extent
drawImage:inRect:fromRect:
initWithTexture:size:flipped:colorSpace:
renderMesh:meshElement:withProgram:engineContext:transform:color:rasterizerStates:blendState:texture:depthBias:
geometryRef
SCNVector3Value
scale
initWithContent:options:
_setTransforms:
SCNMatrix4Value
pointerValue
shapeWithGeometry:options:
valueWithPointer:
_customEncodingOfSCNPhysicsShape:
_customDecodingOfSCNPhysicsShape:
setWithArray:
setReferenceObject:
shapeWithNode:options:
shapeWithShapes:transforms:
defaultShapeForGeometry:
initWithCachedObject:options:
referenceObject
options
transforms
sourceObject
_referenceObject
_options
_transforms
_cachedObject
_collisionShape
dictionaryWithObject:forKey:
functionType
patchType
dataType
setDepth:
setCpuCacheMode:
supportsMSAADepthResolve
supportsFeatureSet:
supportsTessellation
supportsNonUniformThreadgroupSize
supportsLayeredRendering
maxViewportCount
supportsTextureCubeArray
supportsReadWriteTextureCubeArguments
supportsBaseVertexInstanceDrawing
supportsMemorylessRenderTargets
supportsProgrammableBlending
supportsMSAAStencilResolve
supportsTextureSampleCount:
supportsDepthClipMode
defaultUICatalogForBundle:
namedTextureWithName:scaleFactor:
characterAtIndex:
bundlePath
resourcePath
query
stringByRemovingPercentEncoding
componentsWithURL:resolvingAgainstBaseURL:
queryItems
value
initWithURL:offset:length:
dataNoCopy
lastPathComponent
URLByDeletingPathExtension
URLByAppendingPathExtension:
waitForDuration:withRange:
waitForDuration:
emptyShaderCache
renderVideoBackground:engineContext:slot:
renderBackground:engineContext:passInstance:
clearCaches
profile
supportsMTLFeatureSet:
enablesDeferredShading
generatorWithProfile:
deferredGeneratorWithProfile:
programWithHashCode:engineContext:trackedResource:introspectionDataPtr:
renderSize
disableLinearRendering
renderTime
setDepthStencilState:
_handleCreateIfNeeded:
_allowGhostObjects
initWithCharacter:
setWalkingDirection:
canJump
jump
setVelocity:
velocity
setJumpSpeed:
jumpSpeed
_update
_characterController
_ghostObject
_filterCallback
_capsuleShape
dataWithCapacity:
writeToURL:atomically:
setReferenceURL:
willChangeValueForKey:
hasPrefix:
didChangeValueForKey:
_isNameUnique:
_diffObject:with:path:
properties
slotName
particleSystems
_diffNode:with:path:
removeAllOverrides
_resolveURL
_loadReferencedSceneWithURL:catalog:
setValue:forKeyPath:
valueForKeyPath:
removeParticleSystem:
addParticleSystem:
_applyUnsharing:alreadyShared:
replaceMaterialAtIndex:withMaterial:
_applyOverride:forKeyPath:
setLoadingPolicy:
assetCatalogWithURL:
bundleURL
scheme
isFileURL
relativePath
isAbsolutePath
URLByDeletingLastPathComponent
URLByAppendingPathComponent:
_loadWithCatalog:
_catalog
sceneWithURL:
sceneWithURL:options:error:
_loadWithURL:catalog:
_applyOverrides
assetCatalog
catalogURL
documentURL
referenceNodeWithURL:
collectOverrides
addOverride:forKeyPath:
removeForKeyPath:
overrides
setOverrides:
setOverride:forKeyPath:
_isAReference
referenceURL
unload
isLoaded
_loadWithURL:
loadingPolicy
_referenceURL
_overrides
_loadingPolicy
_catalogURL
_sourceDocumentURL
_reloadWithScene:
referenceSceneName
setReferenceSceneName:
referenceNodeName
setReferenceNodeName:
setReferenceName:
referenceName
repeatCount
repeatDuration
usesSceneTimeBase
setRepeatDuration:
animationNamed:
actionNamed:
setupWithActions:
componentsSeparatedByString:
setGeneratedTexturePath:
setClientCommandBuffer:
setClientRenderPassDescriptor:
setClientRenderCommandEncoder:
clientCommandQueue
mainScreen
maximumFramesPerSecond
reloadPipelinesIfNeeded
presentsWithTransaction
GPUEndTime
GPUStartTime
resetVolatileMeshes
resetVolatileMeshElements
presentDrawable:
present
addScheduledHandler:
setClientCommandQueue:
endFrameForEngineContext:
nextDrawable
_createResourceCommandBufferIfNeeded
_clearRenderCaches
irradianceTextureForEnvironmentTexture:renderContext:applySH:
resourceCommandBuffer
radianceTextureForEnvironmentTexture:engineContext:commandBuffer:
volatileBuffer
volatileOffset
effectiveIndexCount
effectiveIndexOffset
_updateProjectionMatrixForOrthographicSkyboxRenderingIfNeeded:
clearColor
renderResourceForProgramDesc:renderPassDescriptor:
setRasterizerStates:
setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:
_zFarForSkyboxRenderingProjectionMatrix:defaultZFar:
_setMeshBuffers:
_drawMeshElement:instanceCount:
setPrimitiveRange:
renderResourceForImage:sampler:options:engineContext:
startProcessingRendererElementsWithEngineIterationContext:
beginDeferredLighting
renderLight:lightType:lightData:
endDeferredLighting
debugOptions
drawWireframeOverlayForElements:range:store:passInstance:
stopProcessingRendererElements:
_drawPBRTextures
_drawShadowMaps
specularDFGTextureWithRenderContext:
registerSemantic:withBlock:
bufferAtIndices:
textureAtIndices:
defaultTexture
samplerAtIndices:
registerShadableArgumentBindingBlockForBuffers:textures:samplers:
registerArgument:frequency:needsRenderResource:block:
registerArgument:frequency:block:
areaLightPrecomputedDataTexture
radianceTextureForEffectSlot:
defaultCubeTexture
irradianceTextureForEffectSlot:
defaultLightingEnvironmentIrradianceTexture
frequency
addResourceBindingsForArgument:frequency:needsRenderResource:block:
registerUserBlockTrampoline:
volatileStride
setVolatileSize:
setVolatileBuffer:
setVolatileOffset:
volatileSize
lastObject
removeLastObject
setUsedCount:
_newMTLBufferFromPoolWithLength:
_recycleMTLBufferToPool:
_createPassWithVertex:fragment:
currentRenderPassDescriptor
renderWithEncoder:pass:commandQueue:
writeBytes:length:
_reduceStatsOfConstantBuffer:
initWithDevice:engineContext:
setPreferredFramesPerSecond:
preferredFramesPerSecond
setScreenTransform:
setWantsWideGamut:
wantsWideGamut
pendingGPUFrameCount
setDisableLinearRendering:
setReverseZ:
setIsOpaque:
_clearUnusedBindingPoints
resourceGroup
resourceQueue
beginFrame:
endFrameSceneSpecifics
endFrameWaitingUntilCompleted:
_reflectionProbeArrayTexture
_setReflectionProbeArrayTexture:
_clusterInfo
resourceBlitEncoder
newRenderTargetWithDescription:size:arrayLength:
_logLightingInformation
_setSceneBufferAtVertexIndex:fragmentIndex:
processRendererElements:count:engineIterationContext:
_prepareMaterialTextures:
setShowsAuthoringEnvironment:
collectsCompilationErrors
setCollectsCompilationErrors:
compilationErrors
createVolatileMeshElementOfType:primitiveCount:bytesPerIndex:
unmapVolatileMeshElement:
drawFullScreenQuadForPass:
currentRenderCommandEncoder
endRenderCommandEncoding
setCurrentPassHash:
setCurrentPassMaterial:
getCurrentPassHash
getCurrentPassMaterial
setDebugOptions:
setContentScaleFactor:
setEnablesDeferredShading:
shouldPresentAfterMinimumDuration
setShouldPresentAfterMinimumDuration:
superSamplingFactor
setSuperSamplingFactor:
setEnableARMode:
setShouldDelegateARCompositing:
generatedTexturePath
.cxx_construct
_currentFrameIndex
_superSamplingFactor
_screenTransform
_sampleCount
_needSuperSampling
_isValidationEnabled
_profile
_engineContext
_wantsWideGamut
_isOpaque
_disableLinearRendering
_useFunctionConstants
_reverseZ
_ownedCommandQueue
_inFlightSemaphore
_pendingGPUFrameCount
_textureTarget
_layerTarget
_drawable
_targetedFrameInterval
_shouldPresentAfterMinimumDuration
_shouldPresentWithTransaction
_currentRenderPassDescriptor
_originalRenderPassDescriptor
_renderSize
_currentCommandBuffer
_renderEncoder
_resourceCommandBuffer
_resourceBlitEncoder
_resourceComputeEncoder
_renderPassParameters
_currentStreamBufferIndices
_volatileBufferPools
_frameVolatileBufferPool
_volatileMeshes
_usedVolatileMeshElements
_freeVolatileMeshElements
_constantBufferPools
_frameConstantBufferPool
_frameTexturePool
_defaultDepthStencilState
_defaultSamplerState
_background2DProgram
_backgroundCubeProgram
_backgroundVideoProgram
_backgroundRasterizerStates
_initialTime
_resourceQueue
_resourceGroup
_shadowKernelBuffer
_processingContext
_seed
_frameUniforms
_sceneUniforms
_lightsData
_nodeUniforms
_lighting
_cache
_deferredRendering
_compositeRendering
_downSamplePipeline
_skCompositing
_debug
_showsAuthoringEnvironment
_compilationIssues
_counters
_renderGraph
_enableARMode
_shouldDelegateARCompositing
_clientRenderPassDescriptor
_clientRenderCommandEncoder
_clientCommandBuffer
_debugOptions
_contentScaleFactor
_clientCommandQueue
_generatedTexturePath
setVertexBuffers:offsets:withRange:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:
defaultProgramUsingTessellation:
tessellationVertexDescriptorHash
vertexDescriptorHash
frameBufferBindings
bindBlock
passBufferBindings
bufferSize
inputsCount
lightBufferBindings
semanticsCount
nodeBufferBindings
instanceCount
setBlendColorRed:green:blue:alpha:
useResource:usage:
setVertexSamplerState:atIndex:
initWithLength:
dataWithBytesNoCopy:length:freeWhenDone:
hasReferenceToPhysicsBody:
standardUserDefaults
boolForKey:
infoDictionary
sharegroup
initWithSharegroup:
textureWithName:scaleFactor:bundle:options:error:
SCN_displayLinkCallback:
initWithQueue:screen:block:
SCN_setupDisplayLinkWithQueue:screen:
usesSeparateWorkGroup
_renderingQueue
setDisplayLink:
displayLink
setPreferredFrameRate:
currentRunLoop
dateWithTimeIntervalSinceNow:
runMode:beforeDate:
_renderThreadPriority
_initializeDisplayLinkWithScreen:completionHandler:
deallocateElementAtOffset:
initWithPage:
_parentPage
addIndexesInRange:
firstIndex
removeIndex:
_allocateElement
initWithBuffer:elementSize:
isFull
hasFreeElementsLeft
newSubBuffer
_buffer
_elementSize
_freeIndices
_newSubBuffer
elementSize
_bufferSize
_pages
_currentAllocatorPage
_allocatorLock
bundleForClass:
newTextureUsingMTKTextureLoaderWithURL:options:
textureCubeDescriptorWithPixelFormat:size:mipmapped:
_bakeSphericalHamonicsBasedIrradianceTexture:forEnvironmentTexture:renderContext:applySH:
sphericalHarmonicsForEnvironmentTexture:order:commandBuffer:
setFragmentBytes:length:atIndex:
newRadianceTextureForEnvironmentTexture:engineContext:cpuAccessible:commandBuffer:
generateMipmapsForTexture:
_bakeStochasticIrradianceTexture:forEnvironmentTexture:mipmapLevelForSampling:useTextureView:renderContext:
textureForSamplingTexture:atSize:mipmapLevelCount:renderContext:
_operateOnDataUsingCompressionAlgorithm:operation:
scn_compressedDataUsingCompressionAlgorithm:
scn_uncompressedDataUsingCompressionAlgorithm:
scn_indexedDataEncodingHighWatermarkWithBytesPerIndex:
scn_indexedDataDecodingHighWatermarkWithBytesPerIndex:
scn_indexedDataEncodingDeltaWithBytesPerIndex:
scn_indexedDataDecodingDeltaWithBytesPerIndex:
scn_indexedDataEncodingTrianglePairsWithBytesPerIndex:
scn_indexedDataDecodingTrianglePairsWithBytesPerIndex:
unstageTexture:commandBuffer:
setThreadgroupMemoryLength:atIndex:
shFromCPU:commandBuffer:
initWithBodyA:frameA:bodyB:frameB:
initWithBody:frame:
jointWithBodyA:frameA:bodyB:frameB:
jointWithBody:frame:
frameA
setFrameA:
frameB
setFrameB:
maximumAngularLimit1
setMaximumAngularLimit1:
maximumAngularLimit2
setMaximumAngularLimit2:
maximumTwistAngle
setMaximumTwistAngle:
startCollectingPerformanceStatisticsForPid:
stopCollectingPerformanceStatisticsForPid:
performanceStatisticsForPid:
collectedShadersForPid:
defaultManager
temporaryDirectory
contentsOfDirectoryAtPath:error:
stringWithContentsOfFile:encoding:error:
removeItemAtURL:error:
stringByDeletingLastPathComponent
fileExistsAtPath:
createDirectoryAtURL:withIntermediateDirectories:attributes:error:
stringFromByteCount:countStyle:
stringByReplacingCharactersInRange:withString:
standardizedURL
stringWithContentsOfURL:encoding:error:
stringByStandardizingPath
dataUsingEncoding:
propertyListWithData:options:format:error:
dictionaryWithContentsOfURL:
JSONObjectWithData:options:error:
documentEnclosingURL
initForReadingFromData:error:
setDecodingFailurePolicy:
context
initForReadingWithData:secure:
setDocumentURL:
setContext:
setAssetCatalog:
lookUpKey
setLookUpKey:
lookUpFoundInstance
setLookUpFoundInstance:
currentMorphTargets
setCurrentMorphTargets:
_documentURL
_assetCatalog
_lookUpKey
_lookUpFoundInstance
_currentMorphTargets
drain
archivedDataWithRootObject:options:
skipMorphTargets
setSkipMorphTargets:
usedCount
_usedCount
_dataSource
string
setNeedsRenderResource:
setBindBlock:
setArgument:
setArgumentEncoder:
_needsRenderResource
_indices
_samplerIndices
_usedResources
_bindBlock
_argument
_argumentEncoder
setSemanticsCount:
setBufferSize:
_semantics
setInputsCount:
_inputs
_samplerInput
_vertexBuffers
_fragmentBuffers
_vertexTextures
_fragmentTextures
_vertexSamplers
_fragmentSamplers
index
matchesRenderPassDescriptor:
_computeUsageForArguments:function:
vertexBuffersUsageMask
setState:
vertexFunction
setVertexFunction:
fragmentFunction
setFragmentFunction:
setFrameBufferBindings:
setNodeBufferBindings:
setLightBufferBindings:
setPassBufferBindings:
setShadableBufferBindings:
_sceneBuffer
_program
_pass
_renderPassDesc
_buffersUsageMask
_texturesUsageMask
_samplersUsageMask
_vertexDescriptor
_vertexFunction
_fragmentFunction
_frameBufferBindings
_nodeBufferBindings
_lightBufferBindings
_passBufferBindings
_shadableBufferBindings
setComputeFunction:
_computeFunction
buildTessellationVertexDescriptorIfNeeded
stepRate
tessellationVertexDescriptor
setStageDescriptor:
_mutabilityTimestamp
_tessellationVertexDescriptor
_vertexDescriptorHash
_tessellationVertexDescriptorHash
_buffers
_elements
_stageDescriptor
_volatileBuffer
setPrimitiveType:
setIndexType:
_primitiveType
_indexCount
_instanceCount
_sharedIndexBufferOffset
_indexBuffer
_indexType
_effectiveIndexOffset
_effectiveIndexCount
setFinished:
performSelector:onTarget:
_selector
_target
moveByX:y:z:duration:
moveToX:y:z:duration:
rotateByX:y:z:duration:
rotateToX:y:z:duration:
rotateByAngle:aroundAxis:duration:
rotateToAxisAngle:duration:
rotateToX:y:z:duration:shortestUnitArc:
scaleBy:duration:
scaleTo:duration:
sequenceWithActions:
groupWithActions:
repeatAction:count:
repeatActionForever:
fadeInWithDuration:
fadeOutWithDuration:
fadeOpacityBy:duration:
fadeOpacityTo:duration:
runAction:onFirstChildWithName:
javaScriptActionWithDuration:script:
customActionWithDuration:actionBlock:
objectWithName:class:
editingModeEnabled
setEditingModeEnabled:
moveBy:duration:
moveTo:duration:
sequence:
group:
runBlock:
runAction:onChildNodeWithName:
javaScriptActionWithScript:duration:
timingFunction
setTimingFunction:
durationRange
setDurationRange:
timingMode
setTimingMode:
isRelative
setSpeed:
speed
_caction
wasPausedWithTarget:atTime:
willResumeWithTarget:atTime:
timeJumpWithTarget:timeOffset:
ratioForTime:
wasAddedToTarget:atTime:
wasRemovedFromTarget:atTime:
willStartWithTarget:atTime:
setKey:
setCompletionBlock:
_removeAction:forKey:
position
euler
setEuler:
rotation
setRotation:
usesEuler
setUsesEuler:
nodeWithNodeRef:
rotationRepresentation
eulerAngles
locationInNode:
nodeAtPoint:recursive:
isUserInteractionEnabled
parent
touchesBegan:withEvent:
touchesMoved:withEvent:
touchesEnded:withEvent:
touchesCancelled:withEvent:
_touchMap
_mouseIsDown
_rightMouseIsDown
_script
globalObject
setException:
evaluateScript:
exception
toString
setNode:
setComponent:
elementIndex
setScreenSize:
screenSize
isNodeManipulator
elementPosition
setElementIndex:
_screenSize
nodeManipulatorItemWithNode:screenSize:
setGizmo:
convertTransform:toNode:
_createBody
initWithType:shape:
bodyWithType:shape:
setMass:
physicsBody
isResting
setLinearRestingThreshold:
setAngularRestingThreshold:
_shapeHandleWithShape:owner:
_physicsWorldCreateIfNeeded:
moveToTransform:
presentationNode
physicsShape
mass
charge
setCharge:
friction
setFriction:
restitution
setRestitution:
rollingFriction
setRollingFriction:
damping
setDamping:
angularVelocity
setAngularVelocity:
angularDamping
setAngularDamping:
linearRestingThreshold
angularRestingThreshold
velocityFactor
setVelocityFactor:
angularVelocityFactor
setAngularVelocityFactor:
collisionBitMask
setCollisionBitMask:
contactTestBitMask
setContactTestBitMask:
allowsResting
setAllowsResting:
isAffectedByGravity
setAffectedByGravity:
usesDefaultMomentOfInertia
setUsesDefaultMomentOfInertia:
momentOfInertia
setMomentOfInertia:
centerOfMassOffset
setCenterOfMassOffset:
continuousCollisionDetectionThreshold
setContinuousCollisionDetectionThreshold:
commitImmediate
removePhysicsBody:handle:
addPhysicsBody:nodeRef:colGroup:colMask:colTest:
setPhysicsShape:
_didDecodeSCNPhysicsBody:
staticBody
dynamicBody
kinematicBody
respondsToCollision
setLinearSleepingThreshold:
linearSleepingThreshold
setAngularSleepingThreshold:
angularSleepingThreshold
continuousCollisionDetection
applyForce:impulse:
applyForce:atPosition:impulse:
applyTorque:impulse:
_activate
clearAllForces
setResting:
resetToTransform:
resetTransform
moveToPosition:
rotateToAxisAngle:
_ownerWillDie
_mass
_charge
_friction
_restitution
_rollingFriction
_continuousCollisionDetectionThreshold
_physicsShape
_type
_damping
_angularVelocity
_angularDamping
_velocityFactor
_angularVelocityFactor
_velocity
_ignoreGravity
_linearRestingThreshold
_angularRestingThreshold
_explicitMomentOfInertia
_momentOfInertia
_centerOfMassOffset
_collisionBitMask
_contactTestBitMask
_allowsResting
_isDefaultShape
_body
iesTextureForProfile:renderContext:
childNodeWithName:recursively:
runAction:
actionForKey:
runAction:afterActionWithKey:
_subSpriteKey
_actionKey
_waitForKeyedAction
_runOnSubSprite
_fired
_preTick:
commonInit
wakeUpAllBodies
removeBehavior:
parseSpecialKey:withPath:intoDestination:
initWithResult:
_rayTestWithSegmentFromPoint:toPoint:options:
arrayWithObject:
_createDynamicWorldIfNeeded
addBehavior:
_customEncodingOfSCNPhysicsWorld:
_customDecodingOfSCNPhysicsWorld:
setGravity:
setTimeStep:
_didDecodeSCNPhysicsWorld:
_physicsContact
initWithScene:
sceneWillDie
_isDefault
timeStep
contactDelegate
setContactDelegate:
removeAllBehaviors
objectInAllBehaviorsAtIndex:
allBehaviors
rayTestWithSegmentFromPoint:toPoint:options:
contactTestBetweenBody:andBody:options:
contactTestWithBody:options:
convexSweepTestWithShape:fromTransform:toTransform:options:
updateCollisionPairs
_needsRedraw
enumerateBodiesUsingBlock:
_reset
_findFieldAttachedToNode:
_updatePhysicsFieldsTransforms
_step:
_defaultVehicleRayCaster
_drawDebugInAuthoringEnvironment:
_ghostPairCallback
_vehicleRayCaster
_debugDrawer
_aether
_hasActiveFields
_firstSimulationDone
_contactDelegate
_contact
_gravity
_speed
_scale
_timeStep
_fields
_elapsedTime
_behaviors
_activeBehaviors
_activeBehaviorsValid
_bodies
physicsWorld:didBeginContact:
physicsWorld:didUpdateContact:
physicsWorld:didEndContact:
getControlPointAtIndex:values:
functionWithControlPoints::::
SCN_simdMatrix4Value
SCN_arrayWithSimdMatrix4:
SCNVector4Value
valueWithBytes:objCType:
getValue:
valueWithCGRect:
objCType
valueWithCATransform3D:
CATransform3DValue
SCN_CGPointValue
SCN_valueWithCGPoint:
SCN_valueWithSimdMatrix4:
cameraRef
stringByResolvingSymlinksInPath
attributesOfItemAtPath:error:
timeIntervalSinceReferenceDate
globalGLSharedContext
initWithAPI:properties:
setGlobalGLSharedContext:
currentContext
_syncObjCModel
initWithLightRef:
parentWillDie:
initWithParent:propertyType:
_syncEntityObjCModel
initPresentationLightWithLightRef:
presentationLight
observeValueForKeyPath:ofObject:change:context:
identifier
setIdentifier:
setIntensity:
shadowColor
setShadowColor:
shadowRadius
setShadowRadius:
castsShadow
setCastsShadow:
shadowSampleCount
setShadowSampleCount:
orthographicScale
setOrthographicScale:
maximumShadowDistance
setMaximumShadowDistance:
automaticallyAdjustsShadowProjection
setAutomaticallyAdjustsShadowProjection:
shadowCascadeCount
setShadowCascadeCount:
gobo
copyPropertiesFrom:
IESProfileURL
setIESProfileURL:
areaType
setAreaType:
areaExtents
setAreaExtents:
areaPolygonVertices
setAreaPolygonVertices:
drawsArea
setDrawsArea:
doubleSided
probeType
setProbeType:
probeUpdateType
setProbeUpdateType:
probeExtents
setProbeExtents:
probeOffset
setProbeOffset:
parallaxCorrectionEnabled
setParallaxCorrectionEnabled:
probeEnvironment
setSpotFalloffExponent:
spotFalloffExponent
sphericalHarmonicsCoefficients
setSphericalHarmonicsCoefficients:
postCommandWithContext:object:key:applyBlock:
_resyncObjCModelOfPerTypeParameters
forcesBackFaceCasters
setForcesBackFaceCasters:
usesDeferredShadows
usesModulatedMode
setUsesDeferredShadows:
setUsesModulatedMode:
presentationMaterialProperty
valueWithCGPoint:
setIESProfileURL:resolvedURL:
encodeInt:forKey:
setSampleDistributedShadowMaps:
decodeIntForKey:
setShadowCascadeSplittingFactor:
_customEncodingOfSCNLight:
valueWithCGSize:
_customDecodingOfSCNLight:
setBaked:
setShouldBakeDirectLighting:
setShouldBakeIndirectLighting:
set_sphericalHarmonics:
setParallaxCenterOffset:
setParallaxExtentsFactor:
setWithObject:
setTemperature:
CGSizeValue
setShadowMapSize:
setShadowBias:
setTechnique:
_didDecodeSCNLight:
lightWithLightRef:
lightRef
copyAnimationChannelForKeyPath:property:
attributeForKey:
_sphericalHarmonics
shouldBakeDirectLighting
shouldBakeIndirectLighting
isBaked
shadowBias
shadowMapSize
technique
temperature
forceBackFaceCasters
setForceBackFaceCasters:
adjustsShadowProjection
setAdjustsShadowProjection:
sampleDistributedShadowMaps
shadowCascadeSplittingFactor
_shadowCascadeDebugFactor
set_shadowCascadeDebugFactor:
shadowMode
setShadowMode:
parallaxCenterOffset
parallaxExtentsFactor
hasGobo
_light
_castsShadow
_usesDeferredShadows
_usesModulatedMode
_baked
_shouldBakeDirectLighting
_shouldBakeIndirectLighting
_automaticallyAdjustsShadowProjection
_forcesBackFaceCasters
_sampleDistributedShadowMaps
_color
_shadowColor
_shadowRadius
_intensity
_temperature
_orthographicScale
_shadowMapSize
_shadowSampleCount
_shadowCascadeCount
_maximumShadowDistance
_shadowCascadeSplittingFactor
_cascadeDebugFactor
_zNear
_zFar
_shadowBias
_probeType
_probeUpdateType
_parallaxCorrectionEnabled
_probeExtents
_probeOffset
_parallaxExtentsFactor
_parallaxCenterOffset
_attenuationStartDistance
_attenuationEndDistance
_attenuationFalloffExponent
_spotInnerAngle
_spotOuterAngle
_spotFalloffExponent
_gobo
_IESProfileURL
_probeEnvironment
_areaType
_areaExtents
_areaPolygonVertices
_drawsArea
_doubleSided
sphericalHarmonicsLevel
CGPointValue
newLibraryWithFile:error:
initWithPath:manager:
_libraryURL
_manager
pathForResource:ofType:
strongToStrongObjectsMapTable
functionNames
newFunctionWithName:
preprocessorMacros
hashCodeForSource:macros:
newLibraryWithSource:options:error:
defaultLibrary
writeToURL:atomically:encoding:error:
collectShaderForProgram:newVertexFunctionName:newFragmentFunctionName:sourceCodeBlock:additionalFileBlock:
enumerateLinesUsingBlock:
newLibraryWithSource:options:completionHandler:
commonProfileCacheLibrary
shaderCompilationGroup
deviceQueue
libraryForFile:
libraryForProgramDesc:completionHandler:
_frameworkLibrary
_defaultLibrary
_deviceQueue
_shaderCompilationGroup
_commonProfileCacheLibrary
_commonProfilePrecompiledFunctions
_availableLibraries
_availableCompiledLibraries
_availableCompiledLibrariesLock
initWithMaterialRef:
ownerWillDie
materialRef
setVertexShader:
setFragmentShader:
setProgram:
initPresentationMaterialWithMaterialRef:
presentationMaterial
commonProfile
_materialPropertyClass
_setColor:
_setC3DImageRef:
_setupContentsFromC3DImage
clearCoat
clearCoatRoughness
clearCoatNormal
builtinProperties
customMaterialProperties
arrayByAddingObjectsFromArray:
_setupMaterialProperty:
_property:
isLitPerPixel
_hasDefaultValues
propertyName
_copyAttributes:
shininess
transparency
transparencyMode
setTransparencyMode:
lightingModelName
setLitPerPixel:
cullMode
locksAmbientWithDiffuse
setLocksAmbientWithDiffuse:
avoidsOverLighting
setAvoidsOverLighting:
fillMode
fresnelExponent
setFresnelExponent:
writesToDepthBuffer
setWritesToDepthBuffer:
readsFromDepthBuffer
setReadsFromDepthBuffer:
colorBufferWriteMask
blendMode
setBlendMode:
copyShaderModifiersFrom:
unlinkCustomPropertyWithParent:
linkCustomPropertyWithParent:andCustomName:
initWithOwner:
_setupShadableHelperIfNeeded
setShaderModifiers:
shaderModifiers
__shadableHelper
copyModifiersFrom:
shaderModifiersArgumentsNames
handleUnbindingOfSymbol:usingBlock:
_shadableSetValue:forUndefinedKey:
_setAttributes:
_customEncodingOfSCNMaterial:
_customDecodingOfSCNMaterial:
setIndexOfRefraction:
setSelfIlluminationOcclusion:
materialWithMaterialRef:
materialWithColor:
materialWithContents:
accessInstanceVariablesDirectly
resolveInstanceMethod:
materialNamed:
indexOfRefraction
selfIlluminationOcclusion
litPerPixel
content
setContent:
materialRefCreateIfNeeded
customMaterialPropertyNames
customMaterialAttributeNames
customMaterialAttributes
_ambient
_diffuse
_specular
_emission
_reflective
_transparent
_multiply
_normal
_ambientOcclusion
_selfIllumination
_metalness
_roughness
_displacement
_clearCoat
_clearCoatRoughness
_clearCoatNormal
_valuesForUndefinedKeys
_shininess
_transparency
_indexOfRefraction
_fresnelExponent
_selfIlluminationOcclusion
_transparencyMode
_lightingModelName
_cullMode
_shadableHelper
_litPerPixel
_locksAmbientWithDiffuse
_avoidsOverLighting
_writesToDepthBuffer
_readsFromDepthBuffer
_fillMode
_blendMode
_colorBufferWriteMask
URLForResource:withExtension:subdirectory:
dataWithContentsOfURL:
setClass:forClassName:
setRequiresSecureCoding:
particleSystemRef
geometryWithGeometryRef:
setEmitterShape:
setParticleColor:
particleImage
setParticleImage:
emissionDuration
setEmissionDuration:
emissionDurationVariation
setEmissionDurationVariation:
idleDuration
setIdleDuration:
idleDurationVariation
setIdleDurationVariation:
birthRate
setBirthRate:
birthRateVariation
setBirthRateVariation:
warmupDuration
setWarmupDuration:
emitterShape
birthLocation
setBirthLocation:
birthDirection
setBirthDirection:
emittingDirection
setEmittingDirection:
orientationDirection
setOrientationDirection:
acceleration
setAcceleration:
spreadingAngle
setSpreadingAngle:
isLocal
setIsLocal:
affectedByGravity
affectedByPhysicsFields
setAffectedByPhysicsFields:
physicsCollisionsEnabled
setPhysicsCollisionsEnabled:
isLightingEnabled
setLightingEnabled:
areSoftParticlesEnabled
setSoftParticlesEnabled:
particleDiesOnCollision
setParticleDiesOnCollision:
isBlackPassEnabled
setBlackPassEnabled:
particleAngle
setParticleAngle:
particleAngleVariation
setParticleAngleVariation:
particleVelocity
setParticleVelocity:
particleVelocityVariation
setParticleVelocityVariation:
particleAngularVelocity
setParticleAngularVelocity:
particleAngularVelocityVariation
setParticleAngularVelocityVariation:
particleLifeSpan
setParticleLifeSpan:
particleLifeSpanVariation
setParticleLifeSpanVariation:
particleBounce
setParticleBounce:
particleBounceVariation
setParticleBounceVariation:
particleFriction
setParticleFriction:
particleFrictionVariation
setParticleFrictionVariation:
particleCharge
setParticleCharge:
particleChargeVariation
setParticleChargeVariation:
particleColor
particleColorVariation
setParticleColorVariation:
systemSpawnedOnCollision
setSystemSpawnedOnCollision:
systemSpawnedOnDying
setSystemSpawnedOnDying:
systemSpawnedOnLiving
setSystemSpawnedOnLiving:
particleSize
setParticleSize:
particleSizeVariation
setParticleSizeVariation:
seed
setSeed:
renderingMode
setRenderingMode:
orientationMode
setOrientationMode:
imageSequenceAnimationMode
setImageSequenceAnimationMode:
particleGeometries
setParticleGeometries:
colliderNodes
setColliderNodes:
propertyControllers
setPropertyControllers:
sortingMode
setSortingMode:
particleMass
setParticleMass:
particleMassVariation
setParticleMassVariation:
dampingFactor
setDampingFactor:
speedFactor
setSpeedFactor:
fixedTimeStep
setFixedTimeStep:
stretchFactor
setStretchFactor:
imageSequenceRowCount
setImageSequenceRowCount:
imageSequenceColumnCount
setImageSequenceColumnCount:
imageSequenceInitialFrame
setImageSequenceInitialFrame:
imageSequenceInitialFrameVariation
setImageSequenceInitialFrameVariation:
imageSequenceFrameRate
setImageSequenceFrameRate:
imageSequenceFrameRateVariation
setImageSequenceFrameRateVariation:
initWithParticleSystemRef:
initPresentationSystemWithSystemRef:
_updateParticleC3DImage:
softParticlesEnabled
lightingEnabled
blackPassEnabled
_customEncodingOfSCNParticleSystem:
particleSystemNamed:
_customDecodingOfSCNParticleSystem:
setParticleIntensity:
setParticleIntensityVariation:
particleSystem
particleSystemNamed:inDirectory:
particleSystemWithParticleSystemRef:
typeOfProperty:
_setParticleImagePath:withResolvedPath:
setLocal:
lightEmissionRadiusFactor
setLightEmissionRadiusFactor:
particleIntensity
particleIntensityVariation
handleEvent:forProperties:withBlock:
addModifierForProperties:atStage:withBlock:
removeModifiersOfStage:
removeAllModifiers
_particleSystem
_emissionDuration
_emissionDurationVariation
_idleDuration
_idleDurationVariation
_birthRate
_birthRateVariation
_warmupDuration
_emitterShape
_birthLocation
_birthDirection
_emittingDirection
_orientationDirection
_acceleration
_spreadingAngle
_isLocal
_affectedByGravity
_affectedByPhysicsFields
_physicsCollisionsEnabled
_lightingEnabled
_softParticlesEnabled
_particleDiesOnCollision
_blackPassEnabled
_particleAngle
_particleAngleVariation
_particleVelocity
_particleVelocityVariation
_particleAngularVelocity
_particleAngularVelocityVariation
_particleLifeSpan
_particleLifeSpanVariation
_particleBounce
_particleBounceVariation
_particleFriction
_particleFrictionVariation
_particleCharge
_particleChargeVariation
_particleImage
_particleColor
_particleColorVariation
_systemSpawnedOnCollision
_systemSpawnedOnDying
_systemSpawnedOnLiving
_particleSize
_particleSizeVariation
_particleIntensity
_particleIntensityVariation
_renderingMode
_orientationMode
_imageSequenceAnimationMode
_particleGeometries
_colliderNodes
_propertyControllers
_sortingMode
_particleMass
_particleMassVariation
_dampingFactor
_speedFactor
_fixedTimeStep
_stretchFactor
_lightEmissionRadiusFactor
_imageSequenceColumnCount
_imageSequenceRowCount
_imageSequenceInitialFrame
_imageSequenceInitialFrameVariation
_imageSequenceFrameRate
_imageSequenceFrameRateVariation
_referenceName
dictionaryWithCapacity:
setC3dAnimation:
inputScale
inputBias
inputOrigin
inputMode
inputProperty
_setParent:
initPresentationNodeWithNodeRef:
physicsField
_dump:
_dumpNodeTree:tab:
orientation
setOrientation:
pivot
setPivot:
renderingOrder
movabilityHint
setMovabilityHint:
rendererDelegate
setRendererDelegate:
setPhysicsField:
constraints
setConstraints:
authoringEnvironmentNode
focusBehavior
setFocusBehavior:
authoringEnvironmentCompanionNode
setAuthoringEnvironmentCompanionNode:
isGizmo
actionKeys
runAction:forKey:
skinner
setPhysicsBody:
_copyRecursively
initWithNodeRef:
_childNodesPassingTest:recursively:output:
childNodesPassingTest:recursively:
_enumerateChildNodesUsingBlock:
enumerateChildNodesUsingBlock:
_childNodesWithAttribute:output:recursively:
objectInChildNodesWithAttribute:firstOnly:
next
setNext:
initWithType:component:
_findComponentWithType:
_setComponent:withType:
cameraWithCameraRef:
presentationCamera
presentationGeometry
skinnerWithSkinnerRef:
_setBaseGeometry:
morpherWithMorphRef:
simdConvertPosition:toNode:
hitTestResultsFromHitTestResultRef:
_updateAffine
simdRotation
simdWorldOrientation
setSimdWorldOrientation:
simdOrientation
_quaternion
setSimdOrientation:
simdEulerAngles
setSimdEulerAngles:
setSimdPosition:
simdPosition
setSimdScale:
simdScale
setSimdRotation:
setWithObjects:
setSimdTransform:
simdTransform
setSimdWorldPosition:
simdWorldPosition
simdWorldTransform
setSimdPivot:
simdPivot
_removeComponentWithType:
_assignComponent:toContainerWithType:
__light
__skinner
skinnerRef
__morpher
morphRef
__camera
__geometry
filters
renderNode:renderer:arguments:
rendererWithContext:options:
substringWithRange:
_reSyncModelTree
countOfChildNodes
insertObject:inChildNodesAtIndex:
canAddChildNode:
insertObject:atIndex:
_setHasFocusableChild
_setPausedOrPausedByInheritance:
__insertObject:inChildNodesAtIndex:
removeObjectAtIndex:
__removeObjectFromChildNodesAtIndex:
removeObjectFromChildNodesAtIndex:
_updateFocusableCache
indexOfChildNode:
replaceObjectInChildNodesAtIndex:withObject:
simdGetBoundingSphereCenter:radius:
isPresentationInstance
getBoundingSphereCenter:radius:
setCenter:
setRadius:
setMin:
setMax:
setGeometryRef:
flattenedClone
isPaused
_focusableCandidates:
_isEffectivelyHidden
isFocusInteractionEnabled
_isEligibleForFocus
focusSystemForEnvironment:
requestFocusUpdateToEnvironment:
updateFocusIfNeeded
currentUIFocusEnvironment
removeActionForKey:
runAction:forKey:completionHandler:
constraintRef
entity
_removeDeadParticleSystem:
_particleSystems
_audioPlayers
simdConvertPosition:fromNode:
simdConvertVector:toNode:
simdConvertVector:fromNode:
simdConvertTransform:toNode:
simdConvertTransform:fromNode:
setBoundingBoxMin:max:
setFilters:
_customEncodingOfSCNNode:usePresentationInstance:
_encodeNodePropertiesWithCoder:
_customDecodingOfSCNNode:
_didDecodeSCNNode:
keyPathsForValuesAffectingPosition
keyPathsForValuesAffectingTransform
keyPathsForValuesAffectingRotation
keyPathsForValuesAffectingEulerAngles
keyPathsForValuesAffectingOrientation
keyPathsForValuesAffectingScale
runAction:completionHandler:
removeAllActions
hasActions
setNeedsFocusUpdate
shouldUpdateFocusInContext:
didUpdateFocusInContext:withAnimationCoordinator:
preferredFocusEnvironments
parentFocusEnvironment
focusItemContainer
soundIdentifierForFocusUpdateInContext:
preferredFocusedView
focusGroupIdentifier
canBecomeFocused
frame
didHintFocusMovement:
_initChildNodesArray
dump
_dumpTree
objectInChildNodesWithName:
enumerateNodesUsingBlock:
childNodesWithAttribute:recursively:
childNodeWithName:
jsChildNodesWithAttribute:
hitTestWithSegmentFromPoint:toPoint:options:
_registerAsObserver
_updateTransform
worldOrientation
setWorldOrientation:
quaternion
setQuaternion:
_setQuaternion:
_euler
_setPosition:
_setScale:
setWorldPosition:
worldPosition
isHittable
mutableChildNodes
isJoint
setIsJoint:
renderInContext:
objectInChildNodesAtIndex:
removeAllChilds
insertChildNode:atIndex:
replaceChildNode:with:
getFrustum:withViewport:
getBoundingSphere
getBoundingBox
_subdividedCopyWithSubdivisionLevel:
setPaused:
_isEligibleForFocusInteraction
actions
setEntity:
removeAllParticleSystems
countOfParticleSystems
objectInParticleSystemsAtIndex:
insertObject:inParticleSystemsAtIndex:
removeObjectFromParticleSystemsAtIndex:
replaceObjectInParticleSystemsAtIndex:withObject:
removeAllAudioPlayers
countOfAudioPlayers
objectInAudioPlayersAtIndex:
insertObject:inAudioPlayersAtIndex:
removeObjectFromAudioPlayersAtIndex:
replaceObjectInAudioPlayerAtIndex:withObject:
convertPosition:fromNode:
convertVector:toNode:
convertVector:fromNode:
convertTransform:fromNode:
authoringEnvironmentPresentationNode
setAuthoringEnvironmentPresentationNode:
_parent
_childNodes
_presentationInstance
_lightLoaded
_geometryLoaded
_cameraLoaded
_skinnerLoaded
_morpherLoaded
_paused
_pausedByInheritance
_affineUpToDate
_transformUpToDate
_hasPivot
_isJoint
_rotationRepresentation
_movability
_hidden
_ignoreAnimationWhenCopying_tmp
_focusBehavior
_isFocusableOrHasFocusableChild
_authoringEnvironmentNode
_hasComponentBitmask
_transform
_position
_rotation
_opacity
_renderingOrder
_components
_actions
_fixedBoundingBoxExtrema
_valueForKey
_rendererDelegate
simdLocalUp
simdLocalRight
simdLocalFront
simdWorldUp
simdWorldRight
simdWorldFront
simdLookAt:
simdLookAt:up:localFront:
simdLocalTranslateBy:
simdLocalRotateBy:
simdRotateBy:aroundTarget:
worldUp
worldRight
worldFront
lookAt:
lookAt:up:localFront:
localTranslateBy:
localRotateBy:
rotateBy:aroundTarget:
localUp
localRight
localFront
bones
setBones:
_setRootNode:
sceneNamed:inDirectory:options:
URLByResolvingSymlinksInPath
sceneSourceWithURL:options:
sceneWithClass:options:error:
dictionaryWithDictionary:
sceneWithData:options:
sceneSourceWithData:options:
initWithSceneRef:
canImportFileExtension:
startDelay
frameRate
setFrameRate:
playbackSpeed
setPlaybackSpeed:
setUpAxis:
writeToURL:options:error:
writeToURLWithUSDKit:
exportAssetToURL:error:
writeToURL:options:delegate:progressHandler:
indexAtPosition:
initWithIndexes:length:
_nodeWithIndexPath:
URLWithString:
initWithURL:options:
_createSceneRefWithOptions:statusHandler:
initForJavascript:
lightingEnvironment
set_allowsDefaultLightingEnvironmentFallback:
_customEncodingOfSCNScene:
_didEncodeSCNScene:
_customDecodingOfSCNScene:
setRootNode:
setFogStartDistance:
setFogEndDistance:
setFogDensityExponent:
setWantsScreenSpaceReflection:
setScreenSpaceReflectionSampleCount:
setScreenSpaceReflectionMaximumDistance:
setScreenSpaceReflectionStride:
setFogColor:
_didDecodeSCNScene:
sceneNamed:
sceneNamed:options:
sceneWithURL:options:
sceneWithURL:atIndex:options:
sceneWithData:atIndex:options:
sceneWithSceneRef:
canImportFileUTI:
supportedFileUTIsForImport
supportedFileUTIsForExport
_indexPathForNode:
jsConstructor
_clearSceneRef
_setSourceURL:
_scenes
setSceneSource:
sceneSource
root
setRootNode:forLayer:
rootNodeForLayer:
_scaleSceneBy:
background
_allowsDefaultLightingEnvironmentFallback
fogColor
fogEndDistance
fogDensityExponent
fogStartDistance
wantsScreenSpaceReflection
screenSpaceReflectionSampleCount
screenSpaceReflectionDepthThreshold
setScreenSpaceReflectionDepthThreshold:
screenSpaceReflectionMaximumDistance
screenSpaceReflectionStride
_dumpToDisk
addSceneAnimation:forKey:target:
addParticleSystem:withTransform:
setPausedForEditing:
isPausedForEditing
_subnodeFromIndexPath:
_prettifyForPreview
_sceneSource
_physicsWorld
_rootNode
_layerRootNode
_background
_environment
_userAttributes
_fogStartDistance
_fogEndDistance
_fogDensityExponent
_fogColor
_wantsScreenSpaceReflection
_screenSpaceReflectionSampleCount
_screenSpaceReflectionMaxRayDistance
_screenSpaceReflectionStride
_sourceURL
_pausedForEditing
viewport
passDescriptor
setPassDescriptor:
setViewMatrix:
projectionMatrix
setProjectionMatrix:
_passDescriptor
_viewport
encodeWaitForEvent:value:
encodeSignalEvent:value:
waitBeforeSubmittingRender:
signalAfterSubmittingRender:
waitEvent
setWaitEvent:
waitFrame
setWaitFrame:
signalEvent
setSignalEvent:
signalFrame
setSignalFrame:
_waitEvent
_waitFrame
_signalEvent
_signalFrame
transitionStartTime
setTransitionStartTime:
transition
setTransition:
outgoingPointOfView
setOutgoingPointOfView:
outgoingScene
setOutgoingScene:
renderingAPI
offscreenRendererWithDevice:size:
offscreenRendererWithContext:size:
setPointOfView:
setBackgroundColor:
sceneTime
setSceneTime:
setSize:
transitionPass
prepareRendererAtIndex:withScene:renderSize:pointOfView:parentRenderer:
_transitionStartTime
_transition
_outgoingScene
_outgoingPointOfView
completionHandler
_transitionPass
_renderers
antialiasingMode
set_antialiasingMode:
_updateEngineCallbacks
_UIOrientationDidChangeNotification:
window
windowScene
interfaceOrientation
sharedApplication
statusBarOrientation
globalMetalDevice
setGlobalMetalDevice:
setPrefersOpenGL:
deviceForOptions:
_initWithOptions:isPrivateRenderer:privateRendererOwner:clearsOnDraw:context:renderingAPI:
pointOfView
removeSourceRenderersForEngineContext:
metalLayer
adjustViewportForRendering:
_invalidateFramebuffer
setDrawableSize:
_prepareSKRenderer
_prepareRenderTarget
_renderer:inputTimeForCurrentFrameWithTime:
setInputTime:
_deleteGLFramebuffer
_createPrepareFramebufferIfNeeded
_createOffscreenFramebufferIfNeeded
_prepareGLRenderTarget
scn_backingLayer
renderbufferStorage:fromDrawable:
metalDevice
maxTextureWidth2D
maxTextureHeight2D
_preparePixelFormat
_antialiasingMode
animationDuration
disableActions
postNotificationName:object:
setFromValue:
setToValue:
hasCustomProjectionTransform
xFov
projectionDirection
_projectPoint:viewport:
_unprojectPoint:viewport:
setImmediateModeRestrictedContext:
_getFrameIndex
renderer:didRenderScene:atTime:
_renderer:didRenderScene:atTime:
_renderer:willRenderScene:atTime:
renderer:willRenderScene:atTime:
_renderer:subdivDataForHash:
_renderer:didBuildSubdivDataForHash:dataProvider:
_isEditor
pausesIncomingScene
pausesOutgoingScene
setAnimationDuration:
_prepareForTransition:outgoingScene:outgoingPointOfView:completionHandler:
_defaultPOVForScene:
_c3dBackgroundColorDidChange
rendererWithDevice:options:
_contentsScaleFactor
setBackingScaleFactor:
_setupSKRendererIfNeeded
scaleMode
_sceneDidUpdate:
removeObserver:name:object:
_overlaysDidUpdate:
_installContext
_beginFrame
_endFrame
set_preparePixelFormat:
colorPixelFormat
_collectCompilationErrors
_renderContextMetal
_preparePreloadRenderer:
_prepareObject:shouldAbortBlock:
_releasePreloadRenderer
currentProgress
isCancelled
_preloadResource:abortHandler:
progressWithTotalUnitCount:
becomeCurrentWithPendingUnitCount:
resignCurrent
renderer:updateAtTime:
renderer:didApplyAnimationsAtTime:
renderer:didSimulatePhysicsAtTime:
renderer:didApplyConstraintsAtTime:
_renderer:updateAtTime:
_renderer:didApplyAnimationsAtTime:
_renderer:didSimulatePhysicsAtTime:
_renderer:didApplyConstraintsAtTime:
setPlaying:
_setSceneTime:
updateCurrentTimeIfPlayingWithSystemTime:
authoringEnvironmentForSceneRenderer:createIfNeeded:
applicationState
_systemTime
_updateSystemTimeAndDeltaTimeWithCurrentTime:
_update:
_updateWithSystemTime:
_needsRepetitiveRedraw
render:
_hitTest:viewport:options:
_isNodeInsideFrustum:withPointOfView:viewport:
_nodesInsideFrustumWithPointOfView:viewport:
_play
_pause
setupAuthoringEnvironment
_resolveAndDiscardGL
presentRenderbuffer:
set_showsAuthoringEnvironment:
setAuthoringDisplayMask:
usesReverseZ
_compilationErrors
_reloadDebugOptions
currentViewport
_drawAtTime:
setUsesReverseZ:
isJitteringEnabled
isTemporalAntialiasingEnabled
_renderSceneWithEngineContext:sceneTime:
_computeNextFrameTime
set_nextFrameTime:
updateAndDrawStatisticsIfNeeded
_needsRedrawAsap
_drawSceneWithNewRenderer:
_drawSceneWithLegacyRenderer:
_clearBackBuffer
set_systemTime:
set_deltaTime:
_installViewport
_duration
settingsForTransition:atTime:renderIncomingToTexture:renderOutgoingToTexture:renderIncomingToScreen:renderOutgoingToScreen:
set_viewport:
renderAtTime:
_drawScene:
MTLTexture
renderTransition:withInputTexture:outputTexture:time:encoder:pass:commandQueue:
textureID
renderTransition:withInputTexture:outputTexture:inputTextureSize:outputTextureSize:time:
_updatePointOfView
_renderAtTime:
_renderAtTime:viewport:encoder:passDescriptor:commandQueue:commandBuffer:
clearDepth
renderWithViewport:commandBuffer:passDescriptor:
renderWithCommandBuffer:viewPoints:
_installGLContextAndSetViewport
createSnapshot:
imageWithCGImage:
_createSnapshotAtTime:withSize:antialiasingMode:
_setBackingSize:
snapshotRendererWithSize:
_computedLightingEnvironmentMapsPath
set_computedLightingEnvironmentMapsPath:
_setupOffscreenRendererWithSize:
setOverlaySKScene:
setJitteringEnabled:
autoenablesDefaultLighting
setAutoenablesDefaultLighting:
autoAdjustCamera
setAutoAdjustCamera:
isPlaying
setDelegate:
set_superSamplingFactor:
set_screenTransform:
set_collectCompilationErrors:
__setTransitionContext:
updateProbes:atTime:
setResourceOptions:
renderAtTime:viewport:commandBuffer:passDescriptor:
_jitterRedisplay
_interfaceOrientationDidChange
_setInterfaceOrientation:
presentScene:withTransition:incomingPointOfView:completionHandler:
isNodeInsideFrustum:withPointOfView:
nodesInsideFrustumWithPointOfView:
projectPoint:
unprojectPoint:
prepareObject:shouldAbortBlock:
prepareObjects:withCompletionHandler:
setTemporalAntialiasingEnabled:
setShowsStatistics:
depthPixelFormat
stencilPixelFormat
audioEngine
audioEnvironmentNode
audioListener
setAudioListener:
_setContentsScaleFactor:
_backingSize
set_aspectRatio:
_aspectRatio
_rendererContextGL
setPointOfCulling:
pointOfCulling
_projectPoints:count:viewport:
_didRenderScene:
_willRenderScene:
_readSubdivCacheForHash:
_writeSubdivCacheForHash:dataProvider:
setScene:completionHandler:
resolvedBackgroundColorDidChange
disableOverlays
setDisableOverlays:
_copyPassDescription
_copyRenderGraphDescription
_renderGraphFrameRecordingAtPath:withCompletion:
_recordWithoutExecute
set_recordWithoutExecute:
programWithNode:withMaterial:
_wantsSceneRendererDelegationMessages
set_wantsSceneRendererDelegationMessages:
_shouldForwardSceneRendererDelegationMessagesToPrivateRendererOwner
set_shouldForwardSceneRendererDelegationMessagesToPrivateRendererOwner:
_nextFrameTime
currentTime
setCurrentTime:
_drawOverlaySceneAtTime:
_stop
setRendersContinuously:
jitteringEnabled
temporalAntialiasingEnabled
frozen
setFrozen:
_copyPerformanceStatistics
_displayLinkStatsTick
_displayLinkStatsTack
_runningInExtension
_presentFramebuffer
_enablesDeferredShading
set_enablesDeferredShading:
set_disableLinearRendering:
_drawableSafeAreaInsets
set_drawableSafeAreaInsets:
_drawWithJitteringPresentationMode
_draw
renderAtTime:viewport:encoder:passDescriptor:commandQueue:
renderAtTime:commandBuffer:viewPoints:
renderWithViewpoints:events:
snapshotAtTime:
snapshotAtTime:withSize:antialiasingMode:
_updateProbes:withProgress:
copySnapshotWithSize:
initOffscreenRendererWithSize:options:
privateRendererOwner
_pointOfView
_pointOfCulling
_lock
__renderingQueue
__antialiasingMode
__preparePixelFormat
_framebufferInfo
_mtlTexture
_viewPoints
_pointOfViewWasSet
_shouldDeleteFramebuffer
_rendersContinuously
_isPrivateRenderer
_isViewPrivateRenderer
_renderingSnapshot
_renderingPrepare
_autoUpdate
_currentSceneTime
_currentSystemTime
_deltaTime
_forceSystemTime
_lastSystemTime
__nextFrameTime
_transitionContext
_playing
_isAnimating
_adaptativeState0
_adaptativeEndFrame
_adaptativeTechniqueTimeStamp
_renderingAPI
__viewport
__aspectRatio
__drawableSafeAreaInsets
_glContext
_renderContext
_jitteringEnabled
_temporalAntialiasingEnabled
_frozen
_shouldForwardSceneRendererDelegationMessagesToSelf
_selfDelegationConformance
_privateRendererOwnerDelegationConformance
_delegationConformance
_backgroundColor
_c3dBackgroundColor
_preloadRenderer
_privateRendererOwner
_snapshotRenderer
_overlayRenderer
_overlayScene
_disableOverlays
_isRunningInExtension
_showStatistics
_showAuthoringEnvironment
_statisticsTimeStamp
snapshot
setAntialiasingMode:
CGPath
flatness
bezierPathWithCGPath:
setFlatness:
unarchivedObjectOfClasses:fromData:error:
setByAddingObject:
requiresSecureCoding
animationRef
keyPathSrc
keyPathDst
animationWithC3DAnimation:
_setAnimation:
pathComponents
pathForResource:ofType:inDirectory:
initWithContentsOfFile:
CGImage
imageNamed:
checkResourceIsReachableAndReturnError:
URLByStandardizingPath
groundColor
turbidity
sunElevation
upperAtmosphereScattering
groundAlbedo
horizonElevation
gamma
exposure
brightness
contrast
saturation
channelEncoding
dimensions
highDynamicRangeCompression
SCNMutableDeepCopy
keys
_setupFrom:
applyFunction:withContext:
_keys
_keyValues
addIndexes:
removeIndexes:
allObjects
_mutex
initWithName:channelEncoding:textureDimensions:turbidity:sunElevation:upperAtmosphereScattering:groundAlbedo:
setHorizonElevation:
setGamma:
setExposure:
setBrightness:
setContrast:
setSaturation:
unarchivedObjectOfClass:fromData:error:
setGroundColor:
setHighDynamicRangeCompression:
updateTexture
rangeValue
stringWithCapacity:
stringWithString:
scn_stringByReplacingCharactersInRanges:withStrings:
_convertToCA
_clearC3DCache
timingFunctions
setTimingFunctions:
tensionValues
setTensionValues:
continuityValues
setContinuityValues:
biasValues
setBiasValues:
keyPath
setAutoreverses:
autoreverses
setTimeOffset:
timeOffset
setFadeInDuration:
fadeInDuration
setFadeOutDuration:
fadeOutDuration
isRemovedOnCompletion
setCommitsOnCompletion:
commitsOnCompletion
setAnimationEvents:
animationEvents
isAdditive
setCumulative:
isCumulative
c3dAnimation
additive
cumulative
_c3dAnimation
_caReady
setTime:
setEventBlock:
animationEventWithKeyTime:block:
eventBlock
_eventTime
_eventBlock
fromValue
toValue
byValue
animationTimingFunction
functionWithName:
animationPlayerWithAnimationPlayerRef:
calculationMode
animationPlayerRef
caAnimation
SCN_evaluateAtTime:reverse:to:
initWithTimingFunctionRef:
functionWithTimingMode:
functionWithCAMediaTimingFunction:
c3dTimingFunction
_timingFunction
_setAnimationRef:
initWithC3DAnimation:
componentsJoinedByString:
isAppliedOnCompletion
fillsForward
fillsBackward
setStartDelay:
setAppliedOnCompletion:
setFillsForward:
setFillsBackward:
animationWithContentsOfURL:
animationFromScene:
initWithCAAnimation:
_didMutate
setBlendInDuration:
setBlendOutDuration:
animationDidStart
setAnimationDidStart:
animationDidStop
setAnimationDidStop:
blendInDuration
blendOutDuration
_optimizeKeyframesWithTarget:
subAnimations
_animationRef
_keyPath
_repeatCount
_timeOffset
_beginTime
_autoreverses
_removedOnCompletion
_applyOnCompletion
_additive
_cumulative
_usesSceneTimeBase
_fillForward
_fillBackward
_animationEvents
_fadeInDuration
_fadeOutDuration
_animationDidStart
_animationDidStop
_userInfo
_caAnimationCache
_userAnimation
initWithAnimationPlayerRef:
initWithSCNAnimation:
weight
setWeight:
paused
setBlendFactor:
stopWithBlendOutDuration:
animationPlayerWithAnimation:
blendFactor
stop
stopWithFadeOutDuration:
_playerRef
_animation
_weight
sortedArrayUsingComparator:
stiffness
initialVelocity
animationDidStart:
setByValue:
animationDidStop:finished:
_shouldCacheWithOptions:
sceneSourceOptions
_cachedSceneSourceForURL:options:
_cacheSceneSource:forURL:options:
_removeCachedSceneSourceIfNeededForURL:
initWithData:options:
sceneCount
sceneWithOptions:error:
errorWithDomain:code:userInfo:
localizedStringForKey:value:table:
dictionaryWithObjectsAndKeys:
assetCatalogForResourceURL:
_sceneWithClass:options:statusHandler:
sceneWithClass:options:statusHandler:
copyPropertiesAtIndex:options:
copyImageFromC3DImage:
longValue
_appendToEntries:entriesWithType:passingTest:entryObjectConstructor:
entryWithIdentifier:withClass:
identifiersOfEntriesWithClass:
sceneTypes
sceneFileTypes
unarchiver:cannotDecodeObjectOfClassName:originalClasses:
unarchiver:didDecodeObject:
unarchiver:willReplaceObject:withObject:
unarchiverWillFinish:
unarchiverDidFinish:
countOfScenes
sceneAtIndex:options:
sceneAtIndex:options:error:
sceneWithOptions:statusHandler:
propertyForKey:
sceneSourceRef
c3dDataRepresentation
entriesPassingTest:
entryWithID:withClass:
IDsOfEntriesWithClass:
sourceStatus
canExportToColladaWithNoDataLoss
performConsistencyCheck
_lastLoadedScene
_lastOptions
_sceneLoaded
_sceneSourceOptions
isEqualToDictionary:
rendererOptions
setRenderer:
setDevice:
setNeedsDisplayOnBoundsChange:
initWithLayer:
isMainThread
setPaused:nextFrameTimeHint:lastUpdate:
preferredFrameRate
setNeedsDisplay
getRed:green:blue:alpha:
setOpaque:
convertTime:fromLayer:
_checkAndUpdateDisplayLinkStateIfNeeded
keyPathsForValuesAffectingValueForKey:
_kvoKeysForwardedToRenderer
setByAddingObjectsFromSet:
automaticallyNotifiesObserversForKey:
display
play:
stop:
pause:
canDrawConcurrently
pauseDisplayLink
resumeDisplayLink
rendersIntoMaterial
setRendersIntoMaterial:
projectPoints:count:
_isGLLayerBacked
_systemTimeAnimationStarted:
contentLayer
scn_inLiveResize
_cancelJitterRedisplay
_supportsJitteringSyncRedraw
pause
syncTimeWithCoreAnimation
setSyncTimeWithCoreAnimation:
_jitterer
_renderer
_displayLink
_preferredFramePerSeconds
_lastRenderedTime
_drawForJittering
_rendersIntoMaterial
_syncTimeWithCoreAnimation
simdLocalCoordinates
simdWorldCoordinates
simdLocalNormal
simdWorldNormal
textureCoordinatesWithMappingChannel:
worldCoordinates
geometryIndex
boneNode
faceIndex
localCoordinates
localNormal
worldNormal
textureCoordinate
modelTransform
_result
simdModelTransform
newTextureForDevice:
cachedTextureWithURL:token:
setTextureProvider:
textureProvider
connectToProxy:
_textureProvider
renderToTexture:computeCommandHandler:blitCommandHandler:helper:
authoringEnvironmentForScene:createIfNeeded:
prepareScene:
addedNode:
setAutomaticallyAdjustsZRange:
setAuthoringCameraType:
setDisplayMask:
setFirstMaterial:
geometryForLightType:
particlesGeometry
cameraGeometry
cameraOrthographicFrustumGeometry
cameraFrustumGeometry
cameraNearPlaneGeometry
fieldGeometry
addLightNode:
addParticlesNode:
addCameraNode:
addPhysicsFieldNode:
removeLightNode:
removeParticlesNode:
removeCameraNode:
removePhysicsFieldNode:
setVertexFunctionName:
setFragmentFunctionName:
handleBindingOfBufferNamed:frequency:usingBlock:
_resetLightAuthoringWithContainerNode:source:light:
updateLightTypeForNode:source:light:screenspaceScalingFactor:
setupParticleMeshEmitter:authoringNode:
defaultCameraController
_updateRootsVisibility
simdTarget
authoringEnvironmentForScene:
authoringCameraNodes
manipulator
removedNode:
selectNode:
addNodeToSelection:
selectNodes:
cancelSelection
updateLightNode:withSourceNode:
updateParticlesNode:withSourceNode:
updateCameraNode:withSourceNode:
updateFieldNode:withSourceNode:
updateWithRenderer:
authoringLayer
displayMask
didTapAtPoint:
setAuthoringCamera:forView:
authoringCamera:
_selection
_layerRoot
_overlayLayerRoot
_lightRoot
_cameraRoot
_particlesRoot
_physicsFieldsRoot
_cameraTarget
_pointsOfViewRoot
_lightsDictionary
_camerasDictionary
_particlesDictionary
_physicsFieldsDictionary
_lightGeometry
_cameraFrustumGeometry
_cameraOrthographicFrustumGeometry
_cameraGeometry
_cameraNearPlaneGeometry
_particlesGeometry
_fieldGeometry
_displayMask
_paleGreen
_paleBlue
_red
_green
_blue
_cyan
_yellow
_orange
_pink
_grayLight
_grayMedium
_grayDark
_white
_manipulator
authoringCameraType
setValueForKey:optionKey:options:
pyramidWithWidth:height:length:
tubeWithInnerRadius:outerRadius:height:
capsuleWithCapRadius:height:
floor
planeWithWidth:height:options:
boxWithWidth:height:length:cornerRadius:options:
pyramidWithWidth:height:length:options:
sphereWithRadius:options:
cylinderWithRadius:height:options:
coneWithHeight:topRadius:bottomRadius:options:
tubeWithInnerRadius:outerRadius:height:options:
capsuleWithRadius:height:options:
torusWithRingRadius:pipeRadius:options:
floorWithOptions:
initWithGeometryRef:
reflectionFalloffStart
reflectionFalloffEnd
setReflectionFalloffStart:
setReflectionFalloffEnd:
_setupObjCModelFrom:
reflectivity
setReflectivity:
reflectionResolutionScaleFactor
setReflectionResolutionScaleFactor:
reflectionSampleCount
setReflectionSampleCount:
reflectionCategoryBitMask
setReflectionCategoryBitMask:
_customDecodingOfSCNFloor:
initWithFloorGeometryRef:
floorRef
reflectionFallOffStart
reflectionFallOffEnd
setReflectionFallOffStart:
setReflectionFallOffEnd:
__createCFObject
_usesCustomScaleFactor
_reflectivity
_reflectionFalloffStart
_reflectionFalloffEnd
_reflectionCategoryBitMask
_width
_length
_reflectionResolutionScaleFactor
_reflectionSampleCount
initWithCameraRef:
setXFov:
setYFov:
_updateFocalLength
initPresentationCameraWithCameraRef:
bloomIterationCount
setBloomIterationCount:
dofIntensity
setDofIntensity:
_updateFieldOfView
setProjectionDirection:
projectionTransformWithViewportSize:
wantsDepthOfField
setWantsDepthOfField:
focalBlurSampleCount
setFocalBlurSampleCount:
focalSize
setFocalSize:
lensShift
setLensShift:
automaticallyAdjustsZRange
wantsHDR
setWantsHDR:
whitePoint
setWhitePoint:
averageGray
setAverageGray:
wantsExposureAdaptation
setWantsExposureAdaptation:
exposureAdaptationDuration
setExposureAdaptationDuration:
exposureAdaptationBrighteningSpeedFactor
setExposureAdaptationBrighteningSpeedFactor:
exposureAdaptationDarkeningSpeedFactor
setExposureAdaptationDarkeningSpeedFactor:
exposureAdaptationHistogramRangeLowProbability
setExposureAdaptationHistogramRangeLowProbability:
exposureAdaptationHistogramRangeHighProbability
setExposureAdaptationHistogramRangeHighProbability:
exposureAdaptationMode
setExposureAdaptationMode:
minimumExposure
setMinimumExposure:
maximumExposure
setMaximumExposure:
bloomIntensity
setBloomIntensity:
bloomThreshold
setBloomThreshold:
bloomIterationSpread
setBloomIterationSpread:
bloomBlurRadius
setBloomBlurRadius:
vignettingPower
setVignettingPower:
vignettingIntensity
setVignettingIntensity:
colorFringeStrength
setColorFringeStrength:
colorFringeIntensity
setColorFringeIntensity:
grainIntensity
setGrainIntensity:
grainScale
setGrainScale:
grainIsColored
setGrainIsColored:
whiteBalanceTemperature
setWhiteBalanceTemperature:
whiteBalanceTint
setWhiteBalanceTint:
motionBlurIntensity
setMotionBlurIntensity:
screenSpaceAmbientOcclusionIntensity
setScreenSpaceAmbientOcclusionIntensity:
screenSpaceAmbientOcclusionRadius
setScreenSpaceAmbientOcclusionRadius:
screenSpaceAmbientOcclusionBias
setScreenSpaceAmbientOcclusionBias:
screenSpaceAmbientOcclusionDepthThreshold
setScreenSpaceAmbientOcclusionDepthThreshold:
screenSpaceAmbientOcclusionNormalThreshold
setScreenSpaceAmbientOcclusionNormalThreshold:
screenSpaceAmbientOcclusionSampleCount
setScreenSpaceAmbientOcclusionSampleCount:
screenSpaceAmbientOcclusionDownSample
setScreenSpaceAmbientOcclusionDownSample:
setProjectionTransform:
_customEncodingOfSCNCamera:
setExposureOffset:
_didDecodeSCNCamera:
keyPathsForValuesAffectingFieldOfView
keyPathsForValuesAffectingFocalLength
bloomIteration
setBloomIteration:
grainSlice
setGrainSlice:
grainTexture
setGrainTexture:
exposureOffset
_checkSettingsConsistency
aperture
setAperture:
fieldOfViewOrientation
setFieldOfViewOrientation:
xMag
setXMag:
yMag
setYMag:
projectionTransform
colorGrading
focalDistance
setFocalDistance:
_camera
_custom
_legacyFov
_usesOrthographicProjection
_automaticallyAdjustsZRange
_projectionDirection
_xFov
_yFov
_fieldOfView
_focalLength
_sensorSize
_lensShift
_fStop
_focusDistance
_dofIntensity
_bladeCount
_focalBlurSampleCount
_projectionTransform
_colorGrading
_wantsHDR
_whitePoint
_averageGray
_exposureOffset
_minimumExposure
_maximumExposure
_wantsExposureAdaptation
_exposureAdaptationDuration
_exposureAdaptationBrighteningSpeedFactor
_exposureAdaptationDarkeningSpeedFactor
_exposureAdaptationHistogramRangeHighProbability
_exposureAdaptationHistogramRangeLowProbability
_exposureAdaptationMode
_bloomIntensity
_bloomThreshold
_bloomIteration
_bloomIterationSpread
_bloomBlurRadius
_motionBlurIntensity
_vignettingPower
_vignettingIntensity
_colorFringeStrength
_colorFringeIntensity
_saturation
_contrast
_grainIntensity
_grainScale
_grainIsColored
_whiteBalanceTemperature
_whiteBalanceTint
_screenSpaceAmbientOcclusion
_grainTexture
_grainSlice
materialAttachmentWithGLKTextureInfo:
glID
setGlID:
propertyType
_clearContents
removeSourceRenderersForSource:
_animationPathForKey:
_updateMaterialColor:
_updateMaterialNumber:
textureSampler
_updateMaterialFilters
_presentationMappingChannel
effectSlotCreateIfNeeded:
_updateMaterialBorderColor:
_updateMaterialAttachment:
_textureOptions
copyC3DImageFromImage:textureOptions:wasCached:
_updateMaterialImage:
_updateC3DImageWithContents:
_updateMaterialSKScene:
_updateMaterialSKTexture:
_updateMaterialLayer:
_updateMaterialAVPlayer:
_updateMaterialTextureProvider:
setUiView:
setUiWindow:
_layerDidChange:
_updateMaterialUIComponent:
setImage:
setSkScene:
setSkTexture:
setAttachment:
setMtlTexture:
setUIView:
setUIWindow:
setAvPlayer:
image
_updateMaterialProceduralContents:
_updateMaterialMTLTexture:
__allocateContentTransformIfNeeded
_updateMaterialPropertyTransform:
_copyC3DImageFromImageData:typeID:
copyC3DImageFromImage:textureOptions:
initWithCGImage:
_copyImageFromC3DImage:
minificationFilter
magnificationFilter
wrapS
wrapT
sRGBTexture
setSRGBTexture:
materialPropertyWithContents:
initPresentationMaterialPropertyWithModelProperty:
borderColor4
_skSceneDidChange:
metalTexture
hasAlpha
filteringMode
usesMipmaps
setPlayer:
_customEncodingOfSCNMaterialProperty:
_customDecodingOfSCNMaterialProperty:
_didDecodeSCNMaterialProperty:
dvt_supportedTypesForPropertyContents
initWithParent:andCustomName:
__runtimeResolvedPath
color4
borderColor
setBorderColor:
attachment
pvrtcData
skScene
skTexture
avPlayer
UIView
maxAnisotropy
setProceduralContents:
proceduralContents
mtlTexture
_isCommonProfileProperty
_sRGB
_preventWarmup
_propertyType
_customSlotName
_borderColor
_contents
_contentType
_mappingChannel
_minificationFilter
_magnificationFilter
_mipFilter
_wrapS
_wrapT
_textureComponents
_maxAnisotropy
_customSlot
_c3dImage
_contentTransform
_runtimeResolvedPath
glTextureId
textureRect
isRotated
clientWillDie:
initWithMeshSource:
initWithMeshElement:
geometryDescription
_setGeometryRef:
initPresentationGeometryWithGeometryRef:
meshSource
meshElement
geometrySourceWithMeshSourceRef:
geometryElementWithMeshElementRef:
_setupGeometrySources
_setupGeometryElements
levelsOfDetail
setLevelsOfDetail:
subdivisionLevel
wantsAdaptiveSubdivision
_subdivisionSettings
set_subdivisionSettings:
tessellator
_copyAttributesTo:
_materialWithName:
_expand
mutableMaterials
_firstMaterial
removeMaterialAtIndex:
insertMaterial:atIndex:
replaceObjectInMaterialsAtIndex:withObject:
insertObject:inMaterialsAtIndex:
removeObjectFromMaterialsAtIndex:
removeAllMaterials
parseSpecialKey:withPath:intoDestination:remainingPath:
thresholdMode
thresholdValue
removeClient:
addClient:
tessellatorValueDidChangeForClient:
replaceMaterial:with:
removeMaterial:
_customEncodingOfSCNGeometry:
_customDecodingOfSCNGeometry:
_releaseCachedSourcesAndElements
geometrySourceForSemantic:
_hasFixedBoundingBoxExtrema
interleavedCopy
_renderableCopy
keyForNodeAttributes
materialWithName:
countOfMaterials
objectInMaterialsAtIndex:
edgeCreasesElement
edgeCreasesSource
_unifyNormals
_sources
_sourceChannels
_materials
_levelsOfDetail
_subdivisionLevel
_subdivisionIsAdaptive
_edgeCreasesSource
_edgeCreasesElement
_tessellator
mutableGeometrySourcesForSemantic:
mutateGeometrySourcesWithSemantics:usingBlock:
item
setItem:
timestamp
setTimestamp:
cacheObject:withTimestamp:forKey:
URLOfResourceNamed:
dataWithContentsOfFile:
enumeratorAtPath:
nextObject
caseInsensitiveCompare:
lookUpKeyForObjectNamed:class:
recursivePathsForResourcesOfType:inDirectory:
fileURLWithPath:isDirectory:
assetCatalogNamed:
clearCache
pathByMakingURLRelativeToCatalog:
sceneDatabase
addInstance:withName:class:
setAnimation:
setInputMode:
setInputScale:
setInputBias:
setInputOrigin:
setInputProperty:
_customEncodingOfSCNParticlePropertyController:
_customDecodingOfSCNParticlePropertyController:
particlePropertyControllerWithAnimation:
controllerWithAnimation:
_inputMode
_inputScale
_inputBias
_inputOrigin
_inputProperty
initWithSkinnerRef:
_setSkeleton:
set_bonesAndIndicesCompression:
_createSkinnerWithVertexCount:bones:boneWeights:boneIndices:baseGeometry:
bytesPerComponent
floatComponents
createSkinnerWithBaseGeometry:bones:boneWeights:boneIndices:
setBoneInverseBindTransforms:
_geometrySourceWithData:semantic:vectorCount:componentType:componentCount:dataOffset:dataStride:
baseGeometry
baseGeometryBindTransform
boneWeights
boneIndices
boneInverseBindTransforms
_createSkinnerWithCompressedData:bonesCount:vertexCount:
_skinnerWithBaseGeometry:skinnableGeometry:bones:boneInverseBindTransforms:bindMatrix:
wantsCPUSkinning
setWantsCPUSkinning:
_bonesAndIndicesCompression
setBaseGeometry:
joints
_skinner
_baseGeometry
_skeleton
_caDisplayLinkCallback
displayLinkWithTarget:selector:
targetTimestamp
addToRunLoop:forMode:
_isInvalidated
_callbackWithTime:
adaptativeFrameRate
setAdaptativeFrameRate:
queuedFrameCount
_cleanup
_caDisplayLink
_supportTargetTimestamp
_adaptativeFrameDuration
_invalidated
_lastFrameTime
_preferredFrameRate
_runningLock
_queuedFrameCount
initWithData:options:error:
entryNames
contentsForEntryName:
initWithEntryNames:contents:properties:options:
archiveData
dataWithContentsOfFile:options:error:
archive:contentsForEntryName:
archive:streamForEntryName:
archive:propertiesForEntryName:
inputStreamWithData:
writeToFile:options:error:
replaceBytesInRange:withBytes:
appendData:
initWithPath:options:error:
initWithEntryNames:dataProvider:options:
streamForEntryName:
writeContentsForEntryName:toFile:options:error:
propertiesForEntryName:
archiveStream
isValid
_data
_provider
_desc
_path
_names
_properties
_cachedContents
_reserved
_zFlags
_reserved2
fileSystemRepresentation
initWithBytes:length:encoding:
numberWithUnsignedLongLong:
setInertiaEnabled:
setInteractionMode:
setDrivenByDefaultNavigationCameraController:
sceneDidChange
cameraDidChange
gestureRecognizers
cameraController
inertiaEnabled
inertiaFriction
setInertiaFriction:
invalidateCameraTarget
_computeAutomaticTargetPointIfNeeded
setAutomaticCameraTarget:
interactionMode
isInertiaRunning
focusNodes:
_switchToFreeViewCamera
automaticTarget
setAutomaticTarget:
frameNodes:
_pointOfViewUsesOrthographicProjection
_pointOfViewOrthographicScale
setZoomFactor:
_resetFreeViewCamera
_prepareFreeViewCamera
view
enableFreeCamera
_freeCameraActivated
_installFreeViewCameraIfNeeded
_targetDistance
rollBy:aroundScreenPoint:viewport:
autoSwitchToFreeCamera
translateInCameraSpaceByX:Y:Z:
zoomBy:animate:
_orthographicScaleForZoomFactor:
_sceneBoundingSphere
zoomFactor
_orthographicZoomFactorForProposedZoomFactor:
_setPointOfViewOrthographicScale:
_cappedTranslationDelta:
_translationCoef
__didChangePointOfView
setSimdTarget:
updateInertiaAtTime:
setUp:
setSimdUp:
_defaultTargetForScene:
_stopInertia
_setupUpVector
stopInertia
setMinimumPressDuration:
setNumberOfTapsRequired:
_handlePinch:
addTarget:action:
_handlePan:
_handlePress:
_handleRotation:
_handleDoubleTap:
setDelaysTouchesBegan:
setCancelsTouchesInView:
enabled
beginGesture:
pinchWithGestureRecognizer:
panWithGestureRecognizer:
rotateWithGestureRecognizer:
switchToNextCamera
_willBeginInteraction
numberOfTouches
locationInView:
_startBrowsingIfNeeded:
_computeTranslationOrigin3DFromPoint:
__willChangePointOfView
rotateOf:
velocityInView:
endInteraction:withViewport:velocity:
beginInteraction:withViewport:
_modeSensitivity
continueInteraction:withViewport:sensitivity:
_translateToViewPoint:
panSensitivity
truckSensitivity
rotationSensitivity
willChangePointOfView
didChangePointOfView
setAutoSwitchToFreeCamera:
allowsTranslation
setAllowsTranslation:
flyModeVelocity
setFlyModeVelocity:
setPanSensitivity:
setTruckSensitivity:
setRotationSensitivity:
sceneWillChange
viewWillDrawAtTime:
viewDidDrawAtTime:
cameraWillChange
wantsRedraw
activateFreeCamera
setEnableFreeCamera:
freeCamera
setView:
cameraInertiaWillStartForController:
cameraInertiaDidEndForController:
initWithView:
enableInertia
setEnableInertia:
automaticCameraTarget
cameraTarget
setCameraTarget:
gimbalLockMode
setGimbalLockMode:
gimbalLockVector
setGimbalLockVector:
focusNode:
stickyAxis
setStickyAxis:
_effectiveStickyAxis
zoomBy:
translateByX:Y:Z:
gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:
gestureRecognizerShouldBegin:
cameraAutomaticTargetPoint
_computeBoundingSphereOmittingFloorsForNode:sphere:
_computeStickyAxisIfNeeded:
_pressGesture
_tapGesture
_pinchGesture
_panGesture
_rotateGesture
_isDraggingWithOneFinger
_lastGestureFingerCount
_browseMode
_cameraOriginalFieldOfView
_fieldOfViewZoomFactor
_originalOrthoScale
_orthographicZoomFactor
_translationAllowed
_didEverFocusNode
_isSceneBoundingSphereComputed
_cameraTargetComputed
_pinchShouldMoveCamera
_shouldUpdateTarget
_shouldIgnoreMomentumEvents
_isOrbiting
_recordingPointOfViewEvents
_mouseDown
_translationOrigin
_initialZoom
_initialPointOfViewWorldPosition
_lastKeyInputTime
_flyModeVelocity
_panSensitivity
_truckSensitivity
_rotationSensitivity
_initialInputLocation
_lastInputLocation
_accumulatedDrag
_lastRotationAngle
_drawAtTimeLock
_stickyAxis
_inertia
_keyboard
_scrollWheelModifiers
_enableFreeCamera
_autoSwitchToFreeCamera
_cameraController
_view
_freeViewCameraNode
initWithBodyA:anchorA:bodyB:anchorB:
initWithBody:anchor:
jointWithBodyA:anchorA:bodyB:anchorB:
jointWithBody:anchor:
addNormalsWithAttributeNamed:creaseThreshold:
_geometryByWeldingVerticesWithThreshold:normalThreshold:
_componentType
_geometryByUnifyingNormalsWithCreaseThreshold:
_geometryByAddingSourcesOfSkinner:
_geometryByRemovingSkinnerSources
_discardOriginalTopology
setConnectionPosition:
btVehicle
wheelWithNode:
suspensionStiffness
setSuspensionStiffness:
suspensionCompression
setSuspensionCompression:
suspensionDamping
setSuspensionDamping:
maximumSuspensionTravel
setMaximumSuspensionTravel:
frictionSlip
setFrictionSlip:
maximumSuspensionForce
setMaximumSuspensionForce:
connectionPosition
steeringAxis
setSteeringAxis:
axle
setAxle:
radius
suspensionRestLength
setSuspensionRestLength:
isFront
setIsFront:
_setVehicle:
_setWheelIndex:
_vehicle
_wheelIndex
_suspensionStiffness
_suspensionCompression
_suspensionDamping
_maximumSuspensionTravel
_frictionSlip
_maximumSuspensionForce
_connectionPosition
_steeringAxis
_axle
_radius
_suspensionRestLength
_isFront
_syncObjCModel:
initPresentationParametricGeometryWithParametricGeometryRef:
presentationPlane
cornerRadius
setCornerRadius:
widthSegmentCount
setWidthSegmentCount:
heightSegmentCount
setHeightSegmentCount:
cornerSegmentCount
setCornerSegmentCount:
initWithParametricGeometryRef:
_height
_cornerRadius
_widthSegmentCount
_heightSegmentCount
_cornerSegmentCount
presentationBox
setChamferRadius:
chamferRadius
lengthSegmentCount
setLengthSegmentCount:
chamferSegmentCount
setChamferSegmentCount:
_boxwidth
_boxheight
_boxlength
_boxchamferRadius
_boxwidthSegmentCount
_boxheightSegmentCount
_boxlengthSegmentCount
_boxchamferSegmentCount
_boxprimitiveType
presentationPyramid
_pyramidwidth
_pyramidheight
_pyramidlength
_pyramidwidthSegmentCount
_pyramidheightSegmentCount
_pyramidlengthSegmentCount
_pyramidprimitiveType
presentationSphere
isGeodesic
radialSpan
segmentCount
isHemispheric
setHemispheric:
geodesic
_sphereradius
_sphereradialSpan
_spheresegmentCount
_sphereprimitiveType
_spheregeodesic
_spherehemispheric
presentationCylinder
radialSegmentCount
setRadialSegmentCount:
_cylinderradius
_cylinderheight
_cylinderradialSpan
_cylinderheightSegmentCount
_cylinderradialSegmentCount
_cylinderprimitiveType
presentationCone
topRadius
bottomRadius
setTopRadius:
setBottomRadius:
_conetopRadius
_conebottomRadius
_coneheight
_coneheightSegmentCount
_coneradialSegmentCount
_coneprimitiveType
presentationTube
outerRadius
setInnerRadius:
setOuterRadius:
innerRadius
_tubeinnerRadius
_tubeouterRadius
_tubeheight
_tuberadialSpan
_tubeheightSegmentCount
_tuberadialSegmentCount
_tubeprimitiveType
presentationCapsule
capRadius
setCapRadius:
capSegmentCount
setCapSegmentCount:
_capsulecapRadius
_capsuleheight
_capsuleheightSegmentCount
_capsuleradialSegmentCount
_capsulecapSegmentCount
_capsuleprimitiveType
presentationTorus
ringRadius
pipeRadius
setPipeRadius:
ringSegmentCount
pipeSegmentCount
_torusringRadius
_toruspipeRadius
_torusradialSpan
_torusringSegmentCount
_toruspipeSegmentCount
_torusprimitiveType
cubemapTextureForLatlongTexture:pixelFormat:engineContext:needsMipmap:
newTextureWithContentsOfURL:options:error:
renderResourceForImageProxy:sampler:engineContext:
newTextureWithName:scaleFactor:bundle:options:error:
_textureDescriptorFromImage:needsMipMap:textureOptions:
_copyImage:toTexture:desc:textureOptions:needsMipMapGeneration:
convertTextureToCubeMapIfApplicable:engineContext:needsMipmap:
_enqueueCopyFromTexture:toTexture:blitEncoder:generateMipMaps:
latlongTextureForCubemap:pixelFormat:renderContext:needsMipmap:
defaultTexture3D
_setInertiaRunning:
simdUp
setPointOfView:updateUpTransform:
maximumVerticalAngle
maximumHorizontalAngle
setMaximumVerticalAngle:
setMaximumHorizontalAngle:
_translateInCameraSpaceByX:Y:Z:
_resetOrientationState
_rotateByX:Y:
_directionForScreenPoint:viewport:
useOrbitInteractionMode
unrolledWorldOrientation:
_mapToSphere:inViewport:
rotateByX:Y:
_updateArcballOrientation
_endDraggingWithVelocity:
drivenByDefaultNavigationCameraController
_updateRotation
_capOrientationAnglesToMaximum
_orientationForMode
_convertRotationFromWorldToPointOfView:
_updateInertiaAtTime:
scheduledTimerWithTimeInterval:repeats:block:
setWorldUp:
minimumVerticalAngle
minimumHorizontalAngle
setMinimumVerticalAngle:
setMinimumHorizontalAngle:
verticalMaximumAngle
horizontalMaximumAngle
setVerticalMaximumAngle:
setHorizontalMaximumAngle:
translateInScreenSpaceTo:viewport:
rollCameraSpaceBy:withPoint:viewport:
rollAroundTarget:
dollyToTarget:
clearRoll
lookAtWith:target:
dollyBy:onScreenPoint:viewport:
_targetRelativeToPointOfViewParent
_isLocationValid:inViewport:
_orientationState
_inputLocation
_arcball
_minimumAngles
_maximumAngles
_handlingInteraction
_drivenBydefaultNavigationCameraController
_automaticTarget
_interactionMode
_orthographicViewSpaceTranslationForZoomAtScreenPoint:scaleDelta:viewport:
geometrySourceWithVertices:count:
render:toMTLTexture:commandBuffer:bounds:colorSpace:
setEngineNotificationQueue:
engineNotificationQueue
newNodeAtPath:type:
newPropertyWithName:type:role:
scene:nodeAtPath:type:
node:propertyWithName:type:role:
tokenWithString:
objectPathWithString:
initWithToken:
initWithInt:
initWithDouble:
dataWithToken:
dataWithInt:
dataWithDouble:
dataWithString:
URLForDirectory:inDomain:appropriateForURL:create:error:
saveAndCreateUSDZPackageWithURL:
save
removeItemAtPath:error:
moveItemAtPath:toPath:error:
setWithCapacity:
regularExpressionWithPattern:options:error:
stringByReplacingMatchesInString:options:range:withTemplate:
decimalDigitCharacterSet
characterIsMember:
newSceneWithURL:
setDictionaryMetadataWithKey:dictionaryKey:value:
setMetadataWithKey:value:
setStringArray:
setDouble4x4Array:count:
setObjectPath:
setTokenValue:
setIntArray:count:
setFloat3Array:count:
setFloat2Array:count:
setBoolValue:
pathByAppendingPropertyComponent:
setConnectionWithTargetPaths:
stringByAppendingPathExtension:
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
copyItemAtPath:toPath:error:
writeToFile:atomically:
setFloat2Value:
setFloat4Value:
setResourcePath:
setTokenArray:
setObjectPathArray:
applyType:
setDouble4x4Value:atTime:
setFloatValue:atTime:
setFloat3Value:atTime:
setQuatfValue:atTime:
setDouble4x4Value:
setDouble3Value:
setQuatfValue:
setFloatArray:count:atTime:
setFloatArray:count:
setFloat3Array:count:atTime:
setQuatfArray:count:atTime:
maximumDrawableCount
setFenceEnabled:
screen
gamut
scn_setBackingLayer:
setDrawableProperties:
eaglContext
_enterForeground:
_enterBackground:
nativeScale
setContentMode:
setMultipleTouchEnabled:
_defaultBackgroundColor
setAllowsCameraControl:
setNavigationCameraController:
initWithFrame:options:
_selectRenderingAPIWithOptions:
initWithFrame:
_commonInit:
renderingAPIForOptions:
_isMetalSupported
set_ibPreferredRenderingAPI:
set_ibWantsMultisampling:
_ibWantsMultisampling
set_ibSceneName:
allowsCameraControl
_ibSceneName
_ibPreferredRenderingAPI
_flushDisplayLink
scn_setGestureRecognizers:
removeObserver:forKeyPath:
addObserver:forKeyPath:options:context:
_setNeedsDisplay
_updateOpacity
_scnUpdateContentsGravity
drawableResizesAsynchronously
setDrawableResizesAsynchronously:
_updateContentsScaleFactor
backingSizeForBoundSize:
lowLatency
isDrawableAvailable
layoutSubviews
_updateBackingSize
navigationCameraController
_flipY:
scn_updateGestureRecognizers
_adjustBackingLayerPixelFormat
traitCollection
performAsCurrentTraitCollection:
_backgroundDidChange
traitCollectionDidChange:
hasDifferentColorAppearanceComparedToTraitCollection:
willMoveFromView:
_didMoveToView:
eventHandler
_createDisplayLinkIfNeeded
setPointOfView:animate:
removeGestureRecognizer:
addGestureRecognizer:
hitTest:withEvent:
didMoveToWindow
willMoveToWindow:
startAndReturnError:
safeAreaInsetsDidChange
safeAreaInsets
_searchForFocusRegionsInContext:
searchArea
intersectsRect:
_getFocusableNodes
_focusFrameForSCNNode:
coordinateSpace
convertRect:toCoordinateSpace:
initWithFrame:item:
addRegion:
_getFocusNodes
_convertFrameToView:
_regionForFocusedItem:inCoordinateSpace:
layerClass
skipFramesIfNoDrawableAvailable
setSkipFramesIfNoDrawableAvailable:
set_renderOptions:
_renderOptions
asynchronousResizing
setAsynchronousResizing:
_resetContentsScaleFactor
cameraControlConfiguration
rendersContinuously
setEventHandler:
eventHandlerWantsRedraw
switchToCameraNamed:
ibPreferredRenderingAPI
setIbPreferredRenderingAPI:
ibSceneName
setIbSceneName:
ibWantsMultisampling
setIbWantsMultisampling:
_runFPSTestWithDuration:
setEaglContext:
displayLayer:
drawRect:
_controlsOwnScaleFactor
_focusedItemRegionContainer
_preferredFocusMovementStyle
__ibSceneName
__ibPreferredRenderingAPI
_ibNoMultisampling
_firstDrawDone
_drawOnMainThreadPending
_viewIsOffscreen
_appChangedColorAppearance
_appIsDeactivated
_autoPausedScene
_inRenderQueueForLayerBackedGLRendering
_isInLiveResize
_isHidden
_didTriggerRedrawWhileRendering
_displayLinkCreationRequested
_skipFramesIfNoDrawableAvailable
_backingLayer
_boundsSize
_snapshotImageData
_snapshotImageDataLength
_navigationCameraController
_spriteKitEventHandler
_controllerGestureRecognizers
_owners
initWithProfile:
_newProgramWithHashCode:engineContext:introspectionDataPtr:
releaseProgramForResource:
_programMutex
_shaders
_trackedResourcesToHashcode
fractionCompleted
removeObserver:forKeyPath:context:
initWithBlock:frequency:needsRenderResource:
_frequency
structType
arrayType
elementType
addPassResourceBindingsForArgument:
vertexArguments
_parseArguments:function:renderPipeline:
fragmentArguments
_searchArguments:forArgumentNamed:type:
_dictionaryForFrequency:
_checkForAssociatedSamplerOnBinding:argument:
deallocateRegistry
generateBindingsForPipeline:withReflection:program:material:geometry:pass:
_generateLock
_current
_nodeBindings
_frameBindings
_shadableBindings
_passBindings
_lightBindings
initWithMorphRef:
clearInBetweens
initPresentationMorpherWithMorphRef:
presentationMorpher
_weightIndexForTargetNamed:
setWeight:forTargetAtIndex:
weightForTargetAtIndex:
weightIndexStringForIndex:
subarrayWithRange:
setUnifiesNormals:
_encodeDataAsHalf
set_encodeDataAsHalf:
setCalculationMode:
unifiesNormals
_customEncodingOfSCNMorpher:
_customDecodingOfSCNMorpher:
_didDecodeSCNMorpher:
SCNUID_classForElementOfArray:
setWeight:forTargetNamed:
weightForTargetNamed:
channelTargetCounts
channelTargetWeights
setChannelTargetCounts:
setChannelTargetWeights:
targetsAndInBetween
_updateTargetsAndInBetween:
inBetweenTargetsForTargetAtIndex:
inBetweenWeightsForTargetAtIndex:
shouldMorphNormals
setShouldMorphNormals:
wantsCPUMorphing
shouldClearCPUDataAfterUpload
setShouldClearCPUDataAfterUpload:
weightIncrementalThreshold
setWeightIncrementalThreshold:
setWantsCPUMorphing:
convertToAdditiveWithBaseGeometry:
_isUsingSparseTargets
convertToSparseWithBaseGeometry:
_morpher
_calculationMode
_weights
_topLevelAndInBetweenTargets
_inBetweenCounts
_inBetweenInfluenceWeights
_targetNameToIndexes
_unifyNormal
_useSparseTargets
center
sharedInstance
add:
remove:
registerUIKitSource:
unregisterUIKitSource:
apply:
scnView
convertPoint:toLayer:
_warpPoint:outOfBounds:
superview
convertPoint:fromView:
subviews
_isSettingFirstResponder
_setFirstResponder:
_canBecomeKeyWindow
_hitTest:withEvent:windowServerHitTestWindow:
warpPoint:
uiView
setWindowLevel:
addSubview:
superlayer
prepareWindowIfNeeded
uiWindow
setUiWindowLayer:
setSource:
setup
_uiView
_uiWindow
_uiWindowLayer
_windowPreparing
_layerTreeDidUpdate
uiWindowLayer
source
_windowReady
_sizeCache
_textureID
_textureSampler
isMultipleTouchEnabled
canBecomeFirstResponder
setAnimationTimingFunction:
completionBlock
immediateModeRestrictedContext
currentState
checkUncommittedTransactions
dataByConvertingDoublesToFloats:count:
dataByConvertingColorData:colorSpace:newColorSpace:vectorCount:componentsPerVector:bytesPerComponent:dataOffset:dataStride:newDataOffset:newDataStride:
initWithData:semantic:colorSpace:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:
initWithData:semantic:vectorCount:componentType:componentCount:dataOffset:dataStride:
dataWithVector3Array:count:bytesPerComponent:
dataWithPointArray:count:bytesPerComponent:
initWithBuffer:vertexFormat:semantic:vertexCount:dataOffset:dataStride:
dataWithBytesNoCopy:length:
_uninterleaveData:count:srcOffset:srcStride:dstStride:
initWithBytesNoCopy:length:freeWhenDone:
decodePropertyListForKey:
raise:format:
geometrySourceWithNormals:count:
geometrySourceWithTextureCoordinates:count:
geometrySourceWithColorComponents:count:hasAlpha:colorSpace:
geometrySourceWithColorData:colorSpace:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:
geometrySourceWithBuffer:vertexFormat:semantic:vertexCount:dataOffset:dataStride:
_geometrySourceWithSource:vertexFormat:
_printData
_meshSource
_semantic
_vectorCount
_componentCount
_colorSpace
_dataOffset
_dataStride
_mkSemantic
_mtlBuffer
_mtlVertexFormat
mutableData
initWithBuffer:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:
initWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:
geometryElementWithBuffer:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:
geometryElementWithBuffer:primitiveType:primitiveCount:bytesPerIndex:
_optimizedGeometryElementWithData:primitiveType:primitiveCount:bytesPerIndex:
primitiveRange
pointSize
setPointSize:
minimumPointScreenSpaceRadius
setMinimumPointScreenSpaceRadius:
maximumPointScreenSpaceRadius
setMaximumPointScreenSpaceRadius:
_optimizeTriangleIndices
_computeACMR
_meshElement
_elementData
_primitiveCount
_primitiveRange
_indicesChannelCount
_interleavedIndicesChannels
_bytesPerIndex
_pointSize
_minimumPointScreenSpaceRadius
_maximumPointScreenSpaceRadius
engine
disconnectNodeInput:
disconnectNodeOutput:
detachNode:
attachNode:
initStandardFormatWithSampleRate:channels:
mainMixerNode
connect:to:format:
setListenerPosition:
setListenerVectorOrientation:
isRunning
sourceMode
setSourceMode:
pointSourceInHeadMode
setPointSourceInHeadMode:
obstruction
setObstruction:
occlusion
setOcclusion:
defaultAuthoringDisplayMask
_initWithEngineContext:
mutableCopyWithZone:
rendererForSceneRenderer:
_setupAuthoringEnv2:
setupAuthoringEnv2
authoringEnvironment2
sceneDidChange:
selectedItems
boundingRectWithSize:options:attributes:context:
initWithString:attributes:
drawAtPoint:
bezierPathWithOvalInRect:
fill
beginEditingNodes:
initWithArray:
selectedNodes
authoringEnvironmentForSceneRenderer:
selectionIsReadonly
setSelectionIsReadonly:
setEditingSpace:
cancelEdition
beginEditingNode:
saveInitialSelection
beginOrbiting
endOrbiting
drawLineFromPoint:toPoint:color:
drawString:atPoint:color:
isEditingSubComponent
setShouldSnapOnGrid:
setShouldSnapToAlign:
graphicalSelectionEnabled
setGraphicalSelectionEnabled:
surroundToSelect
setSurroundToSelect:
_sceneRenderer
_sceneRendererIsSCNView
_noColorProgram
_colorOnlyProgram
_colorAndTextureProgram
_lightProbesProgram
_wireframeProgram
_logsInfo
_boldLogsInfo
_dynamicLinesInfo
_dynamicLinesNoDepthTestInfo
_dynamicTrianglesInfo
_overlayDynamicLinesInfo
_overlayDynamicTriangleInfo
_textInfo
_lightProbesInfo
_normalTextInfo
_boldTextInfo
_depthOnCullOnStates
_depthOffCullOnStates
_depthOnCullOffStates
_depthOffCullOffStates
_arrowIndicesOffset
_arrowIndicesCount
_quadrantIndicesOffset
_quadrantIndicesCount
_quadrantRingIndicesOffset
_quadrantRingIndicesCount
_timedRecordingExpirationTime
_timedRecordingBuffer
_timedRecordingBufferStart
_timedRecordingBufferEnd
_authoringDisplayMask
_hasLighting
_shouldSnapOnGrid
_shouldSnapToAlign
_selectionIsReadonly
_editingSpace
_graphicalSelectionEnabled
_selectionP0
_selectionP1
_selecting
_surroundToSelect
_initialSelection
_selectedNodes
_lastGridDistance
_gridUnit
_visibleManipulableItems
_wireframeRenderer
_consoleLineCount
_statisticsInfo
_drawScale
_authEnv2
indexGreaterThanIndex:
monospacedSystemFontOfSize:weight:
fontWithName:size:
frontVector
_browseScale
viewedObjectSphere
updateBrowseScaleFactor
computeAutomaticTargetPoint
_resetBrowseScaleFactor
_rotateWithDrag:mode:stickyAxis:
_isInertiaRunning
_onInertiaTimer
_3DConnexionIsPressed
computeBoundingSphereOmittingFloorsForNode:sphere:
frontVectorWithPointOfView:
matrixWithNoRoll:
locationOfTouch:inView:
_beginTranslateAtLocation:
endDraggingWithVelocity:
translationInView:
setTranslation:inView:
_translateTo:
rotateWithVector:mode:
_initialPoint
_initialMatrix
_originalFovX
_originalFovY
_zoomFactor
_clickOrigin
_roll
_initialMatrixForRoll
_viewedObjectSphere
_isViewedObjectSphereComputed
_stateLock
_hasAutomaticCameraTarget
_automaticCameraTargetUpToDate
_allowsTranslation
_upDirIsSet
_gimbalLockMode
_inertiaRunning
_upDir
_autoCameraTarget
_browseScaleFactor
_totalDragWithInertia
_inertiaVelocity
_lastSimulationTime
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
valueWithRange:
_loadSourceCode
_newProgramWithHashCodeWithFunctionConstants:engineContext:introspectionDataPtr:
rangeOfString:options:range:
replaceCharactersInRange:withString:
reverseObjectEnumerator
insertString:atIndex:
_originalSourceCode
_injectionPointRanges
_originalLightingSourceCode
_lightingInjectionPointRanges
uppercaseString
textureSize
newTextureWithDescriptor:iosurface:plane:
glTextureCache
setGlTextureCache:
_mtlTextureCache
_glTextureCache
isPremultiplied
_createFramebufferWithEngineContext:size:
_usesIOSurface
_framebufferSize
_framebuffer
rendererWithMTLTexture:options:
rendererWithEAGLContext:options:
rendererDidChange:
_registry
drawInContext:atTime:
needsUpdate
contentSize
__updateTextureWithDelegate:engineContext:
initWithRenderer:size:attributes:outputURL:
main
error
renderMovieToURL:size:antialiasingMode:attributes:error:
setUserInfo:
setDidEndSelector:
_exportAsMovieOperationWithDestinationURL:size:attributes:delegate:didEndSelector:userInfo:
writeToURL:options:
exportAsMovieOperationWithDestinationURL:size:attributes:delegate:didEndSelector:userInfo:
succeded
progress
canceled
setCanceled:
cancel
userInfo
didEndSelector
setProgress:
setAttributes:
outputURL
setOutputURL:
setError:
setSucceded:
_didEndSelector
_startTime
_endTime
_canceled
_succeded
_progress
_error
_attributes
_outputURL
initWithMediaType:outputSettings:
setExpectsMediaDataInRealTime:
initWithAssetWriterInput:sourcePixelBufferAttributes:
initWithURL:fileType:error:
status
addInput:
startWriting
startSessionAtSourceTime:
pixelBufferPool
appendPixelBuffer:withPresentationTime:
isReadyForMoreMediaData
_copySnapshot:
renderAndAppendWithPresentationTime:usingAdaptor:metalTextureCache:cvQueue:completionBlock:
appendImage:withPresentationTime:usingAdaptor:
completedUnitCount
setCompletedUnitCount:
markAsFinished
requestMediaDataWhenReadyOnQueue:usingBlock:
finishWritingWithCompletionHandler:
_finishedExport
_setupMovieToWritableFile:
_assetWriterInput
_avAdaptor
_assetWriter
_rate
_mirrored
_supersampling
minimumLinearLimit
setMinimumLinearLimit:
maximumLinearLimit
setMaximumLinearLimit:
minimumAngularLimit
setMinimumAngularLimit:
maximumAngularLimit
setMaximumAngularLimit:
motorTargetLinearVelocity
setMotorTargetLinearVelocity:
motorMaximumForce
setMotorMaximumForce:
motorTargetAngularVelocity
setMotorTargetAngularVelocity:
motorMaximumTorque
setMotorMaximumTorque:
debugQuickLookObjectWithPointOfView:
debugQuickLookObject
debugQuickLookData
initWithContentsOfURL:options:error:
isAdaptive
isScreenSpace
tessellationFactorScale
tessellationPartitionMode
smoothingMode
edgeTessellationFactor
insideTessellationFactor
maximumEdgeLength
_tessellatorValueForGeometry:
tessellatorValueDidChange
setSmoothingMode:
adaptive
setAdaptive:
screenSpace
setScreenSpace:
setEdgeTessellationFactor:
setInsideTessellationFactor:
setMaximumEdgeLength:
_clients
_adaptive
_screenSpace
_maximumEdgeLength
_edgeTessellationFactor
_insideTessellationFactor
_tessellationFactorScale
_smoothingMode
_partitionMode
setFrame:
SCNJSExportProtocol
imageWithContentsOfFile:
imageWithURL:
imageWithPath:
vector3
vector4
matrix4
valueWithVector3:
valueWithVector4:
valueWithMatrix4:
color::::
toDouble
valueWithObject:inContext:
valueWithVector4:inContext:
valueWithVector3:inContext:
valueWithTransform3D:inContext:
toVector4
toVector3
toTransform3D
toBool
setValue:forProperty:
setPath:
setSemantic:forSymbol:options:
semanticForSymbol:
vertexShader
fragmentShader
tessellationControlShader
setTessellationControlShader:
tessellationEvaluationShader
setTessellationEvaluationShader:
geometryShader
setGeometryShader:
vertexFunctionName
fragmentFunctionName
weightAtTargetIndex:
setWeight:atTargetIndex:
screenSpaceRadius
worldSpaceDistance
levelOfDetailWithGeometry:screenSpaceRadius:
levelOfDetailWithGeometry:worldSpaceDistance:
influenceFactor
setInfluenceFactor:
isIncremental
setIncremental:
applyEngineForce:forWheelAtIndex:
setSteeringAngle:forWheelAtIndex:
applyBrakingForce:forWheelAtIndex:
speedInKilometersPerHour
wheels
chassisBody
vehicleWithChassisBody:wheels:
targetOffset
setTargetOffset:
setLocalFront:
upVector
setUpVector:
gimbalLockEnabled
setGimbalLockEnabled:
lookAtConstraintWithTarget:
extrusionDepth
setExtrusionDepth:
chamferMode
setChamferMode:
chamferProfile
setChamferProfile:
shapeWithPath:extrusionDepth:
initWithChainRootNode:
setMaxAllowedRotationAngle:forJoint:
maxAllowedRotationAngleForJoint:
chainRootNode
targetPosition
setTargetPosition:
inverseKinematicsConstraintWithChainRootNode:
transformConstraintInWorldSpace:withBlock:
positionConstraintInWorldSpace:withBlock:
orientationConstraintInWorldSpace:withBlock:
font
setFont:
isWrapped
setWrapped:
containerFrame
setContainerFrame:
textSize
truncationMode
setTruncationMode:
alignmentMode
setAlignmentMode:
textWithString:extrusionDepth:
valueForProperty:
isUndefined
_hasFired
numberWithChar:
charValue
unsignedCharValue
capitalizedString
numberWithShort:
shortValue
unsignedShortValue
_initializeWheelsArray
initWithChassisBody:wheels:
_createWheel:
wheelAtIndex:
_customDecodingOfSCNPhysicsVehicle:
_chassisBody
_wheels
_speedKmHour
copyTo:
setConstraintRef:
finalizeDecodeConstraint:
_constraintRef
_incremental
_influenceFactor
initWithTarget:
_customEncodingOfSCNLookAtConstraint:
_customDecodingOfSCNLookAtConstraint:
_gimbalLockEnabled
_targetOffset
_upVector
_localFront
maximumDistance
setMaximumDistance:
_customEncodingOfSCNDistanceConstraint:
_customDecodingOfSCNDistanceConstraint:
distanceConstraint
distanceConstraintWithTarget:
targetDirection
setTargetDirection:
keepTargetDirection
setKeepTargetDirection:
_maximumDistance
_keepTargetDirection
_targetDirection
_maximumDirectionAngle
replicatorConstraint
replicatesOrientation
setReplicatesOrientation:
replicatesPosition
setReplicatesPosition:
replicatesScale
setReplicatesScale:
orientationOffset
setOrientationOffset:
positionOffset
setPositionOffset:
scaleOffset
setScaleOffset:
_customEncodingOfSCNReplicatorConstraint:
_customDecodingOfSCNReplicatorConstraint:
replicatorConstraintWithTarget:
_replicateOrientation
_replicatePosition
_replicateScale
_orientationOffset
_positionOffset
_scaleOffset
maximumLinearVelocity
setMaximumLinearVelocity:
maximumLinearAcceleration
setMaximumLinearAcceleration:
decelerationDistance
setDecelerationDistance:
accelerationConstraint
_maximumLinearVelocity
_maximumLinearAcceleration
_decelerationDistance
collisionCategoryBitMask
setCollisionCategoryBitMask:
sliderConstraint
occluderCategoryBitMask
setOccluderCategoryBitMask:
bias
setBias:
avoidOccluderConstraint:shouldAvoidOccluder:forNode:
avoidOccluderConstraint:didAvoidOccluder:forNode:
_customEncodingOfSCNAvoidOccluderConstraint:
_customDecodingOfSCNAvoidOccluderConstraint:
avoidOccluderConstraint
avoidOccluderConstraintWithTarget:
setFreeAxes:
freeAxes
preserveScale
_freeAxes
_preserveScale
constantScaleConstraint
initTransformInWorld:withBlock:
initPositionInWorld:withBlock:
initOrientationInWorldSpace:withBlock:
joint
setJoint:
maxAllowedRotationAngle
setMaxAllowedRotationAngle:
setChainRootNode:
jointForNode:
_customEncodingOfSCNIKConstraint:
_customDecodingOfSCNIKConstraint:
_didDecodeSCNIKConstraint:
_chainRootNode
_ikTarget
_jointsPerNode
newFunctionWithName:constantValues:error:
setRasterSampleCount:
setDepthAttachmentPixelFormat:
setStencilAttachmentPixelFormat:
newRenderPipelineStateWithDescriptor:options:completionHandler:
newRenderPipelineStateWithDescriptor:completionHandler:
newRenderPipelineStateWithDescriptor:options:reflection:error:
newRenderPipelineStateWithDescriptor:error:
_createPipelineStateWithDescriptor:desc:pipeline:
setThreadGroupSizeIsMultipleOfThreadExecutionWidth:
setStageInputDescriptor:
newComputePipelineStateWithDescriptor:options:reflection:error:
_newComputeDescriptorForPipelineDesc:library:
_configureComputePipeline:withDescriptor:
newComputePipelineStateForDesc:library:
getUniqueStageDescriptor:
computePipelineStateForKernel:threadGroupSizeIsMultipleOfThreadExecutionWidth:
newComputePipelineStateWithFunctionName:library:constantValues:
stepFunction
indexBufferIndex
_repeatedAction
initWithPixelBufferAttributes:
setVideoSourceFormat:
currentItem
addOutput:
removeOutput:
unregisterPlayer:
discardVideoData
registerPlayer:
itemTimeForHostTime:
hasNewPixelBufferForItemTime:
copyPixelBufferForItemTime:itemTimeForDisplay:
player
_player
_videoOutput
_textureCache
_pixelBuffer
_texturePixelFormat
_videoSourceFormat
asset
tracksWithMediaCharacteristic:
setFrequency:
setSemantic:
infoWithSemantic:options:
postNotificationName:object:userInfo:
setSemanticInfos:
_customEncodingOfSCNProgram:
_customDecodingOfSCNProgram:
setSourceFile:
programWithLibrary:
shadingLanguage
sourceFile
_optionsForSymbol:
_allSymbolsWithSceneKitSemantic
_bufferBindings
setSemantic:forSymbol:
_vertexShader
_fragmentShader
_vertexFunctionName
_fragmentFunctionName
_sourceFile
_semanticInfos
_opaque
bundleWithIdentifier:
newDefaultLibraryWithBundle:error:
_stopObservingProgram
_programDidChange:
_setC3DProgram
_startObservingProgram
owner
initWithDictionary:copyItems:
_parseAndSetShaderModifier:
_updateC3DProgramInputForSymbol:
_programFromPassAtIndex:
_updateC3DProgramInput:forSymbol:
_updateAllC3DProgramInputs
_setC3DProgramDelegate
_customEncodingOfSCNShadableHelper:
_customDecodingOfSCNShadableHelper:
_didDecodeSCNShadableHelper:
_bindValueForSymbol:atLocation:programID:node:renderer:
_unbindValueForSymbol:atLocation:programID:node:renderer:
_shaderModifiers
_c3dShaderModifierCache
_argumentsNames
_symbolToBinder
_symbolToUnbinder
issueWithShadable:entryPoint:effectiveModifier:message:line:type:
shadable
entryPoint
effectiveModifier
message
line
_shadable
_entryPoint
_effectiveModifier
_message
_line
program:handleError:
patchFont:
initPresentationTextGeometryWithTextGeometryRef:
initWithTextGeometryRef:
fontName
params
_customEncodingOfSCNText:
_customDecodingOfSCNText:
setDiscretizedStraightLineMaxLength:
CGRectValue
set_wantsSeparateGeometryElements:
text
copyAnimationPathForKeyPath:animation:
_wantsSeparateGeometryElements
discretizedStraightLineMaxLength
_flatness
_chamferRadius
_extrusionDepth
_discretizedStraightLineMaxLength
_chamferProfile
_string
_font
_wrapped
_alignmentMode
_truncationMode
_useCustomContainerFrame
_customContainerFrame
__wantsSeparateGeometryElements
initPresentationShapeGeometryWithShapeGeometryRef:
_customEncodingOfSCNShape:
_customDecodingOfSCNShape:
initWithShapeGeometryRef:
_chamferMode
setAlignment:
setLineBreakMode:
attribute:atIndex:effectiveRange:
_setupWithGeometry:thresholdMode:value:
initWithGeometry:thresholdMode:lod:
_customEncodingOfSCNLevelOfDetail:
_didDecodeSCNLevelOfDetail:
initWithGeometry:thresholdMode:thresholdValue:
_lod
_mode
initWithUTF8String:
newComputePipelineStateWithFunction:error:
B16@0:8
@16@0:8
@24@0:8@16
v24@0:8@16
@24@0:8^{_NSZone=}16
^{SCNCActionHide=^^?f@?@BdddddBB@?^{__CFString}qddddB}
@32@0:8@16@24
@40@0:8@16@24Q32
@40@0:8@16@24@32
@100@0:8@16Q24B32Q36Q44Q52Q60q68@76Q84@92
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
@"NSArray"16@0:8
@"MDLAnimatedScalarArray"16@0:8
Q32@0:8^{?=[4]}16Q24
{?=[4]}16@0:8
@"NSData"16@0:8
v32@0:8@16@24
v64@0:8@16@24B32B36f40f44@?48@?56
@72@0:8@16@24@32@40^{SkelNodesMap={map<MDLSkeleton *, (anonymous namespace)::SkelNodes, std::__1::less<MDLSkeleton *>, std::__1::allocator<std::__1::pair<MDLSkeleton *const, (anonymous namespace)::SkelNodes> > >={__tree<std::__1::__value_type<MDLSkeleton *, (anonymous namespace)::SkelNodes>, std::__1::__map_value_compare<MDLSkeleton *, std::__1::__value_type<MDLSkeleton *, (anonymous namespace)::SkelNodes>, std::__1::less<MDLSkeleton *>, true>, std::__1::allocator<std::__1::__value_type<MDLSkeleton *, (anonymous namespace)::SkelNodes> > >=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<MDLSkeleton *, (anonymous namespace)::SkelNodes>, void *> > >={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::__map_value_compare<MDLSkeleton *, std::__1::__value_type<MDLSkeleton *, (anonymous namespace)::SkelNodes>, std::__1::less<MDLSkeleton *>, true> >=Q}}}}48@56@64
@72@0:8@16@24@32@?40@48@56@64
v48@0:8@?16@?24@32@40
v16@0:8
v24@0:8^{__C3DNode=}16
^{__C3DNode=}16@0:8
r^v16@0:8
@?16@0:8
v24@0:8@?16
^{__C3DScene=}16@0:8
v20@0:8B16
@"AVAudioNode"
@"AVAudioPlayerNode"
@"SCNAudioSource"
^{__C3DNode=}
^{__C3DScene=}
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
q16@0:8
d16@0:8
f16@0:8
v20@0:8f16
@"AVAudioFile"
@"AVAudioPCMBuffer"
@"NSURL"
@"NSString"
@"CALayer"
v40@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32
v56@0:8@16{CGSize=dd}24B40B44@48
d76@0:8@16@24^{__C3DEngineContext=}3240d56B64^B68
d48@0:8@16@24^{__C3DEngineContext=}32^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}40
v24@0:8^{__C3DRendererContext={__CFRuntimeBase=QAQ}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBB^{__CFDictionary}I^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}{Cache=[8I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^vii}{?=[2I][5i][14{?=iII}][14I]^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}16
{CGSize=dd}16@0:8
^{__C3DTexture=}40@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32
@40@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32
v64@0:8r^^{__C3DMeshSource}16^s24I32^v36I44Q48B56f60
v40@0:8q16^{__C3DMorph=}24^{__C3DMesh=}32
@40@0:8^{__C3DMorph=}16^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}24@32
{?=*@Q}24@0:8Q16
I16@0:8
B24@0:8^{__C3DMorph=}16
v48@0:8^{__C3DMorpher={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DGeometry}^{__C3DMorph}^{__C3DMesh}II^fII}16@24@32@40
v40@0:8@16@24@32
@"SCNMTLResourceManager"
{?="memory"*"buffer"@"<MTLBuffer>""offset"Q}
[3s]
^{SCNMTLBufferPool=@Q@Q{vector<SCNMTLBufferPool::Buffer, std::__1::allocator<SCNMTLBufferPool::Buffer> >=^{Buffer}^{Buffer}{__compressed_pair<SCNMTLBufferPool::Buffer *, std::__1::allocator<SCNMTLBufferPool::Buffer> >=^{Buffer}}}II@*QQ}
@"<MTLBuffer>"
{?="perVertexTrianglesOffsets"@"<MTLBuffer>""perVertexTrianglesIndices"@"<MTLBuffer>""sharedTriangleIs16Bits"B}
^{Target={?=*@Q}If[3^{__C3DMeshSource}]{?=*@Q}}
@"NSArray"
@"SCNMTLComputePipeline"
@48@0:8^{__C3DSkinner=}16^{__C3DMesh=}24^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}32@40
v48@0:8@16@24^{__C3DSkinner=}32@40
@"MTLStageInputOutputDescriptor"
@24@0:8@?16
@32@0:8d16d24
v24@0:8d16
^{c3dPhysicsField=^^?{?=[4]}{?=[4]}fffIBBBBf}16@0:8
v24@0:8Q16
v24@0:8q16
{SCNVector3=fff}16@0:8
v28@0:8{SCNVector3=fff}16
{SCNVector3=fff}28@0:8{SCNVector3=fff}16
{SCNVector3="x"f"y"f"z"f}
@"SCNPhysicsWorld"
@"SCNNode"
^{c3dPhysicsField=^^?{?=[4]}{?=[4]}fffIBBBBf}
@"<SCNJittererDelegate>"
@"NSObject<OS_dispatch_source>"
@80@0:8@16{SCNVector3=fff}24{SCNVector3=fff}36@48{SCNVector3=fff}56{SCNVector3=fff}68
@48@0:8@16{SCNVector3=fff}24{SCNVector3=fff}36
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""anchorA"{SCNVector3="x"f"y"f"z"f}"anchorB"{SCNVector3="x"f"y"f"z"f}"axisA"{SCNVector3="x"f"y"f"z"f}"axisB"{SCNVector3="x"f"y"f"z"f}}
^{btHingeConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}][3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}ff{btAngularLimit=fffffffB}ffffBBBBBfifff}
{SCNMatrix4=ffffffffffffffff}16@0:8
v24@0:8^{__C3DEngineContext=}16
@96@0:8{?=@@{CGPoint=dd}{CGPoint=dd}{SCNVector3=fff}{SCNVector3=fff}d}16
v96@0:8{?=@@{CGPoint=dd}{CGPoint=dd}{SCNVector3=fff}{SCNVector3=fff}d}16
B96@0:8{?=@@{CGPoint=dd}{CGPoint=dd}{SCNVector3=fff}{SCNVector3=fff}d}16
v32@0:816
@24@0:8Q16
r^{?=f^vf}32@0:8Q16Q24
v52@0:8S162036
104@0:816{SCNVector3=fff}32d44B525672^B88^q96
@"SCNAuthoringEnvironment"
@"NSOrderedSet"
(C3DMatrix4x4="components"[16f]"m"[4]"simd"{?="columns"[4]})
(?="axisMove"{?="originalPosition""axisDirection""mouseDeltaVector"}"planeMove"{?="originalPosition""planeNormal""pointInPlane""mouseDeltaVector"}"axisRotate"{?="rotationSign"f"originalRotation"})
{CGPoint="x"d"y"d}
{?="positions"^"orientations"^"originalLocalMatrix"^{SCNMatrix4}"scales"^}
^{?=f^vf}
@"NSMutableIndexSet"
@"SCNBillboardConstraint"
@"SKScene"
v64@0:8@16@24^{__C3DEngineContext=}3240d56
d40@0:8@16^{__C3DEngineContext=}24^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}32
@32@0:8r^{btPersistentManifold=i[4{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}]^{btCollisionObject}^{btCollisionObject}iffiii^{c3dContactCallback}}16q24
v72@0:8@16@24{SCNVector3=fff}32{SCNVector3=fff}44d56d64
v40@0:8r^{btPersistentManifold=i[4{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}]^{btCollisionObject}^{btCollisionObject}iffiii^{c3dContactCallback}}16q24r^{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}32
^{__C3DModelTarget={__CFRuntimeBase=QAQ}^v^vscCCB^?^?}
@32@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16@24
{?=b2b2b2b1}28@0:8@16C24
C28@0:8@16C24
@?36@0:8@16C24@28
v48@0:8{?=@@^{?}IB}16
v72@0:8{?=^{__C3DMesh}@^{__C3DMeshElement}@I@C}16
v40@0:8{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}16
v48@0:8@16@24Q32@40
v72@0:8{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}16{?=@@^{?}IB}40
^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}
{?="type"C"tessellationFactorScale"f"tessellationPartitionMode"I"tessellationSmoothingMode"C"parameters"(?="uniform"{?="edgeTessellationFactor"f"insideTessellationFactor"f}"screenSpaceAdaptive"{?="projectedEdgeLength"f}"constrainedEdgeLength"{?="maximumEdgeLength"f}"subdivisionSurface"{?="tessellationLevel"C"allowSingleCreasePatch"b1"useScreenSpaceTessellation"b1})}
@32@0:8@?16@24
v32@0:8@16d24
@"NSObject<OS_dispatch_queue>"
^{__C3DMaterial=}
@"SCNMTLRenderPipeline"
Q24@0:8Q16
v24@0:8@"NSString"16
@"<MTLDevice>"16@0:8
@"<MTLHeap>"16@0:8
^v16@0:8
v32@0:8{_NSRange=QQ}16
@40@0:8@16Q24Q32
v40@0:8@16{_NSRange=QQ}24
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16Q24Q32
v40@0:8@"NSString"16{_NSRange=QQ}24
v24@0:8r^v16
v32@0:8^{__C3DFXMetalProgram={__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^v^{__CFDictionary}^vQ}16^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}24
@28@0:8^{__C3DRasterizerStates=}16B24
@24@0:8^v16
@32@0:8^{__CFData=}16Q24
@24@0:8^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}16
@24@0:8^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I{?=qq}CB}^vfff^v^{__C3DMeshSource}[2]^{?}I}16
v32@0:8^{__C3DMesh=}16@24
@28@0:8^{__C3DMesh=}16C24
@32@0:8^{__C3DMorph=}16^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}24
@40@0:8^{__C3DSkinner=}16^{__C3DMesh=}24^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}32
@24@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16
@48@0:8^{__C3DRendererElement=I^{__C3DNode}^{__C3DGeometry}^{__C3DMesh}^v^{__C3DMaterial}^{__C3DFXTechnique}{?=[8C]}iIb8b1b1b1b1b1b1b3b1b3}16^{__C3DEngineContext=}24^{__C3DFXPassInstance=^{__C3DFXPass}q^{__C3DFXPassInstance}CCBC[6^{__C3DArray}]{__C3DCullingContext=^{__C3DEnginePipeline}[6{?=[6(?={?=ffff})]}][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6{?=[6(?={?=ffff})]}][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})]ICCCCB^{__C3DFXPass}^v^{__C3DNode}^{__C3DNode}BBBBBBBBBBQQ^v^{__C3DScene}^{__C3DEngineContext}dd(?={?=ffff})(C3DMatrix4x4=[16f][4]{?=[4]})(C3DMatrix4x4=[16f][4]{?=[4]})[6{?=^{?}II}]B^?}^{__C3DNode}}32Q40
@32@0:8Q16Q24
@40@0:8r^v16Q24Q32
@48@0:8^{__C3DMaterial=}16^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}24@32^{__C3DEngineContext=}40
@24@0:8^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}16
^{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}16@0:8
@"<MTLDevice>"
@"<MTLCommandQueue>"
^{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}
@"SCNMTLLibraryManager"
@"SCNMTLShaderBindingsGenerator"
^{__CFDictionary=}
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
@"SCNMTLBufferAllocator"
{?="registry"@"NSMapTable""lock"{os_unfair_lock_s="_os_unfair_lock_opaque"I}}
@"SCNMTLShadableKey"
@"NSMutableArray"
@"<MTLTexture>"
^{__C3DFXMetalProgram={__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^v^{__CFDictionary}^vQ}
@"<MTLDepthStencilState>"
@"MTKTextureLoader"
@40@0:8^{?=CCCb1b1b1b1b1b1[4C]}1624Q32
C16@0:8
B40@0:8^{?=CCCb1b1b1b1b1b1[4C]}1624Q32
{?="format"C"sampleCount"C"textureUsage"C"renderToTexture"b1"forceTextureRect"b1"viewportDependant"b1"renderToIOSurface"b1"mipmapped"b1"textureCube"b1"padding"[4C]}
@"CIImage"
@28@0:8@16B24
^{SCNCPlaySound=^^?f@?@BdddddBB@?^{__CFString}qddddBB@}
v104@0:8^v16Q24Q32{?={?=QQQ}{?=QQQ}}40Q88Q96
v104@0:8{?={?=QQQ}{?=QQQ}}16Q64Q72r^v80Q88Q96
v88@0:8^v16Q24{?={?=QQQ}{?=QQQ}}32Q80
v88@0:8{?={?=QQQ}{?=QQQ}}16Q64r^v72Q80
@64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
^{__IOSurface=}16@0:8
{?=CCCC}16@0:8
@"<MTLTexture>"24@0:8Q16
@"<MTLTexture>"64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@"<MTLTexture>"68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
@"<MTLResource>"16@0:8
@"<MTLTexture>"16@0:8
@"<MTLBuffer>"16@0:8
@24@0:8^{__C3DFXTechnique={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}qq^^{__C3DFXPass}b1b1b1b1b1I^{?}^{__CFDictionary}^{__C3DNode}^{__CFArray}^{__C3DFXTechnique}^v^{__CFString}^{__CFString}}16
v32@0:8d16@24
v32@0:8@"<SCNAnimation>"16@"NSString"24
v32@0:8@"SCNAnimationPlayer"16@"NSString"24
@"SCNAnimationPlayer"24@0:8@"NSString"16
v32@0:8@"NSString"16d24
@"CAAnimation"24@0:8@"NSString"16
v32@0:8d16@"NSString"24
B24@0:8@"NSString"16
v32@0:8@16@?24
^{__C3DFXTechnique={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}qq^^{__C3DFXPass}b1b1b1b1b1I^{?}^{__CFDictionary}^{__C3DNode}^{__CFArray}^{__C3DFXTechnique}^v^{__CFString}^{__CFString}}16@0:8
^{__C3DAnimationManager=}16@0:8
B32@0:8@16@24
v32@0:8B16@20B28
v48@0:8@16@24@32@40
^{__C3DFXTechnique={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}qq^^{__C3DFXPass}b1b1b1b1b1I^{?}^{__CFDictionary}^{__C3DNode}^{__CFArray}^{__C3DFXTechnique}^v^{__CFString}^{__CFString}}
@"NSMutableDictionary"
@"SCNOrderedDictionary"
@"<MTLLibrary>"
^{?=^{__C3DFXPass}^{__C3DFXTechnique}^v^{__C3DEngineContext}^{__C3DFXProgramObject}d^v^{__C3DRendererElement}q}
@32@0:8^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}16@24
v32@0:8@16q24
@24@0:8q16
^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}
@"SCNTechnique"
@32@0:8^v16@24
^{btCollisionShape=^^?i^v}16@0:8
@"NSDictionary"
^{btCollisionShape=^^?i^v}
@24@0:8d16
^{SCNCActionWait=^^?f@?@BdddddBB@?^{__CFString}qdddd}
{?="characterBody"@"SCNPhysicsBody""direction"{SCNVector3="x"f"y"f"z"f}"velocity"d"jumpSpeed"d}
^{btCharacterControllerInterface=^^?}
^{btPairCachingGhostObject=^^?{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}if^{btBroadphaseProxy}^{btCollisionShape}^v^{btCollisionShape}iiiiffffi^vfffi{btAlignedObjectArray<btCollisionObject *>={btAlignedAllocator<btCollisionObject *, 16>=}ii^^{btCollisionObject}B}^{btHashedOverlappingPairCache}}
^{btOverlapFilterCallback=^^?}
^{btCapsuleShape=^^?i^v{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffi}
v32@0:8r^v16Q24
^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}32@0:8@16@24
@32@0:8@16^{__C3DEngineContext=}24
^{__C3DEngineContext=}16@0:8
v80@0:8{SCNMatrix4=ffffffffffffffff}16
i16@0:8
B24@0:8Q16
^{SCNMTLBlitCommandEncoder=@@}16@0:8
^{SCNMTLComputeCommandEncoder=[31@][31Q][31@][16@]@@@^{SCNMTLBufferPool}I[1Q][1Q]}16@0:8
v37@0:8@16^v24{?=CCCBB}32
@24@0:8^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}16
v24@0:8^{__C3DRasterizerStates=}16
v32@0:8q16q24
v32@0:8@16Q24
v24@0:8^(C3DMatrix4x4=[16f][4]{?=[4]})16
f28@0:8r^(C3DMatrix4x4=[16f][4]{?=[4]})16f24
v40@0:8^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}16^{__C3DEngineContext=}24^{__C3DFXPassInstance=^{__C3DFXPass}q^{__C3DFXPassInstance}CCBC[6^{__C3DArray}]{__C3DCullingContext=^{__C3DEnginePipeline}[6{?=[6(?={?=ffff})]}][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6{?=[6(?={?=ffff})]}][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})]ICCCCB^{__C3DFXPass}^v^{__C3DNode}^{__C3DNode}BBBBBBBBBBQQ^v^{__C3DScene}^{__C3DEngineContext}dd(?={?=ffff})(C3DMatrix4x4=[16f][4]{?=[4]})(C3DMatrix4x4=[16f][4]{?=[4]})[6{?=^{?}II}]B^?}^{__C3DNode}}32
v40@0:8^{__C3DImageProxy={__CFRuntimeBase=QAQ}{?=^?^?^?^?}^vC}16^{__C3DEngineContext=}24^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}32
v148@0:8^{__C3DMesh=}16^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I{?=qq}CB}^vfff^v^{__C3DMeshSource}[2]^{?}I}24^{__C3DFXMetalProgram={__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^v^{__CFDictionary}^vQ}32^{__C3DEngineContext=}40(C3DMatrix4x4=[16f][4]{?=[4]})48r^{C3DColor4=(?=[4f]{?=ffff})}112^{__C3DRasterizerStates=}120^{__C3DBlendStates=}128^{__C3DImage=}136B144
v36@0:8^{?=SS}16I24^{?=^{__C3DEnginePipeline}^{__C3DEngineContext}^{__C3DFXPassInstance}^v^{__C3DNode}BBB}28
v24@0:8^{?=^{__C3DEnginePipeline}^{__C3DEngineContext}^{__C3DFXPassInstance}^v^{__C3DNode}BBB}16
v24@0:8^{__C3DMaterial=}16
v32@0:8^{__C3DRendererElement=I^{__C3DNode}^{__C3DGeometry}^{__C3DMesh}^v^{__C3DMaterial}^{__C3DFXTechnique}{?=[8C]}iIb8b1b1b1b1b1b1b3b1b3}16^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}24
v56@0:8^{?=SS}16{?=qq}24^{__C3DRendererElementStore=}40^{__C3DFXPassInstance=^{__C3DFXPass}q^{__C3DFXPassInstance}CCBC[6^{__C3DArray}]{__C3DCullingContext=^{__C3DEnginePipeline}[6{?=[6(?={?=ffff})]}][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6{?=[6(?={?=ffff})]}][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})][6(C3DMatrix4x4=[16f][4]{?=[4]})]ICCCCB^{__C3DFXPass}^v^{__C3DNode}^{__C3DNode}BBBBBBBBBBQQ^v^{__C3DScene}^{__C3DEngineContext}dd(?={?=ffff})(C3DMatrix4x4=[16f][4]{?=[4]})(C3DMatrix4x4=[16f][4]{?=[4]})[6{?=^{?}II}]B^?}^{__C3DNode}}48
B32@0:8^{__C3DMesh=}16q24
v32@0:8^{__C3DMesh=}16q24
^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I{?=qq}CB}^vfff^v^{__C3DMeshSource}[2]^{?}I}36@0:8c16q20q28
v24@0:8^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I{?=qq}CB}^vfff^v^{__C3DMeshSource}[2]^{?}I}16
v24@0:8^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}16
v36@0:8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}16i24^{__C3DLightRuntimeData=If[4{?=[4]}]^v^{__C3DTextureSampler}^v^{__C3DTextureSampler}}28
v28@0:8@16B24
16@0:8
v36@0:8@16B24d28
^{__C3DMaterial=}16@0:8
{SCNMatrix4="m11"f"m12"f"m13"f"m14"f"m21"f"m22"f"m23"f"m24"f"m31"f"m32"f"m33"f"m34"f"m41"f"m42"f"m43"f"m44"f}
^{__C3DEngineContext=}
@"NSObject<OS_dispatch_semaphore>"
{atomic<int>="__a_"{__cxx_atomic_impl<int, std::__1::__cxx_atomic_base_impl<int> >="__a_value"Ai}}
@"CAMetalLayer"
@"<CAMetalDrawable>"
@"MTLRenderPassDescriptor"
@"<MTLCommandBuffer>"
^{SCNMTLRenderCommandEncoder=BQQQQBBBBIIBB[31{?=@Q}][31@][16@][31{?=@Q}][31@][16@]@@@^{SCNMTLBufferPool}[1Q][1Q]}
{SCNMTLBlitCommandEncoder="_encoder"@"<MTLBlitCommandEncoder>""_commandBuffer"@"<MTLCommandBuffer>"}
{SCNMTLComputeCommandEncoder="_buffers"[31@"<MTLBuffer>"]"_offsets"[31Q]"_textures"[31@"<MTLTexture>"]"_samplers"[16@"<MTLSamplerState>"]"_computePipelineState"@"<MTLComputePipelineState>""_encoder"@"<MTLComputeCommandEncoder>""_commandBuffer"@"<MTLCommandBuffer>""_bufferPool"^{SCNMTLBufferPool}"_features"I"_texturesToBind"[1Q]"_buffersToBind"[1Q]}
{?="renderSliceIndex"C"eyeCount"C"renderMode"C"isMainPass"B"isFinalTechnique"B}
{?="vertexIndex"c"fragmentIndex"c}
[3^{SCNMTLBufferPool}]
^{SCNMTLTexturePool=@@{vector<SCNMTLTexturePool::CachedTexture, std::__1::allocator<SCNMTLTexturePool::CachedTexture> >=^{CachedTexture}^{CachedTexture}{__compressed_pair<SCNMTLTexturePool::CachedTexture *, std::__1::allocator<SCNMTLTexturePool::CachedTexture> >=^{CachedTexture}}}I}
@"<MTLSamplerState>"
[3^{__C3DFXMetalProgram}]
^{__C3DRasterizerStates=}
@"NSObject<OS_dispatch_group>"
{?="passInstance"^{__C3DFXPassInstance}"lightingSystem"^{__C3DLightingSystem}"dynamicBatchingSystem"^{__C3DDynamicBatchingSystem}"pass"^{__C3DFXPass}"renderGraphPass"^v"passRequiresLighting"B"transformTree"^{__C3DTransformTree}}
[6{SCNSceneBuffer="viewTransform"{float4x4="columns"[4]}"inverseViewTransform"{float4x4="columns"[4]}"projectionTransform"{float4x4="columns"[4]}"viewProjectionTransform"{float4x4="columns"[4]}"viewToCubeTransform"{float4x4="columns"[4]}"lastFrameViewProjectionTransform"{float4x4="columns"[4]}"ambientLightingColor""fogColor""fogParameters""inverseResolution""time"f"sinTime"f"cosTime"f"random01"f"motionBlurIntensity"f"environmentIntensity"f"inverseProjectionTransform"{float4x4="columns"[4]}"inverseViewProjectionTransform"{float4x4="columns"[4]}"nearFar""viewportSize""inverseTransposeViewTransform"{float4x4="columns"[4]}"clusterScale"}]
{?="buffer"@"<MTLBuffer>""offset"Q}
{?="buffer"@"<MTLBuffer>""offset"Q"size"Q"shadowMaps"[256@"<MTLTexture>"]"textureMaps"[256@"<MTLTexture>"]"samplerStates"[256@"<MTLSamplerState>"]}
{?="modelTransform"{float4x4="columns"[4]}"lastFrameModelTransform"{float4x4="columns"[4]}"normalTransform"{float4x4="columns"[4]}"modelViewTransform"{float4x4="columns"[4]}"modelViewProjectionTransform"{float4x4="columns"[4]}"boundingBox"{float2x3="columns"[2]}"worldBoundingBox"{float2x3="columns"[2]}"instanceNode"^{__C3DNode}"flags"I"probeCacheIndex"^I"boneTransformSizeWritten"I}
{?="currentLightingSet"{?="lights"[8C]}"currentShadowMaps"[8@"<MTLTexture>"]"currentGoboMaps"[8@"<MTLTexture>"]"frameLightingSetDatas"{unordered_map<unsigned long long, SCNMTLLightSetData, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, SCNMTLLightSetData> > >="__table_"{__hash_table<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::__1::hash<unsigned long long>, true>, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::__1::equal_to<unsigned long long>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData> > >="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *> > >="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *> > >="__value_"^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *> >="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *> >="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> > >="__value_"{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::__1::hash<unsigned long long>, true> >="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::__1::equal_to<unsigned long long>, true> >="__value_"f}}}"currentLightingHashKey"Q"currentLightingDesc"{?="count"q"lights"[8^{__C3DLight}]"lightsData"[8^{__C3DLightRuntimeData}]}"currentLightingSpace"{?="columns"[4]}"currentLightingSpaceShadow"{?="columns"[4]}"needLightingSpaceTransformation"B"clusterSystem"{SCNMTLClusterSystem="clustersCount""tileSize""selectedDebugClusterIndex""_debugClusterTilesPipeline"@"SCNMTLRenderPipeline""_debugLightIndicesBufferPipeline"@"SCNMTLRenderPipeline""_debugClusterSlicesPipeline"@"SCNMTLRenderPipeline""_debugProgram"[7^{__C3DFXMetalProgram}]"_debugShapes"[7^{__C3DMesh}]}"clusterInfo"{Info="clusterBuffer"{?="memory"*"buffer"@"<MTLBuffer>""offset"Q}"clusterTexture"@"<MTLTexture>""lightIndicesTexture"@"<MTLTexture>""cellSize""clusterScale""cellPixelSize""omniLightsRange""spotLightsRange""probeLightsRange""lightsBuffer"{?="memory"*"buffer"@"<MTLBuffer>""offset"Q}"lightsBufferSize"I"shadowTextures"[8@"<MTLTexture>"]"iesOrGoboTextures"[8@"<MTLTexture>"]"samplerStates"[8@"<MTLSamplerState>"]"areaBuffer"@"<MTLBuffer>""areaBufferOffset"Q"areaBufferOffsets"[8Q]}"reflectionProbesTextureArray"@"<MTLTexture>"}
{Cache="rasterizerStates"^{__C3DRasterizerStates}"mesh"^{__C3DMesh}"metalMesh"@"SCNMTLMesh""meshElement"^{__C3DMeshElement}"metalMeshElement"@"SCNMTLMeshElement""program"^{__C3DFXMetalProgram}"material"^{__C3DMaterial}"geometry"^{__C3DGeometry}"metalShadable"@"SCNMTLShadable""commonProfile"^{__C3DEffectCommonProfile}"blendStates"^{__C3DBlendStates}"colorBufferWriteMask"C"topologyClass"C"node"^{__C3DNode}"vertexDescriptorHash"Q"tessellationPipelineStateHash"C"renderPipeline"@"SCNMTLRenderPipeline"}
{?="debugLightMeshPass"[7^{__C3DFXPass}]"lightPasses"[7^{__C3DFXPass}]"lightMeshes"[7^{__C3DMesh}]"resourcesAreReady"B}
[2{?="hash"Q"pipeline"@"SCNMTLRenderPipeline"}]
{?="backgroundTexture"@"<MTLTexture>""overlayTexture"@"<MTLTexture>""stencilDepthTexture"@"<MTLTexture>"}
{?="pixelFormat"Q"sampleCount"Q"displayCubemapPipeline"@"SCNMTLRenderPipeline""displayTexture2DPipeline"@"SCNMTLRenderPipeline""displayDepth2DPipeline"@"SCNMTLRenderPipeline""displayDepthCubePipeline"@"SCNMTLRenderPipeline"}
{?="collectEnabled"B"errors"@"NSMutableDictionary"}
{?="modelTransformBindingCount"I"modelViewTransformBindingCount"I"normalTransformBindingCount"I"nodeOpacityBindingCount"I}
{?="passHash"Q"material"^{__C3DMaterial}}
@"<MTLRenderCommandEncoder>"
@"SCNFixedSizePage"
@32@0:8@16Q24
@48@0:8@16Q24Q32@40
@40@0:8r^v16Q24@32
@40@0:8@16@24@?32
v52@0:8@16@24Q32B40@44
v48@0:8@16@24@32@?40
@44@0:8@16^{__C3DEngineContext=}24B32@36
@40@0:8@16^{__C3DEngineContext=}24@32
@48@0:8@16Q24^Q32@40
@24@0:8i16i20
@20@0:8i16
@40@0:8@16Q24@32
@160@0:8@16{SCNMatrix4=ffffffffffffffff}24@88{SCNMatrix4=ffffffffffffffff}96
@88@0:8@16{SCNMatrix4=ffffffffffffffff}24
{?="bodyA"@"SCNPhysicsBody""frameA"{SCNMatrix4="m11"f"m12"f"m13"f"m14"f"m21"f"m22"f"m23"f"m24"f"m31"f"m32"f"m33"f"m34"f"m41"f"m42"f"m43"f"m44"f}"bodyB"@"SCNPhysicsBody""frameB"{SCNMatrix4="m11"f"m12"f"m13"f"m14"f"m21"f"m22"f"m23"f"m24"f"m31"f"m32"f"m33"f"m34"f"m41"f"m42"f"m43"f"m44"f}"maximumAngularLimit1"d"maximumAngularLimit2"d"maximumTwistAngle"d}
^{btConeTwistConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}ffffffff{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffffffBBBBff{btVector3=(?=[4f])}BB{btQuaternion=(?=[4f])}f{btVector3=(?=[4f])}ifff}
i20@0:8i16
@"SCNAssetCatalog"
@"MTLArgument"
@"<MTLArgumentEncoder>"
^{?=@?II}
^{?=^{__C3DFXPassInput}II}
^{__C3DFXPassInput=}
v34@0:8@16Q24{?=cc}32
@18@0:8{?=cc}16
[31@]
[16@]
^{__C3DFXMetalProgram=}
^{__C3DFXPass=}
{?="colorFormat"[8Q]"depthFormat"Q"stencilFormat"Q"sampleCount"C}
[2I]
@"<MTLRenderPipelineState>"
@"MTLVertexDescriptor"
@"<MTLFunction>"
@"<MTLComputePipelineState>"
v32@0:8{?=qq}16
@"SCNMTLBuffer"
@48@0:8d16d24d32d40
@36@0:8{SCNVector3=fff}16d28
@44@0:8d16{SCNVector3=fff}24d36
@40@0:8{SCNVector4=ffff}16d32
@52@0:8d16d24d32d40B48
@32@0:8@16d24
@32@0:8d16@?24
^{SCNCAction=^^?f@?@BdddddBB@?^{__CFString}qdddd}16@0:8
^{SCNCAction=^^?f@?@BdddddBB@?^{__CFString}qdddd}
v24@0:8^v16
d24@0:8d16
{SCNVector4=ffff}16@0:8
v32@0:8{SCNVector4=ffff}16
{SCNVector4="x"f"y"f"z"f"w"f}
@32@0:8d16@24
@32@0:8q16@24
^{btRigidBody=^^?{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}if^{btBroadphaseProxy}^{btCollisionShape}^v^{btCollisionShape}iiiiffffi^vfffi{btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffBfffffff^{btMotionState}{btAlignedObjectArray<btTypedConstraint *>={btAlignedAllocator<btTypedConstraint *, 16>=}ii^^{btTypedConstraint}B}ii{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ii}16@0:8
^{btCollisionShape=^^?i^v}32@0:8@16@24
v32@0:8{SCNVector3=fff}16B28
v44@0:8{SCNVector3=fff}16{SCNVector3=fff}28B40
v36@0:8{SCNVector4=ffff}16B32
@"SCNPhysicsShape"
^{btRigidBody=^^?{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}if^{btBroadphaseProxy}^{btCollisionShape}^v^{btCollisionShape}iiiiffffi^vfffi{btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffBfffffff^{btMotionState}{btAlignedObjectArray<btTypedConstraint *>={btAlignedAllocator<btTypedConstraint *, 16>=}ii^^{btTypedConstraint}B}ii{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ii}
@"SCNAction"
^{SCNCActionFade=^^?f@?@BdddddBB@?^{__CFString}qddddfffB}
B40@0:8@16@24^@32
@48@0:8{SCNVector3=fff}16{SCNVector3=fff}28@40
@56@0:8{btVector3=(?=[4f])}16{btVector3=(?=[4f])}32@48
@160@0:8@16{SCNMatrix4=ffffffffffffffff}24{SCNMatrix4=ffffffffffffffff}88@152
^{c3dAether={vector<c3dPhysicsField *, std::__1::allocator<c3dPhysicsField *> >=^^{c3dPhysicsField}^^{c3dPhysicsField}{__compressed_pair<c3dPhysicsField **, std::__1::allocator<c3dPhysicsField *> >=^^{c3dPhysicsField}}}{vector<c3dPhysicsField *, std::__1::allocator<c3dPhysicsField *> >=^^{c3dPhysicsField}^^{c3dPhysicsField}{__compressed_pair<c3dPhysicsField **, std::__1::allocator<c3dPhysicsField *> >=^^{c3dPhysicsField}}}I}16@0:8
^{btVehicleRaycaster=^^?}16@0:8
^{btDynamicsWorld=^^?{btAlignedObjectArray<btCollisionObject *>={btAlignedAllocator<btCollisionObject *, 16>=}ii^^{btCollisionObject}B}^{btDispatcher}{btDispatcherInfo=fiifB^{btIDebugDraw}BBBfBf}^{btBroadphaseInterface}^{btIDebugDraw}B^?^?^v{btContactSolverInfo=fffffifffffiffffiiiff}f}16@0:8
v56@0:8@16^{__C3DNode=}24Q32Q40Q48
v32@0:8@16^v24
^{btDiscreteDynamicsWorld=^^?{btAlignedObjectArray<btCollisionObject *>={btAlignedAllocator<btCollisionObject *, 16>=}ii^^{btCollisionObject}B}^{btDispatcher}{btDispatcherInfo=fiifB^{btIDebugDraw}BBBfBf}^{btBroadphaseInterface}^{btIDebugDraw}B^?^?^v{btContactSolverInfo=fffffifffffiffffiiiff}f{btAlignedObjectArray<btTypedConstraint *>={btAlignedAllocator<btTypedConstraint *, 16>=}ii^^{btTypedConstraint}B}^{InplaceSolverIslandCallback}^{btConstraintSolver}^{btSimulationIslandManager}{btAlignedObjectArray<btTypedConstraint *>={btAlignedAllocator<btTypedConstraint *, 16>=}ii^^{btTypedConstraint}B}{btAlignedObjectArray<btRigidBody *>={btAlignedAllocator<btRigidBody *, 16>=}ii^^{btRigidBody}B}{btVector3=(?=[4f])}fBBBB{btAlignedObjectArray<btActionInterface *>={btAlignedAllocator<btActionInterface *, 16>=}ii^^{btActionInterface}B}i{btAlignedObjectArray<btPersistentManifold *>={btAlignedAllocator<btPersistentManifold *, 16>=}ii^^{btPersistentManifold}B}B}
^{btOverlappingPairCallback=^^?}
^{btVehicleRaycaster=^^?}
^{btC3DDebugDraw=^^?i^v}
{c3dAether="_fields"{vector<c3dPhysicsField *, std::__1::allocator<c3dPhysicsField *> >="__begin_"^^{c3dPhysicsField}"__end_"^^{c3dPhysicsField}"__end_cap_"{__compressed_pair<c3dPhysicsField **, std::__1::allocator<c3dPhysicsField *> >="__value_"^^{c3dPhysicsField}}}"_activeFields"{vector<c3dPhysicsField *, std::__1::allocator<c3dPhysicsField *> >="__begin_"^^{c3dPhysicsField}"__end_"^^{c3dPhysicsField}"__end_cap_"{__compressed_pair<c3dPhysicsField **, std::__1::allocator<c3dPhysicsField *> >="__value_"^^{c3dPhysicsField}}}"_lastOverrideIndex"I}
@"<SCNPhysicsContactDelegate>"
@"SCNPhysicsContact"
@"SCNScene"
@"NSMutableSet"
{C3DColor4=(?=[4f]{?=ffff})}28@0:8B16^B20
@24@0:8r^{C3DColor4=(?=[4f]{?=ffff})}16
@80@0:8{?=[4]}16
{CGPoint=dd}16@0:8
@32@0:8{CGPoint=dd}16
@28@0:8{SCNVector3=fff}16
@32@0:8{SCNVector4=ffff}16
@80@0:8{SCNMatrix4=ffffffffffffffff}16
@24@0:8^{__C3DLight=}16
^{__C3DLight=}16@0:8
v48@0:8@16@24@32^v40
v32@0:8{CGSize=dd}16
^{__C3DLight=}
{CGSize="width"d"height"d}
@"SCNMaterialProperty"
@"NSData"
v24@0:8^{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}16
v120@0:8{?=^{__C3DFXMetalProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}CCCB@{?=C@?}}16@?112
@"SCNMTLLibrary"
@"NSMapTable"
@24@0:8^{__C3DMaterial=}16
v32@0:8@"NSString"16@?<v@?II@"SCNNode"@"SCNRenderer">24
@"SCNProgram"16@0:8
v24@0:8@"SCNProgram"16
@"NSDictionary"16@0:8
v24@0:8@"NSDictionary"16
^{__C3DEffectCommonProfile={__CFRuntimeBase=QAQ}^{__C3DMaterial}i^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}fffffCqBBb1b1b1b1b1b1b1b1b1b13}16@0:8
v24@0:8^@16
@24@0:8^@16
@"SCNShadableHelper"
@24@0:8^{__C3DParticleSystem=}16
^{__C3DParticleSystem=}16@0:8
s24@0:8@16
v40@0:8q16@24@?32
v40@0:8@16q24@?32
^{__C3DParticleSystem=}
@"SCNGeometry"
@"UIColor"
@"SCNParticleSystem"
@24@0:8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}16
v40@0:8@16@24@?32
v24@0:8@"SCNAction"16
v32@0:8@"SCNAction"16@?<v@?>24
v32@0:8@"SCNAction"16@"NSString"24
v40@0:8@"SCNAction"16@"NSString"24@?<v@?>32
@"SCNAction"24@0:8@"NSString"16
B32@0:8^{SCNVector3=fff}16^{SCNVector3=fff}24
v32@0:8^{SCNVector3=fff}16^{SCNVector3=fff}24
B32@0:8^{SCNVector3=fff}16^d24
B24@0:8@"UIFocusUpdateContext"16
v32@0:8@"UIFocusUpdateContext"16@"UIFocusAnimationCoordinator"24
@"<UIFocusEnvironment>"16@0:8
@"<UIFocusItemContainer>"16@0:8
@"NSString"24@0:8@"UIFocusUpdateContext"16
@"UIView"16@0:8
{CGRect={CGPoint=dd}{CGSize=dd}}16@0:8
v24@0:8@"UIFocusMovementHint"16
B36@0:8@?16B24@28
@28@0:8@?16B24
B24@0:8@?16
v36@0:8#16@24B32
@28@0:8#16B24
^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}16@0:8
{?=}16@0:8
v32@0:8{?=}16
v32@0:8Q16@24
Q24@0:8@16
B40@0:8^{?=[6(?={?=ffff})]}1624
v24@0:8^{__C3DParticleSystem=}16
{SCNVector3=fff}36@0:8{SCNVector3=fff}16@28
{SCNMatrix4=ffffffffffffffff}88@0:8{SCNMatrix4=ffffffffffffffff}16@80
^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}
{?="columns"[4]}
(?="eulerAngles""axisAngle""quaternion"{?="vector"})
@"SCNNodeComponent"
^{SCNVector3=fff}
v52@0:8{SCNVector3=fff}16{SCNVector3=fff}28{SCNVector3=fff}40
v44@0:8{SCNVector4=ffff}16{SCNVector3=fff}32
B32@0:8^16^f24
v80@0:8{?=[4]}16
40@0:816@32
{?=[4]}88@0:8{?=[4]}16@80
v64@0:8163248
v48@0:8{?=}1632
@40@0:8@16@24^@32
@40@0:8@16q24@32
@24@0:8^{__C3DScene=}16
:16@0:8
v28@0:8@16i24
@20@0:8B16
B48@0:8@16@24@32@?40
v88@0:8@16{SCNMatrix4=ffffffffffffffff}24
@"SCNSceneSource"
[4@"SCNNode"]
{?=dddddd}16@0:8
v64@0:8{?=dddddd}16
{?="originX"d"originY"d"width"d"height"d"znear"d"zfar"d}
@"<MTLEvent>"
^{__C3DFXPass=}16@0:8
@60@0:8i16@20{CGSize=dd}28@44@52
@"SKTransition"
[2@"SCNOffscreenRenderer"]
@40@0:8{CGPoint=dd}16@32
B32@0:8@16@?24
v48@0:8@"SCNScene"16@"SKTransition"24@"SCNNode"32@?<v@?>40
@"NSArray"40@0:8{CGPoint=dd}16@"NSDictionary"32
B32@0:8@"SCNNode"16@"SCNNode"24
@"NSArray"24@0:8@"SCNNode"16
B32@0:8@16@?<B@?>24
v32@0:8@"NSArray"16@?<v@?B>24
@"SCNScene"16@0:8
v24@0:8@"SCNScene"16
@"<SCNSceneRendererDelegate>"16@0:8
v24@0:8@"<SCNSceneRendererDelegate>"16
@"SCNNode"16@0:8
v24@0:8@"SCNNode"16
@"SKScene"16@0:8
v24@0:8@"SKScene"16
@"<MTLRenderCommandEncoder>"16@0:8
@"MTLRenderPassDescriptor"16@0:8
@"<MTLCommandQueue>"16@0:8
@"AVAudioEngine"16@0:8
@"AVAudioEnvironmentNode"16@0:8
@"SCNTechnique"16@0:8
v24@0:8@"SCNTechnique"16
@56@0:8@16B24@28B36^v40Q48
^{__C3DRendererContext={__CFRuntimeBase=QAQ}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBB^{__CFDictionary}I^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}{Cache=[8I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^vii}{?=[2I][5i][14{?=iII}][14I]^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}16@0:8
32@0:816
v48@0:8^{SCNVector3=fff}16Q24{SCNVector4=ffff}32
{SCNVector3=fff}44@0:8{SCNVector3=fff}16{SCNVector4=ffff}28
v24@0:8^{__C3DScene=}16
@56@0:8{CGPoint=dd}16{CGSize=dd}32@48
B48@0:8@16@24{SCNVector4=ffff}32
@40@0:8@16{SCNVector4=ffff}24
v32@0:8^{__C3DEngineContext=}16d24
B24@0:8^{__C3DScene=}16
v64@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@48@56
v72@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64
v88@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64@72@80
v80@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64@72
v40@0:8d16@24@32
^{CGImage=}24@0:8d16
@48@0:8d16{CGSize=dd}24Q40
^{CGImage=}48@0:8d16{CGSize=dd}24Q40
@32@0:8{CGSize=dd}16
^{CGImage=}32@0:8{CGSize=dd}16
@40@0:8{CGSize=dd}16@32
v40@0:8Q16B24B28@32
@"SCNRecursiveLock"
{?="frameBuffer"^{__C3DFramebuffer}"multisamplingFrameBuffer"^{__C3DFramebuffer}"drawableSize"{CGSize="width"d"height"d}}
@"SCNRendererTransitionContext"
@"EAGLContext"
@"SCNMTLRenderContext"
{?="supportsUpdate"b1"supportsDidApplyAnimations"b1"supportsDidSimulatePhysics"b1"supportsDidApplyConstraints"b1"supportsWillRender"b1"supportsDidRender"b1"supportsInputTime"b1"supportsReadSubdivCache"b1"supportsWriteSubdivCache"b1}
{C3DColor4=""(?="rgba"[4f]""{?="r"f"g"f"b"f"a"f}"simd")}
@"SCNRenderer"
@"<SCNSceneRenderer>"
@"__SKSCNRenderer"
@40@0:8@16{CGSize=dd}24
v32@0:8^?16^v24
{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}
^{__C3DKeyframedAnimation=}16@0:8
v24@0:8^{__C3DKeyframedAnimation=}16
^{__C3DKeyframedAnimation=}
B36@0:8d16B24^v28
@24@0:8^{__C3DTimingFunction=}16
^{__C3DTimingFunction=}16@0:8
^{__C3DTimingFunction=}
@24@0:8^{__C3DAnimation=}16
v24@0:8^{__C3DAnimation=}16
^{__C3DAnimation=}16@0:8
^{__C3DAnimation=}
@"SCNTimingFunction"
@24@0:8^{__C3DAnimationPlayer=}16
^{__C3DAnimationPlayer=}16@0:8
^{__C3DAnimationPlayer=}
@"SCNAnimation"
#40@0:8@16@24@32
#40@0:8@"NSKeyedUnarchiver"16@"NSString"24@"NSArray"32
@32@0:8@"NSKeyedUnarchiver"16@24
v40@0:8@"NSKeyedUnarchiver"16@24@32
v24@0:8@"NSKeyedUnarchiver"16
@32@0:8Q16@24
@40@0:8Q16@24^@32
^{__C3DScene=}32@0:8@16@?24
@40@0:8#16@24@?32
@32@0:8@16@?24
@40@0:8#16@24^@32
@32@0:8@16^@24
^{__C3DSceneSource=}16@0:8
^{__C3DLibrary=}16@0:8
@32@0:8@16#24
@24@0:8#16
B48@0:8@16Q24@?32@?40
^{__C3DSceneSource=}
v32@0:8^{SCNVector3=fff}16Q24
v24@0:8^{CGColor=}16
@"SCNJitterer"
@"SCNDisplayLink"
@24@0:8^{__CFArray=}16
@24@0:8^{__C3DHitTestResult=}16
{CGPoint=dd}24@0:8q16
^{__C3DHitTestResult=}
@"<MTLTexture>"32@0:8@"NSURL"16^@24
v24@0:8^{__C3DImageProxy=}16
@"<SCNMaterialPropertyTextureProvider>"
v44@0:8@16@24@32f40
B32@0:8{CGPoint=dd}16
v32@0:8q16@24
@"SCNManipulator"
@40@0:8d16d24@32
@56@0:8d16d24d32d40@48
@48@0:8d16d24d32@40
@24@0:8^{__C3DFloor={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}ffffifffQ}16
^{__C3DFloor={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}ffffifffQ}16@0:8
^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16@0:8
@24@0:8^{__C3DCamera={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{?=b1b1b1b1b1b1b1dddfd(C3DMatrix4x4=[16f][4]{?=[4]}){?=[4]}dd}ffffiib1b1b1b1b1C(C3DMatrix4x4=[16f][4]{?=[4]})ffffffffffffiffffffffffffff{?=fffffii}^{__C3DEffectSlot}Q^{__C3DFXTechnique}^vf}16
v24@0:816
^{__C3DCamera={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{?=b1b1b1b1b1b1b1dddfd(C3DMatrix4x4=[16f][4]{?=[4]}){?=[4]}dd}ffffiib1b1b1b1b1C(C3DMatrix4x4=[16f][4]{?=[4]})ffffffffffffiffffffffffffff{?=fffffii}^{__C3DEffectSlot}Q^{__C3DFXTechnique}^vf}16@0:8
{SCNMatrix4=ffffffffffffffff}32@0:8{CGSize=dd}16
^{__C3DCamera={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{?=b1b1b1b1b1b1b1dddfd(C3DMatrix4x4=[16f][4]{?=[4]}){?=[4]}dd}ffffiib1b1b1b1b1C(C3DMatrix4x4=[16f][4]{?=[4]})ffffffffffffiffffffffffffff{?=fffffii}^{__C3DEffectSlot}Q^{__C3DFXTechnique}^vf}
{?="intensity"f"radius"f"bias"f"depthThreshold"f"normalThreshold"f"sampleCount"q"downSample"q}
v20@0:8I16
v48@0:8@16@?24@?32@40
@"<MTLTexture>"24@0:8@"<MTLDevice>"16
v48@0:8@"<MTLTexture>"16@?<v@?@?<v@?@"<MTLComputeCommandEncoder>">>24@?<v@?@?<v@?@"<MTLBlitCommandEncoder>">>32@"<SCNMaterialPropertyTextureProviderHelper>"40
^{__C3DImage=}32@0:8@16Q24
^{__C3DImage=}36@0:8@16i24^B28
^{__C3DImage=}28@0:8@16i24
^{__C3DImage=}24@0:8@16
@24@0:8^{__C3DImage=}16
@28@0:8@16c24
^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}20@0:8B16
v24@0:8^{__C3DImage=}16
{C3DColor4=(?=[4f]{?=ffff})}16@0:8
c16@0:8
^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}16@0:8
^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}16@0:8
v80@0:8(C3DMatrix4x4=[16f][4]{?=[4]})16
^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}
^{__C3DImage=}
^{SCNMatrix4=ffffffffffffffff}
v24@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16
B48@0:8@16@24^@32^@40
{?=BCCC}16@0:8
v20@0:8{?=BCCC}16
{?="enableVertexWeldingAtImport"B"boundaryInterpolationRule"C"faceVaryingInterpolationRule"C"normalSmoothingMode"C}
@"SCNGeometrySource"
@"SCNGeometryElement"
@"SCNGeometryTessellator"
v40@0:8@16d24@32
v40@0:8@16@24#32
@"CAAnimation"
@24@0:8^{__C3DSkinner=}16
^{__C3DSkinner=}48@0:8@16@24@32@40
^{__C3DSkinner=}56@0:8q16@24@32@40@48
^{__C3DSkinner=}40@0:8@16Q24Q32
@56@0:8@16@24@32@40@48
@112@0:8@16@24@32@40{SCNMatrix4=ffffffffffffffff}48
^{__C3DSkinner=}16@0:8
^{__C3DSkinner=}
B36@0:8B16d20d28
@"CADisplayLink"
@40@0:8@16Q24^@32
@48@0:8@16@24@32Q40
B48@0:8@16@24Q32^@40
B40@0:8@16Q24^@32
{__zFlags="providerSuppliesContents"b1"providerSuppliesStreams"b1"providerSuppliesProperties"b1"noContentsCaching"b1"fileOpen"b1"reserved"b27}
[5^v]
@"SCNView"16@0:8
v24@0:8@"SCNView"16
v24@0:8@"SCNCameraController"16
f20@0:8f16
v24@0:8f16B20
v28@0:8f16f20f24
v32@0:8{CGPoint=dd}16
24@0:8@16
(?={?=ffff})16@0:8
B32@0:8^{__C3DNode=}16^{C3DSphere=}24
@"UIGestureRecognizer"
(?="vector""center"""{?="x"f"y"f"z"f"radius"f})
{?="stickyMoveEnabled"B"direction""pickedAxis"Q"userStickyAxis"Q}
{?="automaticLocationUpToDate"B"hasAutomatic"B}
{?="lastDragLocation"{CGPoint="x"d"y"d}"velocity"{CGPoint="x"d"y"d}"lastDragTime"d}
{?="lock"{os_unfair_lock_s="_os_unfair_lock_opaque"I}"keyCodeConfiguration"@"NSDictionary""keyDown"{set<unsigned short, std::__1::less<unsigned short>, std::__1::allocator<unsigned short> >="__tree_"{__tree<unsigned short, std::__1::less<unsigned short>, std::__1::allocator<unsigned short> >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned short, void *> > >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::less<unsigned short> >="__value_"Q}}}"forward"{vector<unsigned short, std::__1::allocator<unsigned short> >="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::__1::allocator<unsigned short> >="__value_"^S}}"backward"{vector<unsigned short, std::__1::allocator<unsigned short> >="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::__1::allocator<unsigned short> >="__value_"^S}}"left"{vector<unsigned short, std::__1::allocator<unsigned short> >="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::__1::allocator<unsigned short> >="__value_"^S}}"right"{vector<unsigned short, std::__1::allocator<unsigned short> >="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::__1::allocator<unsigned short> >="__value_"^S}}}
{?="hasShift"B"hasOption"B}
@"SCNCameraController"
@"<SCNCameraNavigationControllerDelegate>"
@"SCNView"
@56@0:8@16{SCNVector3=fff}24@36{SCNVector3=fff}44
@36@0:8@16{SCNVector3=fff}24
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""anchorA"{SCNVector3="x"f"y"f"z"f}"anchorB"{SCNVector3="x"f"y"f"z"f}}
^{btPoint2PointConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]{btVector3=(?=[4f])}{btVector3=(?=[4f])}iffB{btConstraintSetting=fff}}
v20@0:8i16
@"SCNPhysicsVehicle"
@24@0:8^{__C3DParametricGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=ffffffffffffiiiiiiiiiiiI}{?=^?^?^?^?^?^?}^{__CFData}}16
v24@0:8^{__C3DParametricGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=ffffffffffffiiiiiiiiiiiI}{?=^?^?^?^?^?^?}^{__CFData}}16
@40@0:8d16d24d32
@36@0:8@16^{__C3DEngineContext=}24B32
v44@0:8@16@24^{SCNMTLBlitCommandEncoder=@@}32B40
@32@0:8^{__C3DImage=}16B24i28
B48@0:8^{__C3DImage=}16@24@32i40B44
@44@0:8@16Q24^{__C3DEngineContext=}32B40
@44@0:8@16Q24@32B40
@32@0:8^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}16^{__C3DEngineContext=}24
@40@0:8^{__C3DImageProxy={__CFRuntimeBase=QAQ}{?=^?^?^?^?}^vC}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^{__C3DEngineContext=}32
@44@0:8^{__C3DImage=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24i32^{__C3DEngineContext=}36
v48@0:8{CGPoint=dd}16{CGSize=dd}32
v24@0:8f16f20
v52@0:8f16{CGPoint=dd}20{CGSize=dd}36
{?=}24@0:8o^f16
{?=[4]}48@0:81632
v56@0:8{CGPoint=dd}16{CGSize=dd}32d48
v64@0:8{CGPoint=dd}16{CGSize=dd}32{CGPoint=dd}48
48@0:8{CGPoint=dd}16{CGSize=dd}32
{?=}32@0:8{?=}16
B48@0:8{CGPoint=dd}16{CGSize=dd}32
{?="angles""initialAbsoluteAngles""initialTransformWorld"{?="columns"[4]}"initialOrientationWorld"{?="vector"}}
{?="start""current""last"}
{?="localArcballAdjustement""sphereLocationStart""sphereLocationCurrent"}
{?="inertiaEnabled"B"inertiaRunning"B"lastSimulationTime"d"friction"f"rotationSensitivity"f"translationSensitivity"f"velocity""timer"@"NSTimer"}
@"<SCNCameraControllerDelegate>"
44@0:816f24{CGSize=dd}28
v24@0:8^{__C3DEngineNotificationQueue={__CFRuntimeBase=QAQ}^{__CFDictionary}^{__CFDictionary}{os_unfair_lock_s=I}dBBB^v}16
^{__C3DEngineNotificationQueue={__CFRuntimeBase=QAQ}^{__CFDictionary}^{__CFDictionary}{os_unfair_lock_s=I}dBBB^v}16@0:8
@48@0:8@16@24@32@40
@48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
@56@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@48
{CGSize=dd}32@0:8{CGSize=dd}16
v48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
{CGRect={CGPoint=dd}{CGSize=dd}}24@0:8@16
@"<SCNEventHandler>"
@"SCNSpriteKitEventHandler"
^{__C3DFXProgram=}
^{__CFSet=}
^{__C3DFXProgram=}48@0:8^{__C3DProgramHashCode=}16^{__C3DEngineContext=}24@32^v40
^{__C3DFXProgram=}40@0:8^{__C3DProgramHashCode=}16^{__C3DEngineContext=}24^v32
@32@0:8@?16i24B28
v36@0:8@16i24@?28
v40@0:8@16i24B28@?32
v40@0:8@?16@?24@?32
q40@0:8@16@24Q32
v64@0:8@16@24^{__C3DFXMetalProgram={__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^v^{__CFDictionary}^vQ}32^{__C3DMaterial=}40^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}48^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}56
{?="stage"i"arguments"@"NSArray""customBlocks"@"NSDictionary""pass"^{__C3DFXPass}}
@24@0:8^{__C3DMorph=}16
#24@0:8@16
^{__C3DMorph=}16@0:8
q24@0:8@16
d24@0:8@16
v32@0:8d16Q24
d24@0:8Q16
^{__C3DMorph=}
^{SCNCActionSequence=^^?f@?@BdddddBB@?^{__CFString}qdddd{vector<SCNCAction *, std::__1::allocator<SCNCAction *> >=^^{SCNCAction}^^{SCNCAction}{__compressed_pair<SCNCAction **, std::__1::allocator<SCNCAction *> >=^^{SCNCAction}}}Qd}
@48@0:8{CGPoint=dd}16@32@40
{CGPoint=dd}40@0:8{CGPoint=dd}16^B32
{CGPoint=dd}32@0:8{CGPoint=dd}16
@"UIWindow"
@"UIView"
^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}
^{SCNCActionMove=^^?f@?@BdddddBB@?^{__CFString}qdddddBB}
v40@0:8^{__C3DScene=}16@24@?32
v48@0:8^{__C3DScene=}16@24@32@?40
@32@0:8r^d16q24
@40@0:8r^{SCNVector3=fff}16q24^q32
@40@0:8r^{CGPoint=dd}16q24^q32
@76@0:8@16@24q32B40q44q52q60q68
@68@0:8@16@24q32s40Q44q52q60
@32@0:8r^{SCNVector3=fff}16q24
@32@0:8r^{CGPoint=dd}16q24
@44@0:8r^f16q24B32^{CGColorSpace=}36
@76@0:8@16^{CGColorSpace=}24q32B40q44q52q60q68
@64@0:8@16Q24@32q40q48q56
@84@0:8@16@24^{CGColorSpace=}32q40B48q52q60q68q76
@96@0:8@16^{CGColorSpace=}24^^{CGColorSpace}32q40q48q56q64q72^q80^q88
s16@0:8
r^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}16@0:8
@56@0:8@16Q24Q32Q40Q48
^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}
^{CGColorSpace=}
@60@0:8@16q24q32q40B48q52
@48@0:8@16q24q32q40
{_NSRange=QQ}16@0:8
^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I{?=qq}CB}^vfff^v^{__C3DMeshSource}[2]^{?}I}16@0:8
^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I{?=qq}CB}^vfff^v^{__C3DMeshSource}[2]^{?}I}
{_NSRange="location"Q"length"Q}
{AVAudio3DPoint=fff}16@0:8
v28@0:8{AVAudio3DPoint=fff}16
@24@0:8^{__C3DEngineContext=}16
v48@0:8{SCNVector3=fff}16{SCNVector3=fff}28@40
v48@0:8@16{CGPoint=dd}24@40
^{__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}
{?="weakProgram"^{__C3DFXProgram}"baseIndex"I"baseVertex"I"vertexSize"I"allocatedVerticesSize"I"allocatedIndicesSize"I"textureImage"^{__C3DImage}"texture"^{__C3DTexture}"drawMode"C"orthographic"B"clearDepthBuffer"B"enableDepthTest"B"enableCulling"B"isDynamic"B"mesh"^{__C3DMesh}"meshElement"^{__C3DMeshElement}"_cache"{?="verticesStride"Q"colorsStride"Q"uvsStride"Q"verticesData"*"colorsData"*"uvsData"*}"_usedMeshes"@"NSMutableSet""_freeMeshes"@"NSMutableSet""_usedMeshElements"@"NSMutableSet""_freeMeshElements"@"NSMutableSet"}
{?="textureInfo"{?="texture"^{__C3DImage}"textureSize"{CGSize="width"d"height"d}"isRetina"B}"lineHeight"d"characterWidth_texture"s"characterWidth_typography"^d"characterHeight_texture"s"symbolRects"^{?}}
[64000C]
@"NSSet"
@"NSMutableOrderedSet"
{?="initialized"B"showFullStatistics"B"showRenderOptionsPanel"B"fps"f"waitDisplayLinkTime"f"pressedButtonIndex"q"fpsString"^{__CFString}"shortString"^{__CFString}"internalString"^{__CFString}"lightingStatistics"[9I]"stats"{__C3DEngineStats="verticesProcessed"I"primitivesProcessed"I"drawCount"I"drawStep"I"frameCount"I"fboSwitches"I"vboSwitches"I"attSwitches"I"attEnabling"I"iboSwitches"I"vaoSwitches"I"prgSwitches"I"texSwitches"I"rssSwitches"I"getCount"I"uniformFloatSent"I"uniformIntSent"I"uniformVector2Sent"I"uniformVector3Sent"I"uniformVector4Sent"I"uniformMatrix4Sent"I"vboUploaded"I"iboUploaded"I"texUploaded"I"cpuTime"d"cstrTime"d"phyTime"d"prtTime"d"animTime"d"skinTime"d"mrphTime"d"rendTime"d"twoDTime"d"delegateTime"d"glFlushTime"d"waitDisplayLinkTime"d"drawableWaitTime"d"gpuTime"d"lastDisplayLinkTime"d"prgCount"I"texCount"I"fboCount"I"vboCount"I"rboCount"I"iboCount"I"cboCount"I"vaoCount"I"fboMemory"I"rboMemory"I"vboMemory"I"iboMemory"I"cboMemory"I"texMemory"I"backBufferMemory"I"depthBuffersMemory"I"onlineShaderCount"I"onlineShaderCompilationTime"d"renderPipelineCount"I"renderPipelineCompilationTime"d"computePipelineCount"I"computePipelineCompilationTime"d"frmAvgTime"d"frmMinTime"d"frmMaxTime"d"frameTimeHistory"[60d]"frameTimeCurrentIndex"I"startTime"d"lastFrameTime"d}}
@"SCNAuthoringEnvironment2"
{SCNMatrix4=ffffffffffffffff}80@0:8{SCNMatrix4=ffffffffffffffff}16
v40@0:816q32
{C3DSphere=}16@0:8
v48@0:8{CGPoint=dd}16q32Q40
{C3DSphere="vector"}
^{SCNCActionRotate=^^?f@?@BdddddBB@?^{__CFString}qddddfBBBBB}
v56@0:8^{__C3DFXMetalProgram=}16@24@32@?40@?48
^{__C3DRendererContext={__CFRuntimeBase=QAQ}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBB^{__CFDictionary}I^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}{Cache=[8I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^vii}{?=[2I][5i][14{?=iII}][14I]^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}24@0:8^{__C3DEngineContext=}16
v40@0:8^{__C3DEngineContext=}16{CGSize=dd}24
^{__C3DTexture=}52@0:8{CGSize=dd}16^{__C3DEngineContext=}32^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}40B48
^{__C3DFramebuffer=}
@48@0:8^{__C3DEngineContext=}16@24@32@40
v32@0:8@16^{__C3DEngineContext=}24
B64@0:8@16{CGSize=dd}24Q40@48^@56
@72@0:8@16{CGSize=dd}24@40@48:56^v64
v24@0:8:16
@"NSError"
@56@0:8@16{CGSize=dd}24@40@48
v56@0:8^{CGImage=}16{?=qiIq}24@48
v72@0:8{?=qiIq}16@40^{__CVMetalTextureCache=}48@56@?64
@"AVAssetWriterInput"
@"AVAssetWriterInputPixelBufferAdaptor"
@"AVAssetWriter"
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""axisA"{SCNVector3="x"f"y"f"z"f}"anchorA"{SCNVector3="x"f"y"f"z"f}"axisB"{SCNVector3="x"f"y"f"z"f}"anchorB"{SCNVector3="x"f"y"f"z"f}"minLinearLimit"d"maxLinearLimit"d"minAngularLimit"d"maxAngularLimit"d"motorTargetLinearVelocity"d"motorMaximumForce"d"motorTargetAngularVelocity"d"motorMaximumTorque"d}
^{btSliderConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}BB{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}BffffffffffffffffffffffffffffBBi[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}][3f][3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]f{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffBfffBfff}
^{SCNCActionScale=^^?f@?@BdddddBB@?^{__CFString}qddddfffffBB}
{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}24@0:8@16
@"CALayer"16@0:8
@24@0:8@"NSString"16
@40@0:8{SCNVector4=ffff}16@32
@36@0:8{SCNVector3=fff}16@28
@88@0:8{SCNMatrix4=ffffffffffffffff}16@80
v32@0:8@"CAAnimation"16@"NSString"24
v32@0:8@16@"NSString"24
@"CAMediaTimingFunction"16@0:8
v24@0:8@"CAMediaTimingFunction"16
@"UIColor"48@0:8d16d24d32d40
v24@0:8@"NSArray"16
^{CGPath=}16@0:8
v24@0:8^{CGPath=}16
@"<SCNCameraControlConfiguration>"16@0:8
@"SCNCameraController"16@0:8
@"CAAnimation"16@0:8
v24@0:8@"CAAnimation"16
@24@0:8@"CAAnimation"16
@"SCNPhysicsBody"16@0:8
@80@0:8@"SCNPhysicsBody"16{SCNVector3=fff}24{SCNVector3=fff}36@"SCNPhysicsBody"48{SCNVector3=fff}56{SCNVector3=fff}68
@48@0:8@"SCNPhysicsBody"16{SCNVector3=fff}24{SCNVector3=fff}36
v40@0:8@"NSString"16q24@?<v@?@"<SCNBufferStream>"@"SCNNode"@"<SCNShadable>"@"SCNRenderer">32
v40@0:8@"NSString"16@"NSString"24@"NSDictionary"32
@"NSString"24@0:8@"NSString"16
@"<SCNProgramDelegate>"16@0:8
v24@0:8@"<SCNProgramDelegate>"16
@"<MTLLibrary>"16@0:8
v24@0:8@"<MTLLibrary>"16
d24@0:8q16
v32@0:8d16q24
@"SCNMorpher"16@0:8
@"SCNGeometry"16@0:8
@32@0:8@"SCNGeometry"16d24
v72@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@"<MTLCommandBuffer>"56@"MTLRenderPassDescriptor"64
v64@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@"<MTLCommandBuffer>"48@"MTLRenderPassDescriptor"56
v32@0:8@"NSArray"16d24
@32@0:8^v16@"NSDictionary"24
@32@0:8@"<MTLDevice>"16@"NSDictionary"24
v24@0:8@"SCNAudioPlayer"16
v32@0:8@"SCNNode"16Q24
v32@0:8@"SCNNode"16@"SCNNode"24
@"SCNNode"28@0:8@"NSString"16B24
@"NSArray"24@0:8@?<B@?@"SCNNode"^B>16
v24@0:8@?<v@?@"SCNNode"^B>16
{SCNVector3=fff}36@0:8{SCNVector3=fff}16@"SCNNode"28
{SCNMatrix4=ffffffffffffffff}88@0:8{SCNMatrix4=ffffffffffffffff}16@"SCNNode"80
@"NSArray"48@0:8{SCNVector3=fff}16{SCNVector3=fff}28@"NSDictionary"40
v24@0:8@"SCNParticleSystem"16
@"SCNNode"24@0:8@"NSString"16
@"SCNLight"16@0:8
v24@0:8@"SCNLight"16
@"SCNCamera"16@0:8
v24@0:8@"SCNCamera"16
v24@0:8@"SCNGeometry"16
@"SCNSkinner"16@0:8
v24@0:8@"SCNSkinner"16
v24@0:8@"SCNMorpher"16
v24@0:8@"SCNPhysicsBody"16
@"SCNPhysicsField"16@0:8
v24@0:8@"SCNPhysicsField"16
@"<SCNNodeRendererDelegate>"16@0:8
v24@0:8@"<SCNNodeRendererDelegate>"16
@"SCNNode"24@0:8@"SCNGeometry"16
@24@0:8@"MDLObject"16
@56@0:8@"SCNPhysicsBody"16{SCNVector3=fff}24@"SCNPhysicsBody"36{SCNVector3=fff}44
@36@0:8@"SCNPhysicsBody"16{SCNVector3=fff}24
v32@0:8@"SCNMaterial"16Q24
v32@0:8Q16@"SCNMaterial"24
@"SCNMaterial"24@0:8@"NSString"16
@"NSArray"24@0:8@"NSString"16
@"SCNGeometryElement"24@0:8q16
@"SCNMaterial"16@0:8
v24@0:8@"SCNMaterial"16
@"SCNGeometryTessellator"16@0:8
v24@0:8@"SCNGeometryTessellator"16
@"SCNGeometryElement"16@0:8
v24@0:8@"SCNGeometryElement"16
@"SCNGeometrySource"16@0:8
v24@0:8@"SCNGeometrySource"16
@32@0:8@"NSArray"16@"NSArray"24
@40@0:8@"NSArray"16@"NSArray"24@"NSArray"32
@24@0:8@"MDLMesh"16
@"SCNMaterialProperty"16@0:8
@"NSURL"16@0:8
v24@0:8@"NSURL"16
@24@0:8@"MDLLight"16
@24@0:8@"MDLMaterial"16
v40@0:8q16@"NSArray"24@?<v@?^^v^Q^Iq>32
v40@0:8@"NSArray"16q24@?<v@?^^v^Qqqf>32
@"SCNParticleSystem"16@0:8
@32@0:8@"NSString"16@"NSString"24
@32@0:8@"SCNPhysicsBody"16@"NSArray"24
@24@0:8@"SCNNode"16
@32@0:8@"SCNGeometry"16@"NSDictionary"24
@32@0:8@"SCNNode"16@"NSDictionary"24
@60@0:8@"NSData"16q24q32q40B48q52
@48@0:8@"NSData"16q24q32q40
@24@0:8@"MDLSubmesh"16
@76@0:8@"NSData"16@"NSString"24q32B40q44q52q60q68
@"SCNScene"32@0:8@"NSDictionary"16@?<v@?fq@"NSError"^B>24
@"SCNScene"32@0:8@"NSDictionary"16^@24
@32@0:8@"NSString"16#24
@"NSArray"24@0:8#16
@"NSArray"24@0:8@?<B@?@@"NSString"^B>16
@32@0:8@"NSURL"16@"NSDictionary"24
@32@0:8@"NSData"16@"NSDictionary"24
@24@0:8@"MDLCamera"16
v32@0:8d16@"SCNNode"24
d24@0:8@"SCNNode"16
v32@0:8@16@"<NSCopying>"24
@"SCNTechnique"24@0:8@"NSDictionary"16
@"SCNTechnique"24@0:8@"NSArray"16
v24@0:8@"SCNPhysicsBehavior"16
@"NSArray"40@0:8@"SCNPhysicsBody"16@"SCNPhysicsBody"24@"NSDictionary"32
@"NSArray"32@0:8@"SCNPhysicsBody"16@"NSDictionary"24
@"NSArray"160@0:8@"SCNPhysicsShape"16{SCNMatrix4=ffffffffffffffff}24{SCNMatrix4=ffffffffffffffff}88@"NSDictionary"152
@"<SCNPhysicsContactDelegate>"16@0:8
v24@0:8@"<SCNPhysicsContactDelegate>"16
@"SCNPhysicsShape"16@0:8
v24@0:8@"SCNPhysicsShape"16
@32@0:8q16@"SCNPhysicsShape"24
@28@0:8B16@?20
@28@0:8B16@?<{SCNMatrix4=ffffffffffffffff}@?@"SCNNode"{SCNMatrix4=ffffffffffffffff}>20
@28@0:8B16@?<{SCNVector3=fff}@?@"SCNNode"{SCNVector3=fff}>20
@28@0:8B16@?<{SCNVector4=ffff}@?@"SCNNode"{SCNVector4=ffff}>20
@32@0:8d16@?<v@?@"<SCNAnimation>"@B>24
@"SCNAction"16@0:8
@?<f@?f>16@0:8
v24@0:8@?<f@?f>16
@"SCNAction"48@0:8d16d24d32d40
@"SCNAction"36@0:8{SCNVector3=fff}16d28
@"SCNAction"52@0:8d16d24d32d40B48
@"SCNAction"44@0:8d16{SCNVector3=fff}24d36
@"SCNAction"40@0:8{SCNVector4=ffff}16d32
@"SCNAction"32@0:8d16d24
@"SCNAction"24@0:8@"NSArray"16
@"SCNAction"32@0:8@"SCNAction"16Q24
@"SCNAction"24@0:8@"SCNAction"16
@"SCNAction"24@0:8d16
@"SCNAction"24@0:8@?<v@?@"SCNNode">16
@"SCNAction"32@0:8@?<v@?@"SCNNode">16@"NSObject<OS_dispatch_queue>"24
@"SCNAction"32@0:8@"NSString"16d24
@"SCNAction"32@0:8d16@?<v@?@"SCNNode"d>24
v88@0:8@"SCNParticleSystem"16{SCNMatrix4=ffffffffffffffff}24
B48@0:8@"NSURL"16@"NSDictionary"24@"<SCNSceneExportDelegate>"32@?<v@?f@"NSError"^B>40
@"SCNPhysicsWorld"16@0:8
@40@0:8@"NSString"16@"NSString"24@"NSDictionary"32
@40@0:8@"NSURL"16@"NSDictionary"24^@32
@24@0:8@"MDLAsset"16
@"SCNPhysicsField"32@0:8d16d24
@"SCNPhysicsField"24@0:8@?<{SCNVector3=fff}@?{SCNVector3=fff}{SCNVector3=fff}ffd>16
^{btRaycastVehicle=^^?{btAlignedObjectArray<btVector3>={btAlignedAllocator<btVector3, 16>=}ii^{btVector3}B}{btAlignedObjectArray<btVector3>={btAlignedAllocator<btVector3, 16>=}ii^{btVector3}B}{btAlignedObjectArray<float>={btAlignedAllocator<float, 16>=}ii^fB}{btAlignedObjectArray<float>={btAlignedAllocator<float, 16>=}ii^fB}iiff^{btVehicleRaycaster}fff^{btRigidBody}iii{btAlignedObjectArray<btWheelInfo>={btAlignedAllocator<btWheelInfo, 16>=}ii^{btWheelInfo}B}}16@0:8
@"SCNPhysicsBody"
^{btRaycastVehicle=^^?{btAlignedObjectArray<btVector3>={btAlignedAllocator<btVector3, 16>=}ii^{btVector3}B}{btAlignedObjectArray<btVector3>={btAlignedAllocator<btVector3, 16>=}ii^{btVector3}B}{btAlignedObjectArray<float>={btAlignedAllocator<float, 16>=}ii^fB}{btAlignedObjectArray<float>={btAlignedAllocator<float, 16>=}ii^fB}iiff^{btVehicleRaycaster}fff^{btRigidBody}iii{btAlignedObjectArray<btWheelInfo>={btAlignedAllocator<btWheelInfo, 16>=}ii^{btWheelInfo}B}}
^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}16@0:8
v24@0:8^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}16
^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}
@120@0:8{?=^{__C3DFXMetalProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}CCCB@{?=C@?}}16@112
^{__C3DFXMetalProgram=}20@0:8B16
v344@0:8@16{?={?=^{__C3DFXMetalProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}CCCB@{?=C@?}}@{?=[8Q]QQC}^{__C3DBlendStates}[8Q]@@@@@?BBBB}24@336
@328@0:8{?={?=^{__C3DFXMetalProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}CCCB@{?=C@?}}@{?=[8Q]QQC}^{__C3DBlendStates}[8Q]@@@@@?BBBB}16
@56@0:8{?=@@@BBB}16@48
^{SCNCActionRepeat=^^?f@?@BdddddBB@?^{__CFString}qdddd^{SCNCAction}QQdB}
v20@0:8C16
@"AVPlayer"
@"AVPlayerItemVideoOutput"
^{__CVMetalTextureCache=}
^{__CVBuffer=}
B48@0:8@16I24I28@32@40
v48@0:8@16I24I28@32@40
^{__C3DFXTechnique=}16@0:8
^{__C3DFXGLSLProgram=}24@0:8q16
v32@0:8^{__C3DFXGLSLProgram=}16@24
@"SCNProgram"
@64@0:8@16@24@32@40q48Q56
@"<SCNShadable>"
v24@0:8^{__C3DTextGeometry={__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}{?=^{__CTFrame}^v^viiBBB{CGRect={CGPoint=dd}{CGSize=dd}}}}16
@24@0:8^{__C3DTextGeometry={__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}{?=^{__CTFrame}^v^viiBBB{CGRect={CGPoint=dd}{CGSize=dd}}}}16
{?={?=cddid^v^v}^v^viiBB{CGRect={CGPoint=dd}{CGSize=dd}}d}16@0:8
@"UIBezierPath"
@"UIFont"
{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}
v24@0:8^{__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}16
@24@0:8^{__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}16
{?=cddid^v^v}16@0:8
v40@0:8@16q24d32
@40@0:8@16q24^{__C3DLOD=}32
^{__C3DLOD=}
7> }#>
